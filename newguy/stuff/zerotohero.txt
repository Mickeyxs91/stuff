





15/2/2022 : 9:49.....
--------------------------
start----------------------------1.what is docker?---------------------------------

i.what is docker?
-----------------
docker is basically a tool that allows us to easily 
create
deploy and
run applications inside containers 

and heres comes the question....what is a container? container is something that we talk later.....
however keep in mind that  the main concept or attribute of docker is that it runs containers.

example a
in linux cmd i will connect to one machine that i have 

e.g. mike@CO-devopingguy:~$ ssn -i ~/aws_linuxfacilito.pem centos@35.171.121.237 -p 2626

so now i am just in a machine in a linux machine locked in by ___ssh___ and basically i have this ip which is my public ip
___35.171.121.237___ 
and now i will expose the service-server on port 1010 on my browser
___35.171.121.237:1010___
now if i hit enter you will probably see nothing and this is because nothing is running here ___35.171.121.237:1010___

and now what i am going to do is to logging to my machine:
mike@CO-devopingguy:~$ ssn -i ~/aws_linuxfacilito.pem centos@35.171.121.237 -p 2626
and i will spin up up a container on port 1010 

and i will just create a container which will hold and then the next web server 

[centos@ip-172-31-87-182 ~]$ docker run -d -p 1010:80 nginx:alpine

flags......
-d  :
-p  : expose one port

the idea here is to depict how easy it is to create a container...now the system will create the container 
now if i hit 

[centos@ip-172-31-87-182 ~]$ docker ps -l

the linux terminal show that there is a container up and running on port 1010

CONTAINER ID   IMAGE          COMMAND                     CREATED         STATUS          PORTS                    NAMES
6867fhgfh56    nginx:alpine   "nginx -g 'daemon of...'"   18 seconds ago  up 17 seconds   0.0.0.0:1010->80/tcp     vibrant

now the refresh on the browser will bring the site in front

now what if i want to delete the container
this can be achieved with the command 

[centos@ip-172-31-87-182 ~]$ docker rm -fv 6867fhgfh56

basically we created an nginx web server by running the following line:

[centos@ip-172-31-87-182 ~]$ docker run -d -p 1010:80 nginx:alpine

which we can running it as many times we want and delete it the same times

but if i take the big line of this image and perform deletion 
[centos@ip-172-31-87-182 ~]$ docker rm -fv cf0e2555558934e67dshj7687sdjbdjhjsgsd98dsdg723e

then the service is basically no longer alive 

and this is the power of docker 
it allows you to spin up a container...access the service and do whatever you want and once you want to kill it you did like :

[centos@ip-172-31-87-182 ~]$ docker rm -fv cf0e2555558934e67dshj7687sdjbdjhjsgsd98dsdg723e

and your container is no longer alive, and you can do this for anything that you want
you are going to have your:
web server
API
web application
database 
wordpress site 
press to ship site
and whatever you want to put in a container and thats we are going to learn  


ii.what is container?
---------------------
 
in this section we are going to learn what is a container and for that we are going to draw some sketches here in notepad
so in the first place what is a container?

operating system 
_____________________________
|      cgroups              |
|        |     namespace    |
|        |       /          |
|        |      /           |
|        |     /            |     
|     ________              |    
|    |  [..]  |             |
|    |  ----  |->container  |
|    |  |  |  |             |
|    |  |  |  |             |
|    |  ----  |             |
|    |________|             |
|___________________________|

note most containers these days run in linux....in the operating system above think that you are running a bunch of processes 
that are like 
___
| |
| |
___
because basically thats the nature of an OS....to run processes like:
ssh
user interface  
web server 

again what is a container?
as the word tells you a container is nothing but a process which is located in something called a namespace 
so say that we want to isolate these processes from the operating system 
and i want to isolate the process  and also control the resources that this container may use 
or
i want to have this seperated from all of the other processes and i dont want any kind of communication from the processes
of our container to the other processes

so this is like...i am just putting these content in a sandbox, when we say sandbox is like we say isolation

* say that i am isolating this process in a container 

so basically i have a container which isolates the process that is running from the other processes 
so here we have two important concepts
one for container is 
i.the namespace which is basically the id or the name of the process of this container
  so this will be started in a sandbox which is namespace and that will be like the id of the process
ii.we have something which is called c-groups which allows us to limit the cpu to memory and a lot of resources so you can limit 
your container to do only the things that you want it to do  
basically this is the most fundamental concept or notion of what a container is 

inside a container there is nothing else but a process inside of a sandbox, which is called a container
a container contains a process  which runs in a namespace and has cgroups to control it,
and well i said that there is only one process here but typically in docker you only run one process per container but of course 
if you wanted you could just go ahead and inside of the container above you could spin up another process ([.....]) which will live with this process
and these processes will be able to talk to each other because 
they are in the same container 
they are sharing the same namespace and 
they are sharing the cgroups here  

so basically is the most fundamental notion of a container....its a container a sandbox which contains typically one process
it could be more than one and this inherits a namespace and the cgroups to control what the container can do 


iii.what is an image?
---------------------
if we take a look on the operating system above we already know that this is a container which it has two processes in it.
typically it has one 
but in this case we just created two 
but this process is in a sandbox which gives it a namespace and some cgroupd to control it...
but now the question is...okk this is the container
but how do i create a container ? thats another good qusetion 
and then is where the concept of the image comes on the way 
then you may be wondering what is an image?.....
we can say that an image is a lot of layers in one hook and pack thing
which has a parent and child relationship.
so let me draw some things here and put a description  



so here on top of every single image in docker we have something called scratch  
(in other words we have an image that is called scratch)
and scratch is the base for every image that you are going to build in docker 
so as its the base...its like an empty representation for operating system
its basically nothing 
but its like the base that you ned to use to start build in images 
so you will always have this kind of base....the scratch image will always be the base 
ok now that we have this base  you know that this empty 
                                                _________
                                                |scratch|
                                                _________
                                                /
                                               /
so                                            /
we need to put something on top of this image    
we need the basics of an operating system remember because in an operating system we run processes 
so we need something that is under the operatiing system which could be:
centos
devian
redhat
ubuntu
alpine
busybox
lets say that we want busybox....we draw a line (which represents the parent relationship between scratch image and busybox ) 
from  scratch image to this 
         _________                                                                                         _________
because  |scratch|   is the parent  and the line --------------- that binds it with the second layer       |busybox|
         _________                                               or  second level of hierarchy that        _________
                                                                 we have here  
                                        
ok now on top of the scratch image we have now the busybox image which is kind of an operating system and contains all of the libraries that 
are the operating system needs to run its processes.
and now   now that we have this layer of an operating system we are going to pick up again  the relationship line from busybox layer to another layer 
and there lets say that we are going to put some services some processes which will run in the busybox guy  
which could be be any process lets say nginx or an apache 

so you can see that in an image [IMAGE]
basically we have our parent relationship which starts from scratch and the on top of the scratch we put an operating system (busybox)
and then on top of the operating system (busybox) we put some processes (apache) which will run in this operating system  

but if i modify the busybox layer the apache layer on top of it is also going to be modified because scratch is the parent of everything but then 
at the same time busybox is also parent of the apache layer 

what happens if for example you want to put something on top of the apache layer?

lets say a cache  service for example 
and basically this is basically the representation of how an image looks like, how this skeleton for an image  
it starts fromm scratch then it gives you the basics for an approach and a system that you can put on top of that layer at busybox then 
on top of that layer you can apache process and on the layer of apache put cache services
but keep in mind that scratch image is the parent of all 


          cache
     ______________
            |
            |
          apache
     ______________
            |
            |
        busybox
     ______________
            |
            |
     ______________
         scratch


so it is obvious that if i change a parent layer somewhere all its childs must be modified too
and by talking about this there comes a new quetsion which is 

then how do i build an image?
that is going to be answered in the next section (conainers vs virtual machines)

iv.containers vs virtual machines 
----------------------------------

in this section we analyze the following two images 


______________________________________________________________________________________________
            container                                    virtual machines
___________________________________             ____________________________________
container a container b container c               vm a          vm b            vm c    
___________________________________             ____________________________________  
   app a        app b       app b                 app a         app b           app c
___________________________________            ______________________________________   
   libs         libs        libs                  libs          libs            libs
___________________________________            __________________________________________   
           D  O  C  K  E  R                      guest os      guest os         guest os
___________________________________            __________________________________________
        host operating system                            H y p e r v i s o r
___________________________________            __________________________________________
            infrastracture                                 infrastracture
______________________________________________________________________________________________



 so basically we see the difference between containers and virtual machines 
 basically a container is a sandbox that contains processes........one process or more than one 
 and here in the infrastracture layer which could be where yopur application is deployed 
 then we have the  host operation system  and then we have docker installed in our operating system
 and 
 in docker we can create the spaces (app  a....libs) which in practice they are containers and we can have the application or the processes  
 inside of this container which was created from an image 
 so in the libs we can have all of the libraries we have the nginx the apache and in general all of tyhe services that we need to build an application 
so we have 
container a with all of it processes 
container b and container c 

so for example we can have 
container a which is our web server 
container b which is our database
container c which is our already service for caching or things like that
and as yoou see they are all independent if we wanted to delete them we just delete container c and this action is not affects 
the other containers as this action dont affect the operating system 
we didnt install any library in it because everything is contained in the container because thats the whole notion of the container....it should contain everything 
so we souldn't install anything on the host operating system because everything is going to be contained in the container itself 



so how is the thing with virtual machines?

well itsway different here because we have again the same infrastracture (cloud,aws, on premise....it doesn't matter)
then we have the hypervisor which is kind of a manager for all the virtual machnies 
and in order to accomplish this infrastracture...this tiny infrastracture here which has a web server a database in a ready service we would need to spin up 
three virtual machines  and each one of these machines should have an guest operating system approved in the system 
and in the container's example we only have one because the container example is only one machine --->docker
but on the example of virtual machines we have three machines 
so here instead of having the container with the web service we are basically installing the web server in the operating system 
and opposed to container's example we have the operating system but we are just creating a sandbox to isolate that web server process (app, libs etc..)
same thing here in the virtual machine number two we have the second service which is installed in the system 
lets say the database 
but in the docker's example we have on the same machine we have another sanbox __container b__ which contains the data of this service 

so the differences among containers and virtual machines are is that in virtual machines we are using a lot of resources because you need at least one gig in RAM 
just to spin up the os in vm a  another gig in vm b and another in vm c 
which means 3 gigabytes in ram
 
in the docker you will need probably one gig or two 

an the second thing here in vms is that you are having a lot of resources which are probably not being used 
on the other hand in Dockers you can easily create containers and you can restrict the resources that they are going to use 

but here comes the collest thing in Docker compared to virtual machines........
what if you want to delete everything here and you want to recreate it.....
what if you want to delete everything  ?

you say docker delete them 
and all of the containers are gone and the operating system is not impacted 
but in the vms you have all of your libraries  and dependencies installed on the virtual machine itself 
so if you want to destroy this then  you must destroy the entire virtual machine or going manually an start unistalling all of the dependencies and the libraries that you 
installed here 
so in vms you finisg this task in a couple of hours and in dockers a couple of seconds 

so docker is pretty cool


v.basics of a dockerfile
---------------------------
here we are going to talk about dockerfile,
do you remember the image tha we make above that shows how containers are created, and we have an image which contains all of the 
information which is kind of a template or snapshot that will be instantiated as a container 
it also had the image that contains all the information and then we just create a container or a bunch of containers  that are based on the parent image
which is kind of a snapshot thing



operating system 
_____________________________________________
|      cgroups                               |
|        |     namespace                     |
|        |       /                           |
|        |      /             ____________   |
|        |     /             |            |  |      
|     ________               |            |  |    
|    |  [..]  |              | image      |  |
|    |  ----  |->container   |            |  |
|    |  |  |  |              |____________|  |
|    |  |  |  |                              |
|    |  ----  |                              |
|    |________|                              |
|____________________________________________|







so now how do we build images ?
and here is were dockerfile comes in, which is nothing but a plain text file that you define the instructions to create your image 
so typically a docker file starts with 
from which is an instruction that says......OK i want this guy (centos,httpd,nginx,redis etc.) as an operating system (later)
so these instructions could be the centos that gives you the binaries that are going to be used as a base for the operating system
about the scratch image this is important for you to know but you are not going to be using it because this is a default thing that happens in the background 
so you dont really need to care about this 



          cache
     ______________
            |
            |
          apache
     ______________
            |
            |
        centos
     ______________
            |
            |
     ______________
         scratch


then second you have the running instructions that are based on the operating system that you choose and they will give you the ability to 
install (appropriate) packages

say that you choose ubuntu to the __from__ instruction then you say apt-get to the run instruction 
if you choose a red hat based like centos to the __from__ instruction you say "yum -y install httpd"
if you choose alpine the you say apk at something

but in this case we are picking up centos and then we are picking up  the httpd installation which is the apache installation 
----------------------------
from centos
copy yum -y install httpd
cmd apachectl-DFOREGROUND
----------------------------

and this could be the layer that sits on top of the centos image and installs the application or leverage that your application need to run 
and finally you could do more things....install more things if you want you could copy things from the outside to the image and do everything 
that your application needs to run.

 ----------------------------
from centos-------------------------------> here we have the operating system as a base  
copy yum -y install httpd-----------------> libraries that the application needs 
cmd apachectl-DFOREGROUND-----------------> in here normally cmd demands that command that  will be triggered once the container gets created 
                                            so basically here we are starting the apache service on the foreground    
----------------------------

in a nutshell 
hey docker file yes you start from centos
then isntall appropriate libraries (it could be every libraries you want)
and finally 
use apachectl-DFOREGROUND command to start the service  
*if you install a service of course you need to start it....yiu need to start the process....you need to start the apache process for you to be able to go to the 
 browser and see your website.

so this the most basic notion of the docker file: 
its just a text file that allows you to define the instructions that should be run for your image to be created (image which is under construction)
images are created through the use of the docker file....


vi.docker's architecture
------------------------


                container <------manages______ _____manages--------->image
                                              | 
                            __________________|_________________
                                |          client           |
                                |        docker cli         |
                                |    ___________________    |
                                |    |    Rest api     |    |           
                                |    | _______________ |    |
   network <------manages______ |    | |   server    | |    |_____manages--------->data volumes
                                |    | |docker daemon| |    |
                                |    | _______________ |    |
                                |    |_________________|    |
                                |___________________________|

here we are going to talk about docker architecture we are going to see how docker's structured 

important to know 
how a container is created 
how the processes are respond 
what is an image 
what is a namespace 
what does cgroup....really important  

so lets keep going to this architecture section and lets see how docker works in the docker host ?
what is a docker host?
lets say that you have a machine a virtual machine or a real machnine it doesn't really matter
and you want to install docker in this machine 
so once you install docker on your machine or  your computer or in any server, then automatically
that server becomes a docker host 
....why a docker host?
well its because its hosting a docker service at docker server  actually 
so your machine that has docker installed is actually capable to run containers and build images 
so that we call a docker host...docker host is basically the house of all of the containers that you will be creating from now on 

then we have a couple of cool things on the image above 
we have the server which is the docker daemon and that is the process that is started once you install docker 
so when you install docker basically you are setting up a server which is a docker server and then you will have a client and then you will say  

docker my man please create one container  
docker my man please remove this container

and that going to be declined....thats how you are going to inrteract with docker server
but 
you cannot talk to the server without an API 

so basically what you do is that you say OKKK docker please run this and once you say that  then the client 
its going to talk to the server through an API
so you will be using the client which is the CLI to send API requests to the dameon
the daemon will respond you back using the same API to give you an answer 

so that how the client gets communicate with the server through an API
so remember that at any time that you are typing commands in the command line you are basically doing API calls to the server and the server 
is giving you back a response 

now with the client remember that you will talk to the server but with the client you can manage 
containers
images 
networks
stuff and 
volumes 

so basically through the cli you will be managing everything 


vii.Layering in docker
-----------------------


_________               _________             _________          _________
| docker|               |docker |             |docker |          |docker  |
---------------        ---------------        ---------------    ---------------
this r/w layer         this r/w layer         this r/w layer     this r/w layer
---------------        ---------------        ---------------    ---------------
     \                     |                  /                    /                
      \                    |                 /                    /
       \                   |                /                    /
        \                  |               /                    /
         \                 |              /                    /
          \                |             /                    /
           \               |            /                    /
            \              |           /                    /
             \             |          /                    /
              \            |         /                    /
                ---------------------------------        /
                 91e54dfb1179                  0B       /
                 ---------------------------------     /
                 ---------------------------------    /
                 d74508fb6632              1895 KB---/----->copy files or we do things 
                 ---------------------------------  /
                 ---------------------------------
                 c22013c84729             194.5 KB----->install apache
                 ---------------------------------
                 ---------------------------------
                 d3a1f33e8a5a              188.1MB ----->installing sshd
                 ---------------------------------
                         ubuntu: 15.04 image
            ____________________________________________

images and containers are two concepts  that are a way powerful  in docker
and the image is template where you defind all of the binaries all of the libraries that your application will need 
and the container is nothing else but the runtime of the image 
so you can have one template as an image and then you can just create as many containers as you want using that image 
but the thing here is that i wanted you to show you the ubuntu image above 
so this image is composed by layers 
do you remember the from instruction the run instruction the cmd instruction 
all of these are layers 

so in the image above we have an ubuntu layer thateach layer as depicted above performs a specific task
but the thing that must be known here is that the layers above are read only layers 
so once you create an image you cannot modify any layer in that  image 
instead what you can do is that you can create another image and start from the layer that you want

so for example you have the layers above and lets say that here  c22013c84729 194.5 KB
you have an apache webserver 
and here 
d74508fb6632  1895 KB you are copying some source code 
now say that you want to update the code in these layer d74508fb6632 because you updated something right 
but remember that the layers in image are read only so cant update these layer 
then what you can do is to create another image starting from the layer of the apache web server c22013c84729 
and then you can add  a new layer here with your new source code 

and basically you would have another image here which contains the layers:
c22013c84729  (apache)
d3a1f33e8a5a  (sshd)

but the other two are not there because in the new image we have make modifications and thus the layers 
91e54dfb1179
d74508fb6632 (copy files or we do things)

will be different on the new image 


so at the end you will end up with two images 
the old one which could be your version 1 
the second one which could be your version 2 

and thats how images are managed in docker....version one version two 
we actually version images because we cannot modify an image 
so we constantly building new images and the we need to remove the old ones and all of that 

a layer in an image isn read only you cannot modify a layer 
you could start from one layer back from the layer you want to perfom changes or start doing things on top of that
and that means  creating new images  

so the ubuntu image above is an image, your entire representation of your application in read only   
but remember that this is kind of a template and with this template you can launch as many containers as you want 

but there is something cool here and that is that you can create containers which are going to be running instances of your image 
basically when you create a container you add a new layering here on top of the image  e.g. above  layer
 91e54dfb1179                  0B
 which is read and write layer 
 and that means that you can modify the content of the image in the layer that was added  
 but wait 
 the content is not going to be impacted because the layer is a temporary layer and info  that you need from the layers
of the ubuntu image  is going to be copied in the to the new layer on top of the image 
by docker automatically 
so remember that that the images are read only but whenever you spin up a new container you are basically creating a new layer at read and write layer 
on top of the image and then you can access all of the content of the image and you can modify it in the read and write layer 
once the container gets destroyed i mean once the layering here disappears then the changes that you made are going to dissapear as well 
so please keep in mind that an image is read only and you can spin up as many containers as you want using that image.
and basically when you create a container what happens is that you put our read and write layer on top of the your image and you can access thge data 
from the image temporarrily here (the new layering here on top of the image)
but once you delete the container everything is gone and the only one thing that is left is your image 
 

viii.Quiz 1: are you ready?
---------------------------

i.containers are created based on images
ii.permissions in the image's layers are read only
iii.docker client and docker daemon communicate each other through rest api

       *so lets keep going to this architecture section and lets see how docker works in the docker host ?
       what is a docker host?
       lets say that you have a machine a virtual machine or a real machnine it doesn't really matter
       and you want to install docker in this machine 
       so once you install docker on your machine or  your computer or in any server, then automatically
       that server becomes a docker host 
       ....why a docker host?
       well its because its hosting a docker service at docker server  actually 
       so your machine that has docker installed is actually capable to run containers and build images 
       so that we call a docker host...docker host is basically the house of all of the containers that you will be creating from now on 

       then we have a couple of cool things on the image above 
       we have the server which is the docker daemon and that is the process that is started once you install docker 
       so when you install docker basically you are setting up a server which is a docker server and then you will have a client and then you will say  

       docker my man please create one container  
       docker my man please remove this container

       and that going to be declined....thats how you are going to inrteract with docker server
       but 
       you cannot talk to the server without an API 

       so basically what you do is that you say OKKK docker please run this and once you say that  then the client 
       its going to talk to the server through an API
       so you will be using the client which is the CLI to send API requests to the dameon
       the daemon will respond you back using the same API to give you an answer 
       so basically what you do is that you say OKKK docker please run this and once you say that  then the client 
       its going to talk to the server through an API
       so you will be using the client which is the CLI to send API requests to the dameon
       the daemon will respond you back using the same API to give you an answer 

       so that how the client gets communicate with the server through an API
       so remember that at any time that you are typing commands in the command line you are basically doing API calls to the server and the server 
       is giving you back a response 

iv.the layer in a container is temporary

       there is something cool here and that is that you can create containers which are going to be running instances of your image 
       basically when you create a container you add a new layering here on top of the image  e.g. above  layer
       91e54dfb1179                  0B
       which is read and write layer 
       and that means that you can modify the content of the image in the layer that was added  
       but wait 
       the content is not going to be impacted because the layer is a temporary layer and info  that you need from the layers
       of the ubuntu image  is going to be copied in the to the new layer on top of the image 
       by docker automatically 
       so remember that that the images are read only but whenever you spin up a new container you are basically creating a new layer at read and write layer 
       on top of the image and then you can access all of the content of the image and you can modify it in the read and write layer 
       once the container gets destroyed i mean once the layering here disappears then the changes that you made are going to dissapear as well 
       so please keep in mind that an image is read only and you can spin up as many containers as you want using that image.
       and basically when you create a container what happens is that you put our read and write layer on top of the your image and you can access thge data 
       from the image temporarrily here (the new layering here on top of the image)
       but once you delete the container everything is gone and the only one thing that is left is your image 

v.Permissions in the containers' layers are: read and write

       so remember that that the images are read only but whenever you spin up a new container you are basically creating a new layer at read and write layer 
       on top of the image and then you can access all of the content of the image and you can modify it in the read and write layer 
       once the container gets destroyed i mean once the layering here disappears then the changes that you made are going to dissapear as well 
       so please keep in mind that an image is read only and you can spin up as many containers as you want using that image.
       and basically when you create a container what happens is that you put our read and write layer on top of the your image and you can access thge data 
       from the image temporarrily here (the new layering here on top of the image)
       but once you delete the container everything is gone and the only one thing that is left is your image 

vi.A Docker Host is:

       what is a docker host?
       lets say that you have a machine a virtual machine or a real machnine it doesn't really matter
       and you want to install docker in this machine 
       so once you install docker on your machine or  your computer or in any server, then automatically
       that server becomes a docker host 
       ....why a docker host?
       well its because its hosting a docker service at docker server  actually 
       so your machine that has docker installed is actually capable to run containers and build images 
       so that we call a docker host...docker host is basically the house of all of the containers that you will be creating from now on 


what you know.....

i.containers are created based on images
ii.permissions in the image's layers are read only
iii.docker client and docker daemon communicate each other through rest api
vi.A Docker Host is:

what you should review
iv.the layer in a container is temporary
v.Permissions in the containers' layers are: read and write


viii.references
---------------

Hello!

Here you have more info:

Overview: https://docs.docker.com/engine/docker-overview/

Slides: https://docs.google.com/presentation/d/15EJh6TbtLMLvQInehuFzUrJqJ5Io5MR2NDZbSp1T_Qg/edit?usp=sharing



ix.Bonus
---------

Do you want to learn Jenkins from scratch? Take a look at the BESTSELLER course here, at Udemy!

There's a special discount for students.

https://learndevopsnow.wordpress.com/

No worries, you can finish this course and then come back.

Best regards,


---------------------------------1.what is docker?------------------------------end

16/2/2022 : 10:04.....
--------------------------
start----------------------------2.installation---------------------------------

x.installation on ubuntu
------------------------

untill now we have talk a little bit about how docker works what is a container what is an image  
and now that we have a basic understanding about this 
we are going to get our hands diry and we are going to start playing around with docker in terminal 
so in these videos we are going to cover the installation for 
ubuntu
debian
centos 
fedora  

so based on your distribution you can just follow the steps for that distribution
but in this videos i will be showing you how to install docker in each of those distributions 
so if you have your laptop with ubuntu or centos go ahaead

or you can create a virtual machine in virtual box or be more whatever you want and you can install docker dirty tester 


so no we are going to create a machine in __aws__ which is pretty easy 
so we will use 
__launch an instance__
and lets try to do it on an ubuntu machine but before doing anything 
we google
__docker for ubuntu__ (get docker ce for ubuntu | docker documentation)
and there we see that docker is available for certain distributions for certain versions 
so for ubuntu you have here your requirements 

you need at least ____ubuntu xenial 16.04 (LTS)____
or probably it will be in complain 

so lets go ahead and look in aws what we have....in the search we type ___ubuntu___ 
and take a look at this one  ___ubuntu 18.04 LTS-bionic___
and the number aggreese with the bionic 18.04 (LTS)
so we are going to pick up this version of ubuntu to install docker 
and pick up this image ___ubuntu 18.04 LTS-bionic___
so i am going to to do it fast because its simple to launch a machine here and then you click next next next xaxaxaxxa

then in step 3: configure instance details
in the ___auto-assign public ip___ we select  enable 

then in step 6: configure security group 
in the __assign a security group:___ we select an existing security group which is going to be the default (default vpc security group)
then review and launch and finally launch
and in the pop up 

"select an existing key pair or create a new key pair" 

tick on the I acknowledge that i have......and press launch instances

so basically what i am doing here is just i create a virtual machine using ubuntu  

you can use your own laptop if you can create a virtual machine 
so lets get to this instance and lets wait i=until is ready or succesful  or start it
so then we copy the ip from the 
__IPv4 Public IP__ text box
and i am going to connect to  this ip using   ____ssh____

so now we back to our terminal 
and through the following commands   
we connect to the machine 


'docker' is not recognized as an internal or external command, operable program or batch file.
i didnt set the ___docker path to enviromental variables_____

now i can run always to my folder 

but before we need to run our docker desktop application.......


C:\Users\michael.kourbelis\Desktop\realstuffv1 > docker pull ubuntu:20.04

and Docker prints the digest of the image after the pull has finished.

20.04: Pulling from library/ubuntu
Digest: sha256:669e010b58baf5beb2836b253c1fd5768333f0d1dbcb834f7c07a4dc93f474be
Status: Downloaded newer image for ubuntu:20.04

Docker also prints the digest of an image when pushing to a registry. This may be useful if you want to pin to a version of the image you just pushed.

A digest takes the place of the tag when pulling an image, for example, to pull the above image by digest, run the following command:

C:\Users\michael.kourbelis\Desktop\realstuffv1 > 669e010b58baf5beb2836b253c1fd5768333f0d1dbcb834f7c07a4dc93f474be



Digest can also be used in the FROM of a Dockerfile, for example:

FROM ubuntu@sha256:82becede498899ec668628e7cb0ad87b6e1c371cb8a1e597d83a47fac21d6af3
LABEL org.opencontainers.image.authors="some maintainer <maintainer@example.com>"



and to test this we run the command 
C:\Users\michael.kourbelis\Desktop\realstuffv1 >  docker run hello-world

and it runned it
as it made uderstood and in super opposed to aws services  in windows it doesn't need a lot of stuff of installation 

you just use 
-docker pull ubuntu:20.04
-docker run hello-world




linux another time as we have windows and aws asks fro my credit card and i dont want to give it right now 
........

xii.installation on centos
-----------------------------
here we are going to install docker for centos and for fedora 
usually the first thing to do is if you have other machines in aws dashboard is to delete them first 
and create the new one 

so 
we google ___docker for centos____ in order to find the requirments of this 


xiii.installation on windows & mac os
----------------------------------------

---------------------------------2.installation------------------------------end


start----------------------------3.resource for this course---------------------------------

xiv.where can i get the samples used in this course?

       Hey, guys!

       I will leave here a GitHub repo where you will find every single file that we created in the course.

       https://github.com/ricardoandre97/docker-en-resources

       Happy Dockerizing!

---------------------------------3.resource for this course------------------------------end

start----------------------------4.Docker images your first touch---------------------------------

xv.what is the official docker image?

here we are going to learn a little bit about images for docker 
well do you remember that i created a machine in aws from now on i will be using this machine to work with docker
so depending on your distribution you can use ubuntu, centos, devean or fedora 

windows are not recommended for docker creation as dockers natively run on 
and most of the environments that you are going to see in the real world are on top of linux 

it is really recommended to install a virtual machine  with centos or ubuntu or devian or fedora and install  docker

and we are going to talk about something which is an official image  
well what is an official image  ?
first remember what is an image....
an image is nothing but a package that contains everything that your application need to run 
no worries we learn to create our own images later......

buut for now we talk a little bit about official images okkkk
so there is a lot of open source software as you know...lets talk about software like 
apache
nginx 
mongodb 
mariadb
mysql

all are open source, and the thing is that these guys for example the guys from nginx or the guys from   mongodb
they have created docker images for those services 
and those images already contain apache or nginx or mysql or mongo
so those are precreated images that you can use right away 
so let go to google  
and search for _____docker hub_____ which is a place in the cloud where all the world is towards images 
so its basically a centralized repository for public images for official images 
now lets look for _____docker nginx____
and you see that the first result of google is the docker hub lets click here and see that it takes you straight forward 
to docker hub and as you see this image is created by the nginx team
so these guys are literally maintianing the image 
so you can trust this image because it is maintained by the nginx team 
now lets take a quick summarry....we know that most of the open source prijects like nginx apache mysql mongo 
the have their own docker official image already built in docker hub
so you can go at any time and download that image 
note the question is how do you download that image? and thw answer is super easy......
if you see we have one line which says 
____docker pull nginx_____
nginx is the name of the image  so basically if you give this command to your terminal you are going to see that something is downloaded 
and the thing that gets downloaded is nothing else but the nginx image which is pulled directly from docker hub 
------------------------------------------------------------------------
and docker hub stores images so that you can pull it from the internet so thats great 
------------------------------------------------------------------------
now here we have something and is that we can have versions of this image.......
do you remember that i told you about versioning images?
well we go to the docker hub's section 
supported tags and respectives dockerfile links and there you can find all the versions of the 
specific image that you demanded at google before 
a version is nothing else but a specific version of that image at certain oint in time lets say:
nginx v1
nginx v1.1
.....

so these guys are giving you support around the tags that you can use to pull this image 

C:\Users\michael.kourbelis\Desktop\realstuffv1 > docker pull nginx

Using default tag: latest
latest: Pulling from library/nginx
Digest: sha256:2834dc507516af02784808c5f48b7cbe38b8ed5d0f4837f16e78d00deb7e7767
Status: Image is up to date for nginx:latest

C:\Users\michael.kourbelis\Desktop\realstuffv1>

so here is a tricky thing if you dont use any tag during the pull of the image you will download the latest image  
as you can see here 
latest: Pulling from library/nginx

example with tag 
C:\Users\michael.kourbelis\Desktop\realstuffv1 > docker pull nginx:1.15.12

so this way you say ok docker please the pull will be made from docker hub using the nginx : 1.15.12
now 
if we download a different version of the above for example 

C:\Users\michael.kourbelis\Desktop\realstuffv1 > docker pull nginx:1.16.0-alpine-powerful

we will get the information that this layer is already exists 
do you remember when i told you about layers in the images which is the parent and child relationship?
well this the second image we pull ( docker pull nginx:1.16.0-alpine-powerful) 
is a layer that is the parent  and it was downloaded somewhere above it 
as when you download that image_____ docker pull nginx:1.16.0-alpine-powerful____
that layer got reused and then you just downloaded the part that you needed 
which 
is super great
as you dont need to download the whole layer from ___ docker pull nginx:1.16.0-alpine-powerful____
because it already exists on your machine 

so in this video we learn what is an official image and an official image are nothing else but a package that is created by the team who provides 
the project for example 
nginx team create an nginx docker image 
apache team create an apache docker image 
mongo db creates a mongodb docker image

now you know how to download that image to your computer 
now you know how to download a specific version of that image 
and 
you know that whenever you download something from docker hub and if you have some layer which is already presence on your computer docker will not 
downloaded again because it already exists in your machine 

so for a challenge one that you could do is to go to docker hub and look for apache image mongodb image and try to download them to you local machine 
later........

xvi.where are my local image?
-------------------------------

here we ar going to complete the challenge that has been given to the previous lesson 

so lets go and google 
docker mysql.....mysql-docker hub

and you see staright the command which without tag will download the latest version of docker mysql image 

C:\Users\michael.kourbelis\Desktop\realstuffv1 > docker pull mysql

so lets download now the version 5 of mysql 

C:\Users\michael.kourbelis\Desktop\realstuffv1 > docker pull mysql:5.7

so lest hit eneter and lets see what happens.....so great as you see here we have some layers which were pooled previously using the command 

____docker pull mysql_____

and now docker is trying a different version of this image but docker figured out that you already have some layers which are used by this image and then docker 
will not download these layers again because they already exist in your local machine  
so docker will reuse these layers and on top of these layers docker will download the amazing things 
so this is great 

not it comes a question okkkk we have done load it like four images but where are our images ?
how can i find my images ?
how an image look like and well to find our images or to see the images that we have downloaded or the images 
that we have downloded or the images that we have 
we can type

C:\Users\michael.kourbelis\Desktop\realstuffv1 > docker images 

and if you hit enter the you will see a list of all the images that you have 

REPOSITORY          TAG                 IMAGE ID            CREATED             VIRTUAL SIZE
nginx               latest              sha256:c316d        3 weeks ago         141.5 MB
nginx               <none>              sha256:c316d        3 weeks ago         141.5 MB

C:\Users\michael.kourbelis\Desktop\realstuffv1>


 
*it doesn't matter if you downloade the image from docker hub or if you created those images 
all the images that you have will be displayed byt the command above 
 
now lets say that for some reason i dont want a specific image e.g. i made a mistake and i dont want to see this image here 
now how i delete this image ?.....its pretty simple 
you type 

docker rmi (remove image) and you pass its name or its id but if the image has a tag you need to provide the tag of the image 
for example
C:\Users\michael.kourbelis\Desktop\realstuffv1 > docker rmi nginx:1.15.12  

many times we must delete the image container before we delete it but first we need to stop it first 

C:\Users\michael.kourbelis\Desktop\realstuffv1 > docker stop "container name or container id"  
C:\Users\michael.kourbelis\Desktop\realstuffv1 > docker rm "container name or container id"  

then we perform the image remove 

so here we learned  
how to see images
how to delete images
how to use tags and images  

this is when we have create and the image container with the run command


xvii.create your first docker container
----------------------------------------
in this lesson we are going to create a basic container using the image that we have downloaded 
ok so no we know how to download images right 
but now 
how do we use these images ?
how do we create a container using these images that we just download ?

so the first look is to our images 
 
we go to download mysql

C:\Users\michael.kourbelis\Desktop\realstuffv1 > docker pull mysql
sha256:92d27b8222bbcf53bc42c70ca7cd1010d6c0527efc61f14980ce77c50932bef4

 C:\Users\michael.kourbelis\Desktop\realstuffv1 > docker images 

REPOSITORY          TAG                 IMAGE ID            CREATED             VIRTUAL SIZE
mysql               latest              sha256:d1dc3        2 weeks ago         519.4 MB
mysql               <none>              sha256:d1dc3        2 weeks ago         519.4 MB
nginx               latest              sha256:c316d        3 weeks ago         141.5 MB
nginx               <none>              sha256:c316d        3 weeks ago         141.5 MB

C:\Users\michael.kourbelis\Desktop\realstuffv1>

basically lets pull nginx:alpine 

 C:\Users\michael.kourbelis\Desktop\realstuffv1 > docker pull nginx:alpine  
 sha256:da9c94bec1da829ebd52431a84502ec471c8e548ffb2cedbf36260fd9bd1d4d3

and we want to create a container using the nginx:alpine
how do we do this ?

well that is pretty easy....we will have an entire section for containers but for now we just create a very basic container using docker and some image 
so in order to create a container you hit 
docker run.....run stands for running containers and every time you type run, that means that you are about to create a new container 
so we are going to say that we want this to be in detached mode (so we use flag -d ) which means in the background   
then we say that we want the image and the image is going to be nginx:alpine

 C:\Users\michael.kourbelis\Desktop\realstuffv1 > docker run -d nginx:alpine  
 
without flag -d ___docker pull nginx:alpine ___ we have a basic example which will be described thoroughly
here :
docker please my man create a new container from the engine alpine image that i just created and its going to be cool 
so if we try to run this we succeed to run it on the foreground and we want to be able to do anything because what will be 
printed-produced below the command ___docker pull nginx:alpine ___ is actually a stuck here  

so thats why we use detached mode which means that this is going to run in the background so we terminate this with ctrl+C
and we are be shown something from the video

so what if we try to delete our image that upon it we create and its container ?
the terminal is going to ask to  stop and delete ots container before you delete the image  

 C:\Users\michael.kourbelis\Desktop\realstuffv1 > docker ps -l
 and we see that have a container that was exited 17 seconds ago so remember we created a container with this line   

 
 C:\Users\michael.kourbelis\Desktop\realstuffv1 > docker run  nginx:alpine   

but it was on the foreground, so basically we must terminate it using ctrl+c and the container just exited 
so we need to remove this guy 

C:\Users\michael.kourbelis\Desktop\realstuffv1 > docker stop "container name or container id"  
C:\Users\michael.kourbelis\Desktop\realstuffv1 > docker rm "container name or container id

before we couldn't delete the image because it was used from the container 

the question is what happens if i just run the line below again with detached mode and create the container 

 C:\Users\michael.kourbelis\Desktop\realstuffv1 > docker run -d nginx:alpine  

 then the docker is able to find that its image is not longer exist and displays that the image is not locally available 
 and its pulled automatically by docker hub and that image is downloaded and after the image is downloaded 
 then a new container is created using that image and you can see the container that you have 
 through docker ps


  C:\Users\michael.kourbelis\Desktop\realstuffv1 > docker ps


the container we care about is the one that we createe 26 seconds ago
if you see this guy is a random guy because we didn't provide any name around its name was assigned to this container 
as you see we have here the container which is running 

now  how do we test that this container works.....we need to expose a port 

i am just taking this probably i am doing a lot of things here but i just want you to see how easy it is to create a container 
we have an entire section of containers...but for now lets test hor to create a sample container with an official image 

so we remove everyting and recreate it from the start 
important note wehn the container is up and running we must stop it first or we type docker rm -f "container name".....-f is flag that means force

now we are going to run the exact same line  to create again  the same container with the same image but we are going to apply a new argument, which is port 
and port allows us to expose a port in our machine.....we talk about this later but for now we look at the variables of the following line 

docker run -d -p 9090:nginx:alpine 


-p 9090:80 ....i will use the port 9090 in my machine which is the docker host and based in centos machine  and i will map it to the 80 port in the container 
 because in the container the service is running on port 80

 but i want to do a mapping to my host on port 9090.....so basically its like port forwarding or "nat rules" things like that 
 again we talk about it later 
 but i just want you to see how to create a container using an official image 
 so remember this again with a 
 
 docker run.....which is to create a container 
 -d....to put it to the background 
 -p....to say ok pleaseu use my port, the port of my machine and map it to the port 80 of the container  
 and 
 use the image nginx:alpine 

 and now the cmd gives us a hash which is the container id and we can say  docker ps to see our container that is up and running 

 now how do we test it well its simple to test it remember that here in the port section after the 9090 port of our machine 
 which is pointing to the port 80 on the container that we made above 

 now lets test it....we go to our aws we take the IPv4 Public IP as in the case you make it on a remote machine  
 and in the case of using your laptop you can use your localhost

 so in the view of a remote machine we use the ipv4 

 so in the browser we give the ipv4 and provide the port 9090  ---> 35.171.121.237:9090 and now we have an nginx up and running 

 and use docker rm -f "container id"

 however if we go and run exactly  the same line to spin up a new container to create a new container on the same port  
   

  C:\Users\michael.kourbelis\Desktop\realstuffv1 > docker run -d -p 9090:80 nginx:alpine

  in the view you refresh it you see your site is up again

  so its super easy to create a container from an oficial image because the image itself contains everything that nginx need to run  
  so we just need to run the image, probably expose some port that we want put it in the background and that all 



*just keep in mind that once you have an image you can just create a container or as many containers you want using that image 


xviii.what is dockerfile
------------------------
in this section we are going to create our firts image...our first custom image....lets think that for some reason 
you are looking for a docker image of an official image 
lets say that you are looking for apache and php  but for some reason you cant find a version of the packages  that you need 
lets say that you need apache 2.1 and php 5.6 which is super deprecated but you dont find then anywhere 
so you are forced to build your own image 
you are forced to create your own image because you cannot find anything that suits your needs in internet.
so basically yhats why you create your own images because you don't find any internet or something that is cool for you 
or probably you find something but you see that you can do it better 
or because you just want to do everythibg by yourself.....and thats great because that's learning 
or probably your company doesn't allow you to reuse images on the internet and forces you to create their own images 
so yes there are a lot of reasons to build your own images 

so we are going to learn how to build our custom images right 

so remember that i told you that if we want to create an image we need a docker file and a docker file is nothing else 
but a simple file where you define all of the configuration for your application.
so lets go to our terminal 
and what we are going to do is to create our folder 
or if we have our folder ready we path it to the terminal and get in

  C:\Users\michael.kourbelis\Desktop\realstuffv1 >

  so right now we have nothing inside this folder because this is a brand new folder that we just created 
  so the first thing we need to do to build our own images is of course to create a docker file 
  so you can use any text editor that you want 
  you can do it in sublime  etc....

  vi is a text editor for linux and is at the terminal level

  vi dockerfile --> command that creates a new simple text file a plain text file called dockerfile
  and if i hit enter i can just edit the content of this file  

  so to build our own images and as it is said before we need to make use of some keywords 
  the first keyword is the keyword 
  ____from___
  from is the first  instruction in our dockerfile because using from you say from where you want to take the images as a base 
  so the good news is that we already have official images that contains operating systems 
  lets go to google and if you want your container to run in centos then you google for 
  ___docker image centos_____ 
  and then in the docker hub you are going to find that someone already created an image for centos and 
  centos team actually created an image for centos which is an official image 
  so you can use it with no problem 
  but lets say that you want to build your image from ubuntu then you google for 
  ___docker image ubuntu_____ 
  and then in the docker hub you are going to find that ubuntu team already created ubuntu official images
  you can downloaded it and you can just pick up the tag that you want and start using the images so thats super great

  in this case we are going to use centos to test it and especially we are going to use ____centos:7____
  and in the docker hub we can see that we must do ____docker pull centos____ 
  so if we search a little bit in the centos image section in the docker hub   in "supported tags and respective dockerfile links"
  we can see that we have a lot of text which means that we have available centos 6,7.....
  we use centos 7 which is the latest tag 
  so remember that if we dont pass any tag to the iamge the system by default puuls the latest image of that
  if you pass that tag then the system is going to pull the appropriate tag which is going to be used
  so we are going to say 
  from centos......and basically in from....the from instruction what we do is that we start from another image 
  in this case we are going to start from another image  
  in this case we are going to start from centos image 
  i just want to point out something in   and that is....that it doesn't really matter which version or which linux distribution you are running 
  on your docker host 
  in this case remember that i am running centos but you could be running ubuntu or devian or it doesn't really matter 
  you can use any image that you want here, you can start from ubuntu and go forward, backward some legends say that you can go and upwards above the clouds
  so it doesn't matter if your operating system doesn't match the distribution that you are using in your image because that are completely different things.
  
  so lets start to create our dockerfile with centos with no tags to pull the latest version of this image
  ........from centos
  so now we have centos tiny operating system.....now what we want to do with this ? thats a good question 
  so lets say that we want to install apache, we want to create an image in centos which will have apache  
  and you know its going to whenever we run the container we will spin up an apache server 
  so it comes a question and it is how do we install a apache in centos? (to install a packege and send those polly kalo,polly kalo xaxaxaxa)
 well if you dont know lets just google it and find the answer   

 ____install apache on centos 7?___                                                  install apache centos 7 without internet
 how to install apache on centos 7|liquid web.....link that we will open
 and we need the packaging installation......___sudo yum -y install httpd___

 and we are going to use this instruction with the keyword run of the dockerfile, run is a a keyword that  we call whenever we want to run 
 something at the operating system level   
 so if you want to create a directory or a user you need to put the run instruction  so

 from centos
 run sudo yum -y install httpd 

 and something that you need to know is that by default images are super lightweight which means that they have not sudo buy default
 e.g. if you want sudo you need to install it but by default it doesn't come in the image 

 so we are going to remove the sudo as we dont have sudo in the images unless you install it right....



 from centos
 run  yum -y install httpd 

 so by default the user is going to be a root and he is going to have all of the privileges to do anything 
 you can later create more users you know to secure it 
 but we are going to look at it later       

 so we have here one layer which is the from layer and this layer is telling the docker 
 hey man please start from the centos image put it on top of this.....i want to use this image as a base 
 and then we are saying in the second layer ok man please run this command  __yum -y install httpd___
 which installs httpd in the centos image 
 and the resulting image will be an image that contains centos as a base and this httpd package installed
 so thats great  we save our docker file 
 and now it is time to turn this dockerfile into a real image 
 so we should  be able to see the image in this way right here 

right now our image is in the dockerfile...but how do we turn this into a real image....well we are going to learn it
in the next section....


xix.build your first image using dockerfile
-------------------------------------------
in this video we are going to build or we are going to turn this image-dockerfile to a real image remember that 
we have a docker file for now and this docker file only has from centos instructions and it has an apache installation  
so how do we turn this into a real image?
well here it comes the ____docker build command____
so this command allows you to create images from a docker file, so basically you say 
docker please  build a new image reading the instructions from this docker file 
 so we say 
 _____docker build____and then we need to provide the name of the result  of the image..... --tag -->which means the name of the result in image
 docker build --tag centos apache ....in this point here lets remember that if we dont pass any tag here we pull the latest version of the image 
so 
 docker build --tag centos_apache:v1 

 in this case lets say a version of one (v1) ok

 so we say here ok docker please build an image and the name of that image wil be centos_apache:v1  

 and the information will be taken from the dockerfile with capital D

 now at the end put a . which means that there is a file in the current directory with the name of the dockerfile
 and docker is going to look for that file in the current directory

 C:\Users\michael.kourbelis\Desktop\realstuffv1 > docker build --tag centos_apache:v1 .

 so lets hit enter and lets see what happens 



-------------------------------------------------------------------------------------------
C:\Users\michael.kourbelis\Desktop\realstuffv1>docker build --tag centos_apache:v1 .
Sending build context to Docker daemon 2.048 kB
Step 1/2 : from centos
 ---> 5d0da3dc9764
Step 2/2 : run  -y update install httpd
 ---> Running in d6b4f0c0c4af
/bin/sh: -y: invalid option
Usage:  /bin/sh [GNU long option] [option] ...
        /bin/sh [GNU long option] [option] script-file ...
GNU long options:
        --debug
        --debugger
        --dump-po-strings
        --dump-strings
        --help
        --init-file
        --login
        --noediting
        --noprofile
        --norc
        --posix
        --rcfile
        --rpm-requires
        --restricted
        --verbose
        --version
Shell options:
        -ilrsD or -c command or -O shopt_option         (invocation only)
        -abefhkmnptuvxBCHP or -o option

SECURITY WARNING: You are building a Docker image from Windows against a non-Windows Docker host. 
All files and directories added to build context will have '-rwxr-xr-x' permissions. 
It is recommended to double check and reset permissions for sensitive files and directories.
The command '/bin/sh -c -y update install httpd' returned a non-zero code: 2
-------------------------------------------------------------------------------------------

 C:\Users\michael.kourbelis\Desktop\realstuffv1 > docker build -t centos_apache:v1 .

  this is probably because we have not set our centos in aws service online

  lets search a little bit 

  FROM centos
  COPY backspace.html /usr/local/apache2/htdocs/backspace.html



C:\Users\michael.kourbelis\Desktop\realstuffv1> docker build -t pici .
Sending build context to Docker daemon 3.072 kB
Step 1/2 : FROM centos
 ---> 5d0da3dc9764
Step 2/2 : COPY backspace.html /usr/local/apache2/htdocs/backspace.html
 ---> 4ebea71e4a02
Successfully built 4ebea71e4a02
Successfully tagged pici:latest
SECURITY WARNING: You are building a Docker image from Windows against a non-Windows Docker host. 
All files and directories added to build context will have '-rwxr-xr-x' permissions. 
It is recommended to double check and reset permissions for sensitive files and directories.

C:\Users\michael.kourbelis\Desktop\realstuffv1>



but with 

FROM httpd:2.4
COPY backspace.html /usr/local/apache2/htdocs/backspace.html


it works....so something is happening with centos

ok so now i delete all the images and the containers from the terminal 
ny dockerfile is 

 from centos
 run  yum -y install httpd 

 and i run the command ___docker build -t centos_apache:v1 .____ from my dockerfile's location

 C:\Users\michael.kourbelis\Desktop\realstuffv1 > docker build -t centos_apache:v1 .

succesful installation, no i run __docker images___ abd i can see my image

C:\Users\michael.kourbelis\Desktop\realstuffv1>docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             VIRTUAL SIZE
centos_apache       v1                  sha256:a39b0        18 seconds ago      231.3 MB
centos              latest              sha256:5d0da        5 months ago        231.3 MB
centos              <none>              sha256:5d0da        5 months ago        231.3 MB

C:\Users\michael.kourbelis\Desktop\realstuffv1>




                                               spacea






____________________________ 2/10/2022____________________________
   ___________________
  |  2/10/2022 |
  _________________________________________________
  | Creating a Dockerfile With an Apache Web Server|
  __________________________________________________
        docker image   apache server   (2) :
    i  .     dockerfile 
    ii .  dockerfile
     (i)    folder      backspace.html  dockerfile   backspace.txt  
       documentation              .

        _________________________________________________________________________
             ------------
            | dockerfile |
             ------------
        
            FROM httpd:2.4
            COPY backspace.html /usr/local/apache2/htdocs/backspace.html
        _________________________________________________________________________


        _________________________________________________________________________
             ----------------
            | backspace.html |
             ----------------
        
            <!DOCTYPE html>
            <html>
            <head>
            <!-- head definitions go here -->
            </head>
            <body>
            <p>hiiii</p>
            </body>
            </html>
        _________________________________________________________________________


      obtain  Image   apache o       "username" ____httpd:2.4____
      
    _______backspace.html_______ 
     path 
    ___________/usr/local/apache2/htdocs/___________
               path apache 
    ___________/usr/local/apache2/htdocs/backspace.html___________

        
    docker build -t pici . 
       flag -t      image         tag  .. pici:8.8 .
     tag    column        Images    
      images    
           docker     directory      cmd 
                    .....

    C:\Users\michael.kourbelis\Desktop\dockerize >   
    docker build -t pici . 


    C:\Users\michael.kourbelis\Desktop\dockerize >   
    docker run -dit  --name picii -v "%cd%":/usr/local/apache2/htdocs -w /usr/local/apache2/htdocs -p 8080:80 pici
    docker run -dit  --name picii  -p 8080:80 pici

      -v  -w    
    -v  mount      docker,     docker image        Pc       Pc 
          
     mount Kati poy   Nas (storage)     upload images 

     -w.........

    -p :   Mapping  8080  80 
    -d :   datched mode      

          map  8080  80    html REPOSITORY        
      

     -w flag : (we dont really need to use this for one-off commands ) 
        declare  working directory  container     ___/usr/src/myapp___ 
     then the image name and the command we want to run 
 
finally,


    -dit  : d stands for daemon i is for interactive t is for sudo tty   
    -p    : our post flag allows us to connect  our host port 8080 to port 80 inside the container 
    -v    : our v flag allows us  to mount our present working directory(pwd) 
            to this directory :  __________/usr/local/apache2/htdocs/__________  
            which is the directory that apache will  monitor for files to host as websites
           -v    :
            (=mount)  pwd (linux version  "%cd%" windows version)  
    directory       container         backspace.html
              "html"
          download    (     ) 
    ..     php 
        backspace.php
         browser   backspace.php    backspace.html
      the following line    <?php echo "hello";?>   backspace.php
    
         refresh    browser       php   installed 
      apache container 
    
     -----------------------------
    *docekr rmi id force delete
    ---------------------------------

    

     so how we can get apache and php to play nicely inside of a container ?

     well we have a few options 
     i   . we can install php inside of a container running apache 
     ii  . we could also install apache inside of a php container      or
     iii . we could use a pre-build solution that is offered by the php docker hub repository  
     an image that has php and apache ready to go....
     lets find that image https://hub.docker.com/_/php
     lets see the official php docker images somewhere there must be the apache 
     and we can do  " docker pull php:apache " and pull this image to our container down 

      obtain  php 
    C:\Users\michael.kourbelis\Desktop\dockerize > docker pull php:apache

       image         Image     conflicts
    soooo 
    C:\Users\michael.kourbelis\Desktop\dockerize > docker ps
    CONTAINER ID   IMAGE     COMMAND              CREATED          STATUS          PORTS                  NAMES
    a79a623a12b7   httpd     "httpd-foreground"   42 minutes ago   Up 42 minutes   0.0.0.0:8080->80/tcp   pici

    C:\Users\michael.kourbelis\Desktop\dockerize > docker stop pici  .....stop it 
    pici
    C:\Users\michael.kourbelis\Desktop\dockerize > docker rm pici    .....remove it 
    pici

    *       Id  container we are good

    docker run -d -p 80:80 --name pici -v "%cd%":/var/www/html php:7.2-apache     ......from site 

    docker run -d -p 8080:80 --name pici -v "%cd%":/var/www/html php:apache       ......modified

    we make our local port 8080 connect to port 80 ( instead of port 80 ) inside of the container
    and second we use the php:apache tag instead of php:7.2-apache


    C:\Users\michael.kourbelis\Desktop\dockerize>docker run -d -p 8080:80 --name pici -v "%cd%":/var/www/html php:apache
    88719cee8112265ba46bc9a8552419821833884a0c8904cd4c9dda699c320a3b


    now lets go to our browser and hit what must be hitted


     
    with http://localhost:8080/backspace.php        
    with http://localhost:8080                "it works"


           moynt  directory         container 
  
    now we have a containerized version of apache running  the latest version of php and it is serving websites 
    from my present working directory i can easily start and stop the container and remove if this is what is required
    

    it works  with http://localhost:8080/backspace.html

   
    Orologia 
    stack service
    stack service discovery 
    ftiaxneis comport file kai ftiaxneis stacks omadopoihmena 

____________________________ 2/10/2022____________________________

























 ----------------Installing Apache Web Server using windows dockerfile--------------
 ---------------------i dont know-----------------------------

 1.download the apache msi file.....download the apache setup file 
 2.preparing the environment for installation 
 3.building apache windows container image 
 4.testing the apache image

 first we download it 

 https://archive.apache.org/dist/httpd/binaries/win32/
 .......... apache_2.2.8-win32-x86-no_ssl.msi    

 right click...save link as to  C:\Users\michael.kourbelis\Desktop\realstuffv1

 then in c folder we create a folder with the name __apache__
 and a subfolder with the name setup
 copy the 
 apache_2.2.8-win32-x86-no_ssl.msi  
 from   
 C:\Users\michael.kourbelis\Desktop\realstuffv1
 to 
 C:\apache\setup

 and in the apache folder create a Dockerfile

 and in the dockerfile write the followings...... that are 
 from https://github.com/assistanz247/APACHE/blob/master/dockerfile.....

 
#THIS DOCKER FILE IS DEVELOPED BY ASSISTANZ NETWORKS

#SPECIFY THE CONTAINER IMAGE

FROM microsoft/windowsservercore

#COPY THE APACHE INSTALLATION FILES INTO THE CONTAINER
ADD ./setup c:/apache

#INSTALLING APACHE
RUN ["msiexec.exe", "/i", "C:\\apache\\apache_2.2.8-win32-x86-no_ssl.msi", "/qn"]

#APACHE CONFIGURATION

RUN powershell.exe -command \

#COPY CUSTOMIZE HTTPD CONFIGURTION FILE TO APACHE conf FOLDER
copy-item c:/apache/httpd.conf -destination '"c:/program files (x86)/Apache Software Foundation/Apache2.2/conf"'; \

#INSTALLING APACHE SERVICE USING BATCH FILE
cmd.exe /c c:/apache/service.bat; \

#SET APACHE SERVICE TO RUN UNDER LOCAL SYSTEM ACCOUNT
sc.exe config apache2.2 obj=LocalSystem; \

#REMOVE THE APACHE SETUP FILES DIRECTORY
remove-item c:/apache -Recurse


now we create a batch file to register the apache service from... https://github.com/assistanz247/APACHE/blob/master/service.bat

cd\
cd Program Files (x86)\Apache Software Foundation\Apache2.2\bin
httpd.exe -k install


now it is high time to create a customize httpd.conf file.
that we download it from......https://github.com/assistanz247/APACHE/blob/master/httpd.conf

#
# This is the main Apache HTTP server configuration file.  It contains the
# configuration directives that give the server its instructions.
# See <URL:http://httpd.apache.org/docs/2.2/> for detailed information.
# In particular, see 
# <URL:http://httpd.apache.org/docs/2.2/mod/directives.html>
# for a discussion of each configuration directive.
#
# Do NOT simply read the instructions in here without understanding
# what they do.  They're here only as hints or reminders.  If you are unsure
# consult the online docs. You have been warned.  
#
# Configuration and logfile names: If the filenames you specify for many
# of the server's control files begin with "/" (or "drive:/" for Win32), the
# server will use that explicit path.  If the filenames do *not* begin
# with "/", the value of ServerRoot is prepended -- so "logs/foo.log"
# with ServerRoot set to "C:/Program Files (x86)/Apache Software Foundation/Apache2.2" will be interpreted by the
# server as "C:/Program Files (x86)/Apache Software Foundation/Apache2.2/logs/foo.log".
#
# NOTE: Where filenames are specified, you must use forward slashes
# instead of backslashes (e.g., "c:/apache" instead of "c:\apache").
# If a drive letter is omitted, the drive on which Apache.exe is located
# will be used by default.  It is recommended that you always supply
# an explicit drive letter in absolute paths, however, to avoid
# confusion.
#

# ThreadsPerChild: constant number of worker threads in the server process
# MaxRequestsPerChild: maximum  number of requests a server process serves
ThreadsPerChild 250
MaxRequestsPerChild  0

#
# ServerRoot: The top of the directory tree under which the server's
# configuration, error, and log files are kept.
#
# Do not add a slash at the end of the directory path.  If you point
# ServerRoot at a non-local disk, be sure to point the LockFile directive
# at a local disk.  If you wish to share the same ServerRoot for multiple
# httpd daemons, you will need to change at least LockFile and PidFile.
#
ServerRoot "C:/Program Files (x86)/Apache Software Foundation/Apache2.2"

#
# Listen: Allows you to bind Apache to specific IP addresses and/or
# ports, instead of the default. See also the <VirtualHost>
# directive.
#
# Change this to Listen on specific IP addresses as shown below to 
# prevent Apache from glomming onto all bound IP addresses (0.0.0.0)
#
#Listen 12.34.56.78:80
Listen 80

#
# Dynamic Shared Object (DSO) Support
#
# To be able to use the functionality of a module which was built as a DSO you
# have to place corresponding `LoadModule' lines at this location so the
# directives contained in it are actually available _before_ they are used.
# Statically compiled modules (those listed by `httpd -l') do not need
# to be loaded here.
#
# Example:
# LoadModule foo_module modules/mod_foo.so
#
LoadModule actions_module modules/mod_actions.so
LoadModule alias_module modules/mod_alias.so
LoadModule asis_module modules/mod_asis.so
LoadModule auth_basic_module modules/mod_auth_basic.so
#LoadModule auth_digest_module modules/mod_auth_digest.so
#LoadModule authn_anon_module modules/mod_authn_anon.so
#LoadModule authn_dbm_module modules/mod_authn_dbm.so
LoadModule authn_default_module modules/mod_authn_default.so
LoadModule authn_file_module modules/mod_authn_file.so
#LoadModule authz_dbm_module modules/mod_authz_dbm.so
LoadModule authz_default_module modules/mod_authz_default.so
LoadModule authz_groupfile_module modules/mod_authz_groupfile.so
LoadModule authz_host_module modules/mod_authz_host.so
LoadModule authz_user_module modules/mod_authz_user.so
LoadModule autoindex_module modules/mod_autoindex.so
#LoadModule cern_meta_module modules/mod_cern_meta.so
LoadModule cgi_module modules/mod_cgi.so
#LoadModule dav_module modules/mod_dav.so
#LoadModule dav_fs_module modules/mod_dav_fs.so
#LoadModule deflate_module modules/mod_deflate.so
LoadModule dir_module modules/mod_dir.so
LoadModule env_module modules/mod_env.so
#LoadModule expires_module modules/mod_expires.so
#LoadModule file_cache_module modules/mod_file_cache.so
#LoadModule headers_module modules/mod_headers.so
LoadModule imagemap_module modules/mod_imagemap.so
LoadModule include_module modules/mod_include.so
#LoadModule info_module modules/mod_info.so
LoadModule isapi_module modules/mod_isapi.so
LoadModule log_config_module modules/mod_log_config.so
LoadModule mime_module modules/mod_mime.so
#LoadModule mime_magic_module modules/mod_mime_magic.so
#LoadModule proxy_module modules/mod_proxy.so
#LoadModule proxy_ajp_module modules/mod_proxy_ajp.so
#LoadModule proxy_balancer_module modules/mod_proxy_balancer.so
#LoadModule proxy_connect_module modules/mod_proxy_connect.so
#LoadModule proxy_http_module modules/mod_proxy_http.so
#LoadModule proxy_ftp_module modules/mod_proxy_ftp.so
LoadModule negotiation_module modules/mod_negotiation.so
#LoadModule rewrite_module modules/mod_rewrite.so
LoadModule setenvif_module modules/mod_setenvif.so
#LoadModule speling_module modules/mod_speling.so
#LoadModule status_module modules/mod_status.so
#LoadModule unique_id_module modules/mod_unique_id.so
LoadModule userdir_module modules/mod_userdir.so
#LoadModule usertrack_module modules/mod_usertrack.so
#LoadModule vhost_alias_module modules/mod_vhost_alias.so
#LoadModule ssl_module modules/mod_ssl.so

# 'Main' server configuration
#
# The directives in this section set up the values used by the 'main'
# server, which responds to any requests that aren't handled by a
# <VirtualHost> definition.  These values also provide defaults for
# any <VirtualHost> containers you may define later in the file.
#
# All of these directives may appear inside <VirtualHost> containers,
# in which case these default settings will be overridden for the
# virtual host being defined.
#

#
# ServerAdmin: Your address, where problems with the server should be
# e-mailed.  This address appears on some server-generated pages, such
# as error documents.  e.g. admin@your-domain.com
#
#ServerAdmin 

#
# ServerName gives the name and port that the server uses to identify itself.
# This can often be determined automatically, but we recommend you specify
# it explicitly to prevent problems during startup.
#
# If your host doesn't have a registered DNS name, enter its IP address here.
#
ServerName :80

#
# DocumentRoot: The directory out of which you will serve your
# documents. By default, all requests are taken from this directory, but
# symbolic links and aliases may be used to point to other locations.
#
DocumentRoot "C:/Program Files (x86)/Apache Software Foundation/Apache2.2/htdocs"

#
# Each directory to which Apache has access can be configured with respect
# to which services and features are allowed and/or disabled in that
# directory (and its subdirectories). 
#
# First, we configure the "default" to be a very restrictive set of 
# features.  
#
<Directory />
    Options FollowSymLinks
    AllowOverride None
    Order deny,allow
    Deny from all
    Satisfy all
</Directory>

#
# Note that from this point forward you must specifically allow
# particular features to be enabled - so if something's not working as
# you might expect, make sure that you have specifically enabled it
# below.
#

#
# This should be changed to whatever you set DocumentRoot to.
#
<Directory "C:/Program Files (x86)/Apache Software Foundation/Apache2.2/htdocs">
    #
    # Possible values for the Options directive are "None", "All",
    # or any combination of:
    #   Indexes Includes FollowSymLinks SymLinksifOwnerMatch ExecCGI MultiViews
    #
    # Note that "MultiViews" must be named *explicitly* --- "Options All"
    # doesn't give it to you.
    #
    # The Options directive is both complicated and important.  Please see
    # http://httpd.apache.org/docs/2.2/mod/core.html#options
    # for more information.
    #
    Options Indexes FollowSymLinks

    #
    # AllowOverride controls what directives may be placed in .htaccess files.
    # It can be "All", "None", or any combination of the keywords:
    #   Options FileInfo AuthConfig Limit
    #
    AllowOverride None

    #
    # Controls who can get stuff from this server.
    #
    Order allow,deny
    Allow from all

</Directory>

#
# DirectoryIndex: sets the file that Apache will serve if a directory
# is requested.
#
<IfModule dir_module>
    DirectoryIndex index.html
</IfModule>

#
# The following lines prevent .htaccess and .htpasswd files from being 
# viewed by Web clients. 
#
<FilesMatch "^\.ht">
    Order allow,deny
    Deny from all
</FilesMatch>

#
# ErrorLog: The location of the error log file.
# If you do not specify an ErrorLog directive within a <VirtualHost>
# container, error messages relating to that virtual host will be
# logged here.  If you *do* define an error logfile for a <VirtualHost>
# container, that host's errors will be logged there and not here.
#
ErrorLog logs/error.log

#
# LogLevel: Control the number of messages logged to the error_log.
# Possible values include: debug, info, notice, warn, error, crit,
# alert, emerg.
#
LogLevel warn

<IfModule log_config_module>
    #
    # The following directives define some format nicknames for use with
    # a CustomLog directive (see below).
    #
    LogFormat "%h %l %u %t \"%r\" %>s %b \"%{Referer}i\" \"%{User-Agent}i\"" combined
    LogFormat "%h %l %u %t \"%r\" %>s %b" common

    <IfModule logio_module>
      # You need to enable mod_logio.c to use %I and %O
      LogFormat "%h %l %u %t \"%r\" %>s %b \"%{Referer}i\" \"%{User-Agent}i\" %I %O" combinedio
    </IfModule>

    #
    # The location and format of the access logfile (Common Logfile Format).
    # If you do not define any access logfiles within a <VirtualHost>
    # container, they will be logged here.  Contrariwise, if you *do*
    # define per-<VirtualHost> access logfiles, transactions will be
    # logged therein and *not* in this file.
    #
    CustomLog logs/access.log common

    #
    # If you prefer a logfile with access, agent, and referer information
    # (Combined Logfile Format) you can use the following directive.
    #
    #CustomLog logs/access.log combined
</IfModule>

<IfModule alias_module>
    #
    # Redirect: Allows you to tell clients about documents that used to 
    # exist in your server's namespace, but do not anymore. The client 
    # will make a new request for the document at its new location.
    # Example:
    # Redirect permanent /foo http:///bar

    #
    # Alias: Maps web paths into filesystem paths and is used to
    # access content that does not live under the DocumentRoot.
    # Example:
    # Alias /webpath /full/filesystem/path
    #
    # If you include a trailing / on /webpath then the server will
    # require it to be present in the URL.  You will also likely
    # need to provide a <Directory> section to allow access to
    # the filesystem path.

    #
    # ScriptAlias: This controls which directories contain server scripts. 
    # ScriptAliases are essentially the same as Aliases, except that
    # documents in the target directory are treated as applications and
    # run by the server when requested rather than as documents sent to the
    # client.  The same rules about trailing "/" apply to ScriptAlias
    # directives as to Alias.
    #
    ScriptAlias /cgi-bin/ "C:/Program Files (x86)/Apache Software Foundation/Apache2.2/cgi-bin/"

</IfModule>

#
# "C:/Program Files (x86)/Apache Software Foundation/Apache2.2/cgi-bin" should be changed to whatever your ScriptAliased
# CGI directory exists, if you have that configured.
#
<Directory "C:/Program Files (x86)/Apache Software Foundation/Apache2.2/cgi-bin">
    AllowOverride None
    Options None
    Order allow,deny
    Allow from all
</Directory>

# 
# Apache parses all CGI scripts for the shebang line by default.
# This comment line, the first line of the script, consists of the symbols
# pound (#) and exclamation (!) followed by the path of the program that 
# can execute this specific script.  For a perl script, with perl.exe in
# the C:\Program Files\Perl directory, the shebang line should be:

   #!c:/program files/perl/perl

# Note you _must_not_ indent the actual shebang line, and it must be the
# first line of the file.  Of course, CGI processing must be enabled by 
# the appropriate ScriptAlias or Options ExecCGI directives for the files 
# or directory in question.
#
# However, Apache on Windows allows either the Unix behavior above, or can
# use the Registry to match files by extention.  The command to execute 
# a file of this type is retrieved from the registry by the same method as 
# the Windows Explorer would use to handle double-clicking on a file.
# These script actions can be configured from the Windows Explorer View menu, 
# 'Folder Options', and reviewing the 'File Types' tab.  Clicking the Edit
# button allows you to modify the Actions, of which Apache 1.3 attempts to
# perform the 'Open' Action, and failing that it will try the shebang line.
# This behavior is subject to change in Apache release 2.0.
#
# Each mechanism has it's own specific security weaknesses, from the means
# to run a program you didn't intend the website owner to invoke, and the
# best method is a matter of great debate.
#
# To enable the this Windows specific behavior (and therefore -disable- the
# equivilant Unix behavior), uncomment the following directive:
#
#ScriptInterpreterSource registry
#
# The directive above can be placed in individual <Directory> blocks or the
# .htaccess file, with either the 'registry' (Windows behavior) or 'script' 
# (Unix behavior) option, and will override this server default option.
#

#
# DefaultType: the default MIME type the server will use for a document
# if it cannot otherwise determine one, such as from filename extensions.
# If your server contains mostly text or HTML documents, "text/plain" is
# a good value.  If most of your content is binary, such as applications
# or images, you may want to use "application/octet-stream" instead to
# keep browsers from trying to display binary files as though they are
# text.
#
DefaultType text/plain

<IfModule mime_module>
    #
    # TypesConfig points to the file containing the list of mappings from
    # filename extension to MIME-type.
    #
    TypesConfig conf/mime.types

    #
    # AddType allows you to add to or override the MIME configuration
    # file specified in TypesConfig for specific file types.
    #
    #AddType application/x-gzip .tgz
    #
    # AddEncoding allows you to have certain browsers uncompress
    # information on the fly. Note: Not all browsers support this.
    #
    #AddEncoding x-compress .Z
    #AddEncoding x-gzip .gz .tgz
    #
    # If the AddEncoding directives above are commented-out, then you
    # probably should define those extensions to indicate media types:
    #
    AddType application/x-compress .Z
    AddType application/x-gzip .gz .tgz

    #
    # AddHandler allows you to map certain file extensions to "handlers":
    # actions unrelated to filetype. These can be either built into the server
    # or added with the Action directive (see below)
    #
    # To use CGI scripts outside of ScriptAliased directories:
    # (You will also need to add "ExecCGI" to the "Options" directive.)
    #
    #AddHandler cgi-script .cgi

    # For type maps (negotiated resources):
    #AddHandler type-map var

    #
    # Filters allow you to process content before it is sent to the client.
    #
    # To parse .shtml files for server-side includes (SSI):
    # (You will also need to add "Includes" to the "Options" directive.)
    #
    #AddType text/html .shtml
    #AddOutputFilter INCLUDES .shtml
</IfModule>

#
# The mod_mime_magic module allows the server to use various hints from the
# contents of the file itself to determine its type.  The MIMEMagicFile
# directive tells the module where the hint definitions are located.
#
#MIMEMagicFile conf/magic

#
# Customizable error responses come in three flavors:
# 1) plain text 2) local redirects 3) external redirects
#
# Some examples:
#ErrorDocument 500 "The server made a boo boo."
#ErrorDocument 404 /missing.html
#ErrorDocument 404 "/cgi-bin/missing_handler.pl"
#ErrorDocument 402 http:///subscription_info.html
#

#
# EnableMMAP and EnableSendfile: On systems that support it, 
# memory-mapping or the sendfile syscall is used to deliver
# files.  This usually improves server performance, but must
# be turned off when serving from networked-mounted 
# filesystems or if support for these functions is otherwise
# broken on your system.
#
#EnableMMAP off
#EnableSendfile off

# Supplemental configuration
#
# The configuration files in the conf/extra/ directory can be 
# included to add extra features or to modify the default configuration of 
# the server, or you may simply copy their contents here and change as 
# necessary.

# Server-pool management (MPM specific)
#Include conf/extra/httpd-mpm.conf

# Multi-language error messages
#Include conf/extra/httpd-multilang-errordoc.conf

# Fancy directory listings
#Include conf/extra/httpd-autoindex.conf

# Language settings
#Include conf/extra/httpd-languages.conf

# User home directories
#Include conf/extra/httpd-userdir.conf

# Real-time info on requests and configuration
#Include conf/extra/httpd-info.conf

# Virtual hosts
#Include conf/extra/httpd-vhosts.conf

# Local access to the Apache HTTP Server Manual
#Include conf/extra/httpd-manual.conf

# Distributed authoring and versioning (WebDAV)
#Include conf/extra/httpd-dav.conf

# Various default settings
#Include conf/extra/httpd-default.conf

# Secure (SSL/TLS) connections
#Include conf/extra/httpd-ssl.conf
#
# Note: The following must must be present to support
#       starting without SSL on platforms with no /dev/random equivalent
#       but a statically compiled-in mod_ssl.
#
<IfModule ssl_module>
SSLRandomSeed startup builtin
SSLRandomSeed connect builtin
</IfModule>

 
now it is high time to build the windows container image 

docker build -t apache c:\apache



C:\Users\michael.kourbelis\Desktop\realstuffv1>cd c:\

c:\>docker build -t apache c:\apache
Sending build context to Docker daemon 4.404 MB
[WARNING]: Empty continuation line found in:
    RUN powershell.exe -command copy-item c:/apache/httpd.conf -destination '"c:/program files (x86)/Apache Software Foundation/Apache2.2/conf"'; cmd.exe /c c:/apache/service.bat; sc.exe config apache2.2 obj=LocalSystem; remove-item c:/apache -Recurse
[WARNING]: Empty continuation lines will become errors in a future release.
Step 1/4 : FROM microsoft/windowsservercore
SECURITY WARNING: You are building a Docker image from Windows against a non-Windows Docker host. All files and directories added to build context will have '-rwxr-xr-x' permissions. It is recommended to double check and reset permissions for sensitive files and directories.
pull access denied for microsoft/windowsservercore, repository does not exist or may require 'docker login': denied: requested access to the resource is denied

c:\>
 ---------------------i dont know-----------------------------
 ----------------Installing Apache Web Server using windows dockerfile--------------  


                                                 spacea


now that we have succesfully pull our image  lets re run our command

 C:\Users\michael.kourbelis\Desktop\realstuffv1 > docker build -t centos_apache:v1 .


 errors again

dockerfile
 from centos
 run  yum -y install httpd:2.4

 C:\Users\michael.kourbelis\Desktop\realstuffv1 > docker pull centos

a1d0c7532777: Pull complete    
Digest: sha256:a27fd8080b517143cbbbab9dfb7c8571c40d67d534bbdee55bd6c473f432b177                                                                                                                                                                                                 Digest: sha256:a27fd8080b517143cbbbab9dfb7c8571c40d67d534bbdee55bd6c473f432b17783.52 MB/83.52 MB
Status: Downloaded newer image for centos:latest
C:\Users\michael.kourbelis\Desktop\realstuffv1>   

then 
 C:\Users\michael.kourbelis\Desktop\realstuffv1 > docker build -t centos_apache:v1 .


 C:\Users\michael.kourbelis\Desktop\realstuffv1>docker build -t centos_apache:v1 .
Sending build context to Docker daemon 3.072 kB
Step 1/2 : from centos
 ---> 5d0da3dc9764
Step 2/2 : run  yum -y install httpd:2.4
 ---> Running in 8d28bef4b0c4
CentOS Linux 8 - AppStream                      213  B/s |  38  B     00:00
Error: Failed to download metadata for repo 'appstream': Cannot prepare internal mirrorlist: No URLs in mirrorlist
SECURITY WARNING: You are building a Docker image from Windows against a non-Windows Docker host. 
All files and directories added to build context will have '-rwxr-xr-x' permissions. 
It is recommended to double check and reset permissions for sensitive files and directories.
The command '/bin/sh -c yum -y install httpd:2.4' returned a non-zero code: 1

C:\Users\michael.kourbelis\Desktop\realstuffv1 >


now it doesnt create the image centos_apache



so lets run from the start with  nothing to exist from containers up to images 

 C:\Users\michael.kourbelis\Desktop\realstuffv1 > docker build -t centos_apache:v1 .

a1d0c7532777: Pull complete
Digest: sha256:a27fd8080b517143cbbbab9dfb7c8571c40d67d534bbdee55bd6c473f432b177
CentOS Linux 8 - AppStream                       90  B/s |  38  B     00:00    72.97 MB/83.52 MB
Error: Failed to download metadata for repo 'appstream': Cannot prepare internal mirrorlist: No URLs in mirrorlist
SECURITY WARNING: You are building a Docker image from Windows against a non-Windows Docker host. 
All files and directories added to build context will have '-rwxr-xr-x' permissions. 
It is recommended to double check and reset permissions for sensitive files and directories.
The command '/bin/sh -c yum -y install httpd:2.4' returned a non-zero code: 1


so lets remove everything again
and remove 2.4 from the dockerfile

 C:\Users\michael.kourbelis\Desktop\realstuffv1 > docker build -t centos_apache:v1 .
again 

something is with centos
we will figure it out later...........


lets try to do it with http:2.4 e.g.

FROM httpd:2.4
COPY backspace.html /usr/local/apache2/htdocs/backspace.html

10c4d45228bf: Pull complete
Digest: sha256:5cc947a200524a822883dc6ce6456d852d7c5629ab177dfbf7e38c1b4a647705
Status: Downloaded newer image for httpd:2.4
Step 2/2 : COPY backspace.html /usr/local/apache2/htdocs/backspace.html=>e4dafd9bd8b2acting
Successfully built e4dafd9bd8b2
Successfully tagged centos_apache:v1
SECURITY WARNING: You are building a Docker image from Windows against a non-Windows Docker host. 
All files and directories added to build context will have '-rwxr-xr-x' permissions. 
It is recommended to double check and reset permissions for sensitive files and directories.
cdb155854ae6: Extracting

now if  rerun the command the i.e. if we build the image again will docker download the same httpd image again?
will docker installs the packages again one way to know it 


 C:\Users\michael.kourbelis\Desktop\realstuffv1 > docker build -t centos_apache:v1 .

 .....

C:\Users\michael.kourbelis\Desktop\realstuffv1>docker build -t centos_apache:v1 .
Sending build context to Docker daemon 3.584 kB
Step 1/2 : FROM httpd:2.4
 ---> a8ea074f4566
Step 2/2 : COPY backspace.html /usr/local/apache2/htdocs/backspace.html
 ---> Using cache
 ---> e4dafd9bd8b2
Successfully built e4dafd9bd8b2
Successfully tagged centos_apache:v1
SECURITY WARNING: You are building a Docker image from Windows against a non-Windows Docker host. 
All files and directories added to build context will have '-rwxr-xr-x' permissions. 
It is recommended to double check and reset permissions for sensitive files and directories.

C:\Users\michael.kourbelis\Desktop\realstuffv1>




 docker will save everything in the cash and then he reused them because he saw that nothing actually change in the docker file
 and thus it is not getting rebuilt 

 but if you go ahead and abd change something to the docker file lets say you want remove :2.4 from https

FROM httpd
COPY backspace.html /usr/local/apache2/htdocs/backspace.html

 C:\Users\michael.kourbelis\Desktop\realstuffv1 > docker build -t centos_apache:v1 .

 you will see among step 1/2 and step 2/2 this
       latest: Pulling from library/httpd
       Digest: sha256:5cc947a200524a822883dc6ce6456d852d7c5629ab177dfbf7e38c1b4a647705
       Status: Downloaded newer image for httpd:latest ---> a8ea074f4566

so docker will figure out that you change something and will rebuild the image from the last change 
so you see that step 1/2 is the same as before as you didn't modify anything in that layer 

you modify nothing on  the second layer either 
but you modify among them 

review on he parent & child relationship

--t results in image  
and use the docker file which is this directory ___.___

now our image is already built and this can be proved by ___docker images___
but if you want to filter them i.e. to see which are with centos which are with apache and so on 
                                          apply grep which is a linux utility and then we type apache as the filter
you can give this command ____docker images | grep apache_____

but in windows the equivalent for grep is findstr for cmd 
while 
grep  is Select-String for PowerShell 

 C:\Users\michael.kourbelis\Desktop\realstuffv1 > docker images | findstr apache

 the funny thing is that i created with from httpd and if i run with centos as filter it produce the same with httpd

C:\Users\michael.kourbelis\Desktop\realstuffv1 > docker images | findstr apache
centos_apache       v1                  sha256:e4daf        31 minutes ago      143.6 MB

C:\Users\michael.kourbelis\Desktop\realstuffv1 > docker images | findstr centos
centos_apache       v1                  sha256:e4daf        31 minutes ago      143.6 MB



ok now we have created our own image the first one using docker file from httpd (and centos at the same time it will show)


 cat equivalent 
C:\Users\michael.kourbelis\Desktop\realstuffv1 > type Dockerfile

in the next video we are going to see how to create a container using this image and how to tell docker 
which service should be started once you create a container

because if you see inside dockerfile we have the already the html file (or the package installed)
but 
we are not telling docker how to start the process inside the container 
and remember that the process is pretty importnat because the process is what basically runs inside the container 
and if you have no process running tghen in theory you have no container becaise the container depends on the process 
its tied to the process 
if there is no process or if the process dies then the container exits.

xx. test your image by creating a docker container 
--------------------------------------------------
in the previous lesson we create a new image from a docker file  and that image is name centos_apache v1 
so now we want to create a new container on port 9090 and we want to see if this is really working 
we should see the test page of apache 

if we see the dockerfile we see the firts layer that says from httpd  and the second layer where we copy our html from our 
directory  to apache 

but in dockerfile we dont have any line that tells docker how the process should be started 
so now lets try to create a container using this image and lets see what happens 
so lets type 

docker run (to create the container) 
-d (lets put it on the background with -d..detached mode) 
centos_apache:v1 (and pass the image which is centos_apache:v1)   
-p 9090:80

up here what we are saying :
docker run a container in the background  using the centos_apache v1 that was builted some seconds ago 

note you can name the container too among run and -d flag by type ____--name centos___



C:\Users\michael.kourbelis\Desktop\realstuffv1 > docker run --name centos -d centos_apache:v1 

now if you hit enter what happens is that you made it 

53de532e7ebe699cf6b11086c4381ff588f1b680ffd12b50a94d2a791aa50235

C:\Users\michael.kourbelis\Desktop\realstuffv1>

you obtain the hashmapa and it applies the static container name

so now with docker ps you are able to see all your containers of yours with sole exception the centos
as it hadn't got a process and exited 
remember that we are not starting in any process in the docker file 
we are just (installing a package) copy an html file and we just starting from an image 

with docker ps -a we list all the containers running and exited ones 

now we see that our container exited because it has nothing in the command section which in docker is cmd  that 
is the location that leads to a file that starts the process of each appropriate container  

so lets perform some modification to our dockerfile and delete our current image and its container


 C:\Users\michael.kourbelis\Desktop\realstuffv1 > docker build -t centos_apache:v1 .



 change our dockerfile to be 

 
FROM httpd
Run  yum -y install httpd:2.4

 C:\Users\michael.kourbelis\Desktop\realstuffv1 > docker build -t centos_apache:v1 .

10c4d45228bf: Pull complete    
Digest: sha256:5cc947a200524a822883dc6ce6456d852d7c5629ab177dfbf7e38c1b4a647705
Status: Downloaded newer image for httpd:latest a8ea074f4566acting
Step 2/2 : Run  yum -y install httpd:2.4
Running in fb1d274480c8
/bin/sh: 1: yum: not found

SECURITY WARNING: You are building a Docker image from Windows against a non-Windows Docker host. 
All files and directories added to build context will have '-rwxr-xr-x' permissions. 
It is recommended to double check and reset permissions for sensitive files and directories
The command '/bin/sh -c yum -y install httpd:2.4' returned a non-zero code: 1
cdb155854ae6: Extracting

C:\Users\michael.kourbelis\Desktop\realstuffv1>docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             VIRTUAL SIZE
httpd               latest              sha256:a8ea0        3 weeks ago         143.6 MB
httpd               <none>              sha256:a8ea0        3 weeks ago         143.6 MB

C:\Users\michael.kourbelis\Desktop\realstuffv1>docker ps
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES

C:\Users\michael.kourbelis\Desktop\realstuffv1>docker ps -a
CONTAINER ID        IMAGE                                                                     COMMAND                  CREATED             STATUS                        PORTS               NAMES
fb1d274480c8        sha256:a8ea074f4566addcd01f9745397f32be471df4a4abf200f0f10c885ed14b1d28   "/bin/sh -c 'yum -y i"   58 seconds ago      Exited (127) 57 seconds ago                       affectionate_agnesi

C:\Users\michael.kourbelis\Desktop\realstuffv1>


C:\Users\michael.kourbelis\Desktop\realstuffv1 > docker run --name ceeentos -d centos_apache:v1 
we see that our container
is exited 

C:\Users\michael.kourbelis\Desktop\realstuffv1>docker run --name ceeentos -d centos_apache:v1
Unable to find image 'centos_apache:v1' locally
Error response from daemon: pull access denied for centos_apache, repository does not exist or may require 
'docker login': denied: requested access to the resource is denied


lets add a line to our dockerfile 
which has the keyword 

CMD--->that is in position to start the process inside of a container 
......in a container in docker we dont have cmd or sudo 
so you need to learn hoe to figure out things without using the sudo and without using the cmd 


so we need to find a way to start the httpd process without cmd 
so lets go to google and find a way or a command that will start apache without cmd


____docker centos apache cmd_____

Docker CentOS image does not auto start httpd  (https://stackoverflow.com/questions/21280174/docker-centos-image-does-not-auto-start-httpd)


so great news you have to run apache in foreground which means stucking the screen 
and as long as the process is alive the container will be alive too 
once the process exits the containers exits 

so lets try this line /usr/sbin/apache2 -DFOREGROUND  and lets see if that works 

CMD /usr/sbin/apache2 -DFOREGROUND 

according to video we will use apachectl

CMD /usr/sbin/apachectl -DFOREGROUND 
 
and lets seek for it in google

apachectl DFOREGROUND

apachectl -DFOREGROUND exits immediately (https://stackoverflow.com/questions/43750436/apachectl-dforeground-exits-immediately)

here we found  the line ___apachectl -DFOREGROUND____       -e debug____

and this basically will start the apache process in foreground 

and we dont think that we need a full path   here just CMD apachectl -DFOREGROUND 

ok so this is going to start the process inside the container 
e.g. when the container is created then it will look for the cmd instruction and  
it will trigger this command    apachectl -DFOREGROUND 
and this command should start the process inside the container and it should keep the container alive 
i mean it should keep the process alive in the foreground mode 
everything should be run in foreground in a dockerfile 

so lets save our dockerfile 

FROM httpd
RUN  yum -y install httpd:2.4
CMD apachectl -DFOREGROUND 

and use the vesrion 2 in our build as version 1 does not include cmd 

C:\Users\michael.kourbelis\Desktop\realstuffv1 > docker build -t centos_apache:v2 .

10c4d45228bf: Pull complete 
Digest: sha256:5cc947a200524a822883dc6ce6456d852d7c5629ab177dfbf7e38c1b4a647705
Status: Downloaded newer image for httpd:latest
a8ea074f4566acting
Running in 09e739361f2a
/bin/sh: 1: yum: not found
SECURITY WARNING: You are building a Docker image from Windows against a non-Windows Docker host. 
All files and directories added to build context will have '-rwxr-xr-x' permissions. It is recommended to double check and reset permissions
for sensitive files and directories.
The command '/bin/sh -c yum -y install httpd:2.4' returned a non-zero code: 1
cdb155854ae6: Extracting



FROM centos:latest
RUN yum update -y
RUN yum install httpd -y
ENTRYPOINT ["/usr/sbin/httpd","-D","FOREGROUND"]

C:\Users\michael.kourbelis\Desktop\realstuffv1 > docker build -t centos_apache:v2 .
a1d0c7532777: Pull complete
Digest: sha256:a27fd8080b517143cbbbab9dfb7c8571c40d67d534bbdee55bd6c473f432b177
Status: Downloaded newer image for centos:latest
5d0da3dc9764acting
Step 2/4 : RUN yum update -y
Running in edcaa0825555
CentOS Linux 8 - AppStream                      236  B/s |  38  B     00:00
Error: Failed to download metadata for repo 'appstream': Cannot prepare internal mirrorlist: No URLs in mirrorlist
SECURITY WARNING: You are building a Docker image from Windows against a non-Windows Docker host. 
All files and directories added to build context will have '-rwxr-xr-x' permissions.
It is recommended to double check and reset permissions for sensitive files and directories
The command '/bin/sh -c yum update -y' returned a non-zero code: 1           
a1d0c7532777: Extracting


C:\Users\michael.kourbelis\Desktop\realstuffv1 > docker images | findstr apache


now lets try to create one container  

C:\Users\michael.kourbelis\Desktop\realstuffv1 > docker run --name centos -d centos_apache:v2 



we need more infos about centos 
for the time we just make use of the following dockerfile that makes use of the html file 

C:\Users\michael.kourbelis\Desktop\realstuffv1 > docker build -t centos_apache:v2 .

and now it is time to create our container (which is alive if its process inside it is alive )



our container is running thus we are go to check it with two more variables in the docker run command 

how do we test it ? thats a good question........ 
do you remember about the port thing 


with -p flag we map the outer port in space on our port 80 -p 9090:80 becaus by default http runs on port 80

C:\Users\michael.kourbelis\Desktop\realstuffv1 > docker run -d --name centos -p 9090:80  centos_apache:v2

docker run -dit  --name picii  -p 8080:80 pici

C:\Users\michael.kourbelis\Desktop\realstuffv1>docker run -d --name centos -p 9090:80  centos_apache:v2
12223754addf3fd011def375591eec64be988643d0967ac2d89c7d271e70f73f

and now we have our hash which means that we have expose port 9090 to port 80 and thus we can go to our browser and  
test it with localhost:9090
http://localhost:9090/backspace.html


we come back to video 20.test your image by creating docker container when we get linux 


---------------------------------4.Docker images your first touch------------------------------end


start----------------------------5.Docker images Learn about Dockerfiles---------------------------------

xxi.The FROM instruction-take my image as a base
-------------------------------------------------
in this video we are going deeper into docker images
so from now on we are going to be exploring each and every instruction that we have in a docker file  to build images 
so now we are going to start building more images than what we have done so far 
and we are going to explore each component of each instruction that we may using the docker file  so thats great

so lets tak a look  at this docker file that we created on the previous section
with the command  type Dockerfile wich is equivalent to cat Dockerfile


so what i am going to do here is i am basically going to create the dockerfile number 2.....Dockerfile2
and then i will say ok.......
FROM......which is an instruction that tells you from which image you are starting  
for example 
this start could be from an operating system it could be another image it could be a docker image....it doesn't really matter  

you could say for example 

from nginx:alpine which is an image that we already use and you can just build this and that is going to work   
ok now we have two things 
the first one is that we want to build this image 
the second one is that we have a name that is not dockerfile is dockerfile2...and you must know that the default 
name in docker for dockerfile is of course dockerfile but here we have something that we call dockerfile2
so we need to add a couple of modifications to the build command
ok so now we know that we have these dockerfile2 which we want to build and we go to build it 

so we are going to say 

docker build --tag or -t which is exactly the same thing and result in image that will be "nginx_custom:v1" and 
then we want to specify the name of the file with -f Dockerfile2

C:\Users\michael.kourbelis\Desktop\realstuffv1 >  docker build  -t nginx_custom:v1 -f Dockerfile2

now if i hit enter it will actually complains 
--------------------------------------------------------------------------------------------------
C:\Users\michael.kourbelis\Desktop\realstuffv1> docker build  -t nginx_custom:v1 -f Dockerfile2
docker: "build" requires 1 argument.
See 'docker build --help'.

Usage:  docker build [OPTIONS] PATH | URL | -

Build a new image from the source code at PATH

C:\Users\michael.kourbelis\Desktop\realstuffv1>
--------------------------------------------------------------------------------------------------

its because we need to provide the context which means the location where this file (Dockerfile2) is located in  
and dockerfile2 is located in the same directory that we specify in cmd and we didn't specify it with the dot "."


C:\Users\michael.kourbelis\Desktop\realstuffv1 >  docker build  -t nginx_custom:v1 -f Dockerfile2 .

Pull complete
Status: Downloaded newer image for nginx:alpine
bef258acf10dloading
Successfully built bef258acf10d
Successfully tagged nginx_custom:v1
SECURITY WARNING: You are building a Docker image from Windows against a non-Windows Docker host. All files 
and directories added to build context will have '-rwxr-xr-x' permissions. 
It is recommended to double check and reset permissions for sensitive files and directories.

Usage:  docker build [OPTIONS] PATH | URL | -
C:\Users\michael.kourbelis\Desktop\realstuffv1>
Build a new image from the source code at PATH f2303c6c8865: Waiting  Sending build context to Docker daemon  5.12 kB
Step 1/1 : FROM nginx:alpine
alpine: Pulling from library/nginx
f2303c6c8865: Pulling fs layer

C:\Users\michael.kourbelis\Desktop\realstuffv1  > 


so as you see npow it gets build, so two things here 
first thing here is you are starting from alpine ____Step 1/1 : FROM nginx:alpine____
second thing is you used a different dockerfile2 to build this image because if you dont use this dockerfile2 and if you dont use the flag -f 
then docker will look for a file with the default name of Dockerfile in the current directory __.__ to build the image so great you already know 
you can start from any image that you want any official image that you want....any official image or any custom image that you want   

and of course the operating system that will be in the image because we need an operating system its going to be inheritted from _____nginx:alpine_____

xxii.the run instruction rocks
-------------------------------
in this video we are going to learn about the run instruction in docker
we already discussed about that run instruction in docker
and if you look at you normal docker file then you see that we are using the running instruction   
to run some commands in the centos image (run  yum -y install httpd) in the specific moment 
well you can do whatever you want because you can run commands there 
so lets now create a docker file 
and modify the Dockerfile2 
if you remember we already built the image in the previous lesson which is called "nginx_custom:v1"

now lets go to google and lets look for the nginx docker image 
which is the nginx image that we are using in dockerfile2
and basically what we want to do is to find out the root directory of this image because what happens if i create a container using 
the image  "nginx_custom:v1"

so lets check it out

C:\Users\michael.kourbelis\Desktop\realstuffv1  >  docker run -d -p 9090:80 --name nginx nginx_custom:v1
c413dbee7a0cb521627392fb854c5a259ec55f32ee6615b2feb1fca98969d302

C:\Users\michael.kourbelis\Desktop\realstuffv1>

so we get our hash and we are ready to go....this basically the same image as nginx alpine so we should see the nginx welcome page if we 

perform localhost:9090.......yeaah

so now lets remove that container now that we see that it works 


C:\Users\michael.kourbelis\Desktop\realstuffv1> docker rm -f nginx

*note 
the code that displayed on the browser from nginx os is somewhere inside of the nginx image 
so what we want to do is to use the run instruction to override this content 
so for that we are going to google and look for the nginx image and also we are going to look for the root directory of nginx
so if we google 

__nginx docker image___
and go to nginx docker hub and in the search we type __root__ or webroot and head to the section with title 
"How to use this image".....and it is "hosting some simple static content"

FROM nginx
COPY static-html-directory /usr/share/nginx/html

so basically in other words we are going to override the indexed html file which is in the folder "/usr/share/nginx/html"
and that folder is the root folder of nginx and we are going to modify the text below the title of 
"welcome to nginx" 

we are going to override it using the run instruction 

it is the only way for you to see how the run instruction works 
we assume that in this location there is an index.html file that serves the content that is displayed in the browser 
so now we are going to copy this path  "/usr/share/nginx/html"

and we are going to open our Dockerfile2 and we are going to add the 

run instruction which will do an echo and we will say 


RUN echo "Overwrite home page > "

and now we are going to redirect that to the file /usr/share/nginx/html/index.html

RUN echo "Overwrite home page" > /usr/share/nginx/html/index.html

well if you dont know what this thing does....well is basically a linux command which is going to echo/print this command 
__"Overwrite home page"__ to the output and then redirects ">" to this file "/usr/share/nginx/html/index.html"
which means that this file __index.html__ will be overridden with this content __"Overwrite home page"__

FROM nginx:alpine
RUN echo "Overwrite home page" > /usr/share/nginx/html/index.html


so basically here we have our from instruction  and then we do echo and 
through this we are overiding this file "index.html" with   the content of "Overwrite home page"
and the thing here is that as you saw before in the run instruction we can run anything we need 
you can run  get comands we can run apt commands, echo commands basically any linux command available you can run it here 
so we are going to test this way
akay so save this file and remember that we need to rebuild this image for the changes to take  effect because we need to create a new image
so to create a new image 
we are going to build this and we are going to say that this version is the version 2 of the original 
and version 2 will contain  the new home page the new code or the new content for the home page  


C:\Users\michael.kourbelis\Desktop\realstuffv1 >  docker build  -t nginx_custom:v2 -f Dockerfile2 .



so we are going to say exactly the same thing 
please docker build a new image which is going to be the version 2  using this Dockerfile2 in this directory .

now if we hit enter we are going to see that the step 2 is being run and now this content 

/usr/share/nginx/html/index.html

should be overwritten


C:\Users\michael.kourbelis\Desktop\realstuffv1 > docker build  -t nginx_custom:v1 -f Dockerfile2 .
Sending build context to Docker daemon  5.12 kB
Step 1/1 : FROM nginx:alpine
 ---> bef258acf10d
Successfully built bef258acf10d
Successfully tagged nginx_custom:v1
SECURITY WARNING: You are building a Docker image from Windows against a non-Windows Docker host. 
All files and directories added to build context will have '-rwxr-xr-x' permissions. 
It is recommended to double check and reset permissions for sensitive files and directories.

C:\Users\michael.kourbelis\Desktop\realstuffv1 > docker run -d -p 9090:80 --name nginx nginx_custom:v1
98ae33598bb405d91f3bca946c2c83d977a4f39a86921bd53f56b186db57f56a

C:\Users\michael.kourbelis\Desktop\realstuffv1 > docker build  -t nginx_custom:v2 -f Dockerfile2 .
Sending build context to Docker daemon  5.12 kB
Step 1/2 : FROM nginx:alpine
 ---> bef258acf10d
Step 2/2 : RUN echo "Overwrite home page" > /usr/share/nginx/html/index.html
 ---> Running in 34bc959bafd6
Removing intermediate container 34bc959bafd6
 ---> 2f0d12a03141
Successfully built 2f0d12a03141
Successfully tagged nginx_custom:v2
SECURITY WARNING: You are building a Docker image from Windows against a non-Windows Docker host. All files and directories added to build context will have '-rwxr-xr-x' permissions. It is recommended to double check and reset permissions for sensitive files and directories.

C:\Users\michael.kourbelis\Desktop\realstuffv1 >


now to test it we are going to create a container just like we did before but now we are use the image number 2 

C:\Users\michael.kourbelis\Desktop\realstuffv1 > docker run -d -p 9090:80 --name nginx nginx_custom:v2

we hit enter ....we get our hash and the go to our browser hit refresh and see that the content is ovwerwritten 
nooooooooo

Error response from daemon: Conflict. The container name "/nginx" is already in use 
by container "98ae33598bb405d91f3bca946c2c83d977a4f39a86921bd53f56b186db57f56a". 
You have to remove (or rename) that container to be able to reuse that name.

C:\Users\michael.kourbelis\Desktop\realstuffv1>

i kneewwww it 

delete everything and start again everythingggggg

C:\Users\michael.kourbelis\Desktop\realstuffv1 >  docker images 

Dockerfile2
FROM nginx:alpine
C:\Users\michael.kourbelis\Desktop\realstuffv1 > docker build  -t nginx_custom:v1 -f Dockerfile2 .
C:\Users\michael.kourbelis\Desktop\realstuffv1 > docker run -d -p 9090:80 --name nginx nginx_custom:v1

Dockerfile2
FROM nginx:alpine
RUN echo "Overwrite home page" > /usr/share/nginx/html/index.html


twra an pame na kanoume build tha mas afhsei kathws den tou einai tipota an omws pame na xantrexoume to idio container sto idio image pou trexei 
tote ta dyo images tha stoukaroun kai 9a ginei mpaxalo 

opote kanoume delete ton container to image nginx me th akoloiuth entolh 

C:\Users\michael.kourbelis\Desktop\realstuffv1 > docker rm -f nginx

kai meta xanakane build kai ta loipa 

C:\Users\michael.kourbelis\Desktop\realstuffv1 > docker build  -t nginx_custom:v2 -f Dockerfile2 .
C:\Users\michael.kourbelis\Desktop\realstuffv1 > docker run -d -p 9090:80 --name nginx nginx_custom:v2

Error response from daemon: Conflict. The container name "/nginx" is already in use 
by container "434855d7cada09e230c0d752c0c2c532d18891b5522484db04e39b88535aedb2". 
You have to remove (or rename) that container to be able to reuse that name.

eimai megalos mapas sto video leei xeka9ara oti stamataei to service 

C:\Users\michael.kourbelis\Desktop\realstuffv1 > docker rm -f nginx

kai meta xanakane build kai ta loipa 



opote to sum up 

Dockerfile2
FROM nginx:alpine
C:\Users\michael.kourbelis\Desktop\realstuffv1 > docker build  -t nginx_custom:v1 -f Dockerfile2 .
C:\Users\michael.kourbelis\Desktop\realstuffv1 > docker run -d -p 9090:80 --name nginx nginx_custom:v1
C:\Users\michael.kourbelis\Desktop\realstuffv1 > docker rm -f nginx


Dockerfile2
FROM nginx:alpine
RUN echo "Overwrite home page" > /usr/share/nginx/html/index.html

C:\Users\michael.kourbelis\Desktop\realstuffv1 > docker build  -t nginx_custom:v2 -f Dockerfile2 .
C:\Users\michael.kourbelis\Desktop\realstuffv1 > docker run -d -p 9090:80 --name nginx nginx_custom:v2

so  basically what you can do with the run command is that you can do anything you want here 
you can install packages 
you can create users 
you can override things 
you can search for things 
you can basically execute any linux command any available linux command  


* run instruction allows you to run anything that you want 


xxiii.copy files with copy
---------------------------
here we are going to talk about the copy instruction in docker....lets create a real use case scenario 
first we want to create an image right? 
and 
we want our image to have the following requirments 

i  . we want a from instruction from centos
ii . we want to install http because we want an apache server 
iii. we want to copy some code to that image some html code 
iv . and the resulting image should have centos and http installed and should have the code copied to the root directory of that web server 
v  . finally we want to create a container which will serve the content that we just created 
     so lets go ahead and try that 

now the video shows that there is a folder name "templates"  and we copy from here a file that is named bootstrap 
more specificcaly 
templates/startbootstrap-freelance-master/ 
and we are going to copy that folder to cocker image folder that we have with the view to levelize our docker file with  
the folder "startbootstrap-freelance-master" which is good 

now "startbootstrap-freelance-master" has some css some html files some jsons but in our case it has only an html file 
xaxaxaxxaxaxxax

now we change the name of "startbootstrap-freelance-master" folder to htmlcode and basically this folder contains a static web page 
so what we want to do is to copy this ____htmlcode____ to the root location of apache 


now we have a question  

the first one is how are we going to copy this content backspace.html to the image to the resulting image using the dockerfile  
and 
the second question is where should we copy the content ?

so to answer the second question we are going to go to google and we search for 

____default webroot for apache in centos 7____
because we are actually installed apache in centos 
so lets take a look and see if we can find something 
so the good news are that the default root for apache is ____/var/www/html 

now remember that the folder where the backspace.html code is stored is name "htmlcode"
so now we are going to modify the dockerfile 
we know that it starts from centos we know that it start from apache and we know that we are starting the service using the instruction cmd




now one simple review of the Dockerfile

---------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------

 FROM centos
 RUN  yum -y install httpd


C:\Users\michael.kourbelis\Desktop\realstuffv1 >   docker build -t pici . 

a1d0c7532777: Pull complete
Digest: sha256:a27fd8080b517143cbbbab9dfb7c8571c40d67d534bbdee55bd6c473f432b177
Status: Downloaded newer image for centos:latest
5d0da3dc9764acting
Step 2/2 : RUN  yum -y install httpd
Running in 347dc5fc5348
CentOS Linux 8 - AppStream                      106  B/s |  38  B     00:00
Error: Failed to download metadata for repo 'appstream': Cannot prepare internal mirrorlist: No URLs in mirrorlist
SECURITY WARNING: You are building a Docker image from Windows against a non-Windows Docker host. All files and 
directories added to build context will have '-rwxr-xr-x' permissions. 
It is recommended to double check and reset permissions for sensitive files and directories.
The command '/bin/sh -c yum -y install httpd' returned a non-zero code: 1   
a1d0c7532777: Extracting


C:\Users\michael.kourbelis\Desktop\realstuffv1 >   docker run -dit  --name picii  -p 8080:80 pici

---------------------------------------------------------------------------------------
Apache inside the container doesn't seems to work. it give access forbidden.
You don't have permission to access / on this server.
If i install similar apache on the vm where docker is installed it works without changing any configurations.
Do we need to go inside the container and change apache config?
    answer 
    was using the centos:7 version docker image in the course, which was the lastest version at that time. 
    Now, latest means centos:8. In this centos 8 image, no default index.html is provided, that's why you saw the 403 error. 
    Adding a simple index to the webroot of the container fixes it!
---------------------------------------------------------------------------------------

C:\Users\michael.kourbelis\Desktop\realstuffv1 > docker build -t myimage:v1 .

Complete!
Removing intermediate container 22ea12552e46
 ---> 8139f09f7cfa
Successfully built 8139f09f7cfa
Successfully tagged myimage:v1
SECURITY WARNING: You are building a Docker image from Windows against a non-Windows Docker host. 
All files and directories added to build context will have '-rwxr-xr-x' permissions. 
It is recommended to double check and reset permissions for sensitive files and directories.


docker run -d --name myimagee -p 9090:80  myimage:v1



C:\Users\michael.kourbelis\Desktop\realstuffv1 > docker run -d --name myimagee -p 9090:80  myimage:v1
docker run -d -p 9090:80 --name nginx myimage:v1

f87cd6f3d62ab0f026df2380337ae4a0e66e487ead1f482bd13b6aad3bb7a776

but now browser says that site cannot be reached in 9090 but says it works in 8080 xaxaxaxxaxaxaxaaxaxax

---------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------
now remember that the folder where the backspace.html code is stored is name "htmlcode"
so now we are going to modify the dockerfile 

we know that it starts from centos                                                      FROM centos:7
we know that it installs apache                                                         RUN  yum -y install httpd
and we know that we are starting the service using the instruction cmd                  CMD apachectl -DFOREGROUND



and now we add another instruction which is called COPY that through this instruction we are gonna copy the "htmlcode" folder that contains 
the backspace.html.....to the http's default webroot (/var/www/html).....COPY htmlcode /var/www/html

remember at the start we have the tiny operating system which is centos:7 then in this tiny operating system we will install httpd 
then by default httpd will create a folder here  ( /var/www/html ) to store html code (and in general every type of code i thing)  

and at the end we create a line to start the service  CMD apachectl -DFOREGROUND


dockerfile complete


 FROM centos:7
 RUN  yum -y install httpd
 COPY htmlcode /var/www/html
 CMD apachectl -DFOREGROUND

 so now lets build this image 

 docker build -t apachewithcode:v1 .
 
 *note here we use -t flag to specify the tag of this image  and we can specify the dockerfile with -f dockerfile
 but remember that by default Docker will look for a file called dockerfile and if the file is called Dockerfile then we dont need to specify it but if it called 
 Dockerfile2 then we need to specify it 

 but we need to provide the folder where the file is located with the .

 C:\Users\michael.kourbelis\Desktop\realstuffv1 > docker build -t myimage:v1 .


and we have 
step 1/4 : start from centos
Step 2/4 : RUN  yum -y install httpd
Step 3/4 : COPY htmlcode /var/www/html
Step 4/4 : CMD apachectl -DFOREGROUND

Successfully built eb5794802db7
Successfully tagged myimage:v1
SECURITY WARNING: You are building a Docker image from Windows against a non-Windows Docker host. 
All files and directories added to build context will have '-rwxr-xr-x' permissions. 
It is recommended to double check and reset permissions for sensitive files and directories.

now lets try to create a new container that is the one below 
remember that the image that we created  has a name with ____myimage:v1____

C:\Users\michael.kourbelis\Desktop\realstuffv1 > docker run -d --name myimagee -p 9090:80  myimage:v1
1ab9221bfe496044ff91ccc9b4474369bb24c71cd5a71e0935236bd286cca5ca

remember that image is something static and a container is just a runtime representation of that image 

now we check if our container is up and running with docker ps command 
so lets go to our browser 

and type
http://localhost:9090                           to see our centos in combination with apache 
http://localhost:9090/backspace.html            to see our backspace.html file that we have in htmlcode folder


and we will see our html code which is the folder that we just copy as a template to the image
and now our webserver is serving the content that we just copied from our host to the image itself 
through the copy instruction 
so basically this is how the copy instruction works 
you can copy a single file you can copy a bunch of files 
i just wanted you to know that the copy instruction allows you to take code or a files from your docker host and it allows you to copy those files
to your result in image  

xxiv.download files from internet using add
--------------------------------------------
in this video we are going to talk about the add instruction in docker which is pretty similar to the copy instruction that we saw before
but in this video we are going to poiny out something and probably  you are wondering ok i am learning  some docker file instructions 
but where that guy on the video takes the information from.
so lwt me show you exactly 
at any point in time you can go to google and hit "dockerfile" and thats it 
now we are going to see the difference between copy and add 
and 
basically copy allows you to copy files from your docker host i.e. from your machine to the image itself 
and 
add allows you to do exactly the same thing 
but the difference is that add allows you to download files from the internet and copy them into the image 
lets go to our docker file and try it out 

we will create the Dockerfile3 with the view to seperate the things out and also become more familiar with multiple commands in multiple files
through change 
and in dockerfile3 we are going to remove the line below
___ COPY htmlcode /var/www/html___
and add the following insrtruction to add content from the internet to this machine, so basically we are going to download the code from some url and 
we are going to put it into the image
so we are going to google and lets lookk for 
_____github sample html site____....https://github.com/mdn/beginner-html-site-styled
so here we have an index.html and we want to download the entire content and we want to put it into the web root of the web server 
so we go to the button "download zip" and perform a right click on that button and "copy the link address"
and we get the following url 

https://github.com/mdn/beginner-html-site-styled/archive/refs/heads/gh-pages.zip

and that url is in position to download the zip file 

and now our add  instruction becomes 

ADD https://github.com/mdn/beginner-html-site-styled/archive/refs/heads/gh-pages.zip  /var/www/html/code.zip

and remember that what the add instruction is going to do is that it will go to the url above and download this file ___gh-pages.zip____
and put the file in " /var/www/html/" with the name code.zip
and in the case that you live it witout name the name wil be the "gh-pages.zip"
so lets try to do this, lets build this image through 
docker build and remember that this is the version number 2 (-t apachecode:v2) and remember that now we need to specify the Dockerfile number 3 (-f Dockerfile3)

so the command will be 





C:\Users\michael.kourbelis\Desktop\realstuffv1 > docker build -t apachecode:v2 -f Dockerfile3 .

2d473b07cdd5: Pull complete
Digest: sha256:c73f515d06b0fa07bb18d8202035e739a494ce760aa73129f60f4bf2bd22b407
Status: Downloaded newer image for centos:7
eeb6ee3f44bdacting
Step 2/4 : RUN  yum -y install httpd
Running in 8e809efc094e
Loaded plugins: fastestmirror, ovl
Package httpd.x86_64 0:2.4.6-97.el7.centos.4 will be installed
2d473b07cdd5: Extracting 
Dependencies Resolveding
2d473b07cdd5: Extracting 
httpd             x86_64      2.4.6-97.el7.centos.4         updates      2.7 M

 apr               x86_64      1.4.8-7.el7                   
 apr-util          x86_64      1.5.2-6.el7                  
 centos-logos      noarch      70.0.6-3.el7.centos           
 httpd-tools       x86_64      2.4.6-97.el7.centos.4         
 mailcap           noarch      2.1.41-2.el7                 
2d473b07cdd5: Downloading 
Transaction Summaryoading 


warning: /var/cache/yum/x86_64/7/base/packages/apr-1.4.8-7.el7.x86_64.rpm: Header V3 RSA/SHA256 Signature, key ID f4a80eb5: NOKEY
Public key for apr-1.4.8-7.el7.x86_64.rpm is not installed                    
Public key for httpd-tools-2.4.6-97.el7.centos.4.x86_64.rpm is not installed  

........

and now we are going to create a new container using the image that we have created 

C:\Users\michael.kourbelis\Desktop\realstuffv1 > docker run -d --name iimage -p 9090:80  apachecode:v2
bb218f21fa3965d832ea1b8b7f010e6b15f3ada815df7fbda88cbd9c053ba07e

we took the hash and go forward.....to the browser to the port that we specify above 
e.g. http://localhost:9090/

and now if we put /code.zip you see that we enter into the file but we are not authorised to see it 
so now what we are going to do is to avoid the error 

"You don't have permission to access /code.zip on this server."
via unzipping this content "/code.zip" and put the content in the directory 
so once we hit 
http://localhost:9090/ 
we must able to see the content inside of the zip file.

so we go to the Dockerfile3 and probably above the ADD instruction we need to install another package 
 RUN  yum -y install httpd unzip
which is that ___unzip___ and below the add instruction we are going to use the run instruction  that unzipes the code.zip
that was downloaded...so we go to this directory "/var/www/html/" via cd and we unzipe code.zip

 RUN cd /var/www/html/code.zip && unzip code.zip
 so once we unzip the code in this folder in "/var/www/html/" will be a new folder that resulted from the unzip process 
 so if we go to git hub  and download the zip folder 
 if we go inside it we see the actual name of the folderf that includes the code tha we need to run

"beginner-html-site-styled-gh-pages"
so what we are going to do is to copy the name above because remember that once we unzip it this in here 
_____RUN cd /var/www/html/code.zip && unzip code.zip_____
we will have a dot name 
so we can change the location of the file /var/www/html/ by adding to this the ___beginner-html-site-styled-gh-pages___
because this file is the file that is in this zip file 
e.g. 
/var/www/html/beginner-html-site-styled-gh-pages

and the complete image of this is 

RUN cd /var/www/html/code.zip && unzip code.zip && mv /var/www/html/beginner-html-site-styled-gh-pages

so once we unzip it we will have folder beginner-html-site-styled-gh-pages as the result of the process 
so again what we are do here 

RUN cd /var/www/html/ && unzip code.zip && mv /var/www/html/beginner-html-site-styled-gh-pages


is that we change directory to this directory /var/www/html and unzip the code and then we use the linux command move (mv)
that allows us to move files from one folder to another 
so we say move this ___ /var/www/html/beginner-html-site-styled-gh-pages____
all the files under this directory /* to /var/www/html/

RUN cd /var/www/html/ && unzip code.zip && mv /var/www/html/beginner-html-site-styled-gh-pages/* /var/www/html/


so here we have two things 
the firts is that we have the && symbol that allows us to run more tha one task in one single run instruction 
so we say 
cd /var/www/html/  and please unzip the code.zip  and then move this guy  /var/www/html/beginner-html-site-styled-gh-pages/*
which is the result from the unzip process  and move all the files to the root directory __/var/www/html/___of our web server  
so now we are going to save this Dockerfile3 and we are going to build a new image with version number 3 

C:\Users\michael.kourbelis\Desktop\realstuffv1 > docker build -t apachecode:v3 -f Dockerfile3 .

and now as you can see from the terminal we are not used the cashy because we modified the parent layer and therefore all of the child layers will be affected 
so we only need to wait until the process finished and then lets see if it works 

ok the build process already finished and in the new image we should have all the content downloaded from internet in the root directory 

so to test it we are going to remove the container of version 2 of this image and create a new container using the latest image that we just 
created  which is the version3 

___docker run -d --name iimage -p 9090:80  apachecode:v3____


C:\Users\michael.kourbelis\Desktop\realstuffv1 > docker ps

CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                  NAMES
bb218f21fa39        apachecode:v2       "/bin/sh -c 'apachect"   49 minutes ago      Up 49 minutes       0.0.0.0:9090->80/tcp   iimage

C:\Users\michael.kourbelis\Desktop\real stuff\realstuffv1> docker rm -f bb218f21fa39
bb218f21fa39

so lets create the new container of that image 

C:\Users\michael.kourbelis\Desktop\real stuff\realstuffv1>docker run -d --name iimage -p 9090:80  apachecode:v3
7e38fb0696fbb3755dd4e80eb73bcd88521f4aeff87b87a6f114518536e23a72

remember that at any time that you do changes in the docker file you need to rebuild the image and you remove the container of the previous image and 
recreate the container with the new image



lets go to our browser and hit some hits 

 http://localhost:9090/

 so this produce our page and it was retrieved fromm github was unzipped and was put on the web root of our webserver  

again we are basically downloading this file which is basically a zip file from google 

https://github.com/mdn/beginner-html-site-styled/archive/refs/heads/gh-pages.zip

and we put it somewhere on the image with a new name 
__/var/www/html/code.zip__

then we just change directory from  ____cd /var/www/html/___ to /var/www/html/code.zip......as we put the zip file here 
then we unzip the file and the result of the unzip process will have this folder 

____beginner-html-site-styled-gh-pages____extracted

so basically we are saying please move all of the files under the folder ____beginner-html-site-styled-gh-pages____ and move them to the directory root 
of our web server 

xxv.want to build like a pro? use the ENV instruction
------------------------------------------------------
in this video we are going to talk about enviromental variable in the dockerfile 
so we are going to modify our Dockerfile3
and now lets say that we want to add a new environment variable which is going to be called ____html____
and it is going to reference for example these long name 
https://github.com/mdn/beginner-html-site-styled/archive/refs/heads/gh-pages.zip

or the name of the project or something like that .
so to create an environment variable in a Dockerfile we use the __ENV__ instruction which stands for environment
then we just put the name of the variable that we want.....so this is going to be the key (HTML) and the value its gonna be whatever we need it to be 
 and we want the value to be this name ___beginner-html-site-styled___

 ENV HTML beginner-html-site-styled

 so from the above line we say the following
 hey docker please create an environment variable with the key to be HTML and its value of it will be the project/folder 
 name ___beginner-html-site-styled____

 then wat we do is to remove the static name from the ADD instruction 

 ADD https://github.com/mdn/   beginner-html-site-styled    /archive/refs/heads/gh-pages.zip  /var/www/html/code.zip

                               --------------------------
      and we are going to replace it with the $HTML that we have create it using a dollar Sign to tell docker that
      we referenching an enviromental variable


 ADD https://github.com/mdn/   $HTML    /archive/refs/heads/gh-pages.zip  /var/www/html/code.zip
                               -----
      and also we can go to the run instruction and change the same name with the same $HTML variable

 RUN cd /var/www/html/ && unzip code.zip && mv /var/www/html/  beginner-html-site-styled-gh-pages  /* /var/www/html/
                                                               --------------------------------
 RUN cd /var/www/html/ && unzip code.zip && mv /var/www/html/  $HTML-gh-pages  /* /var/www/html/
                                                               -----

so here we have this enviromental variable :  ENV HTML   beginner-html-site-styled
                                                  ----   -------------------------
                                                    |               |
                                                    |               |
                                                    |               |
                                                    |               |
                                                    |               |
                                                    |               |
                                                    |               |
                                             enviromental          with 
                                                variable            its 
                                                                   value        

and as you can observe from above we just replace this __beginner-html-site-styled___  with this __$HTML___

and now if we rebuild the v4 of our image remove the container of v3 and recreate the container of the current image version 4 
mw must see the exact same result on our browser.....as the url is somehow the same as before 
so lets save the dockerfile and test it, 
but before we do this lets add something in the RUN command...another && that echoes the html variable and redirect it to a file here : "/var/www/html"
e.g. ____/var/www/html/env.html____

.....and we are creating a new file called env.html and the content of this file will be content of the enviromental variable __beginner-html-site-styled__
because we are referencing to the enviromental variable 
so now lets save it and try to build it again

Dockerfile3
-----------
 FROM centos:7
 RUN  yum -y install httpd unzip
 ENV HTML beginner-html-site-styled
 ADD https://github.com/mdn/$HTML/archive/refs/heads/gh-pages.zip  /var/www/html/code.zip
 RUN cd /var/www/html/ && unzip code.zip && mv /var/www/html/$HTML-gh-pages/* /var/www/html/ && echo $HTML > /var/www/html/env.html
 CMD apachectl -DFOREGROUND


C:\Users\michael.kourbelis\Desktop\real stuff\realstuffv1 > docker build -t apachecode:v4 -f Dockerfile3 .
C:\Users\michael.kourbelis\Desktop\real stuff\realstuffv1 > docker ps
C:\Users\michael.kourbelis\Desktop\real stuff\realstuffv1 > docker rm -f 7e38fb0696fb
7e38fb0696fb
C:\Users\michael.kourbelis\Desktop\real stuff\realstuffv1 > docker run -d --name iimage -p 9090:80  apachecode:v4

 http://localhost:9090/


 remember that if you have any running container you can keep it or delete it 
 so here we are going to launch a new container using Disney image  
 we just create an environmental variable and we just reference that enviromental varianle an appropriate spots in our Dockerfile
 but it shouldn't impact the functionality because we are just replacing values 

 so now what we need to do is that we need to make sure that we have this file (env.html) available with this value $HTML 
 so lets go here " http://localhost:9090/" to our web page and lets type /env.html.....http://localhost:9090/env.html

 so yes it displays the name of the folder ___beginner-html-site-styled____ which is came from the enviromental variable that 
 was deifned above it in 
 ENV HTML beginner-html-site-styled and it value was passed as text inside the  env.html

xxvi.being organized matters! understand the workdir instruction
----------------------------------------------------------------
in this video we are going to talk about the working directory in docker 
lets go to our Dockerfile3 and lets just take a look at that 
if you see here 
basically what we have is that we are building everything on top of the centos image  
so you can thing of that like a tiny operating system 
basically a container is a tiny operating system that is running one or more processes because if you see every container
should have an operating system or the basics for an operating system like centos or debian or alpine or something like kolikithi toumpano
but a container should have an operating system because as you see here   
 RUN  yum -y install httpd unzip
we are running a lot of tasks and these tasks are run in this os thats why we use "yum" thats why we can do "cd" and change directories 
thats why we use unzip packages    and thats why we can use these commands "mv"
so keep in mind that a container is a tiny thing that has an os running on it  and the os is normally defining in the from instruction  
if you are starting from another image then you are inheriting the OS of that image 


so now that we know this is that we can talk  about the workdir or a working directory 
so we are going to put something in the Dockerfile3 that includes new instructions e.g. the instruction in the 
docker file to define that working directory is workdir
and this actually means where are you running your commands 
so here 
__ RUN  yum -y install httpd unzip__
we dont know where we are running the commands because we dont really know it probably going to be in the route 
but if you want for example create some folder and then  change directory to that folder you can do it like this ___cd___
or you can specify the working directory   
in this case you see that we are actually change directory to this directory "/var/www/html/" because  we want to sit in this directory 
and unzip the code.zip file    which is  an the add instruction

 ADD https://github.com/mdn/$HTML/archive/refs/heads/gh-pages.zip  /var/www/html/code.zip

 and then move all the things to that " mv /var/www/html/$HTML-gh-pages/*"
 and basically do a bunch of stuff in this directory "/var/www/html/"
so what we can do here is that we can actually defined it working directory to this folder  
and what is going to happen is that whenever docker gets to this step "workdir" its going to change directory to this 
"/var/www/html/" and now we will be able to run things and modify files inside of this folder "/var/www/html/"

so now we dont need this instruction anymore (cd /var/www/html/) as we already change  the directory in the 
 WORKDIR /var/www/html/  for all the subsequent steps 

 so what we can do is that we can just go straight to unzip the code zip file which is in the run instruction which located under the workdir instruction 
 and then we can just move the HTML pages (mv /var/www/html/$HTML-gh-pages/*) which is in this directory now $HTML-gh-pages/*
 as we use the workdir instruction now and then  
 so we are moving this directory ($HTML-gh-pages/*) and all of its content to our current directory and we specify the current directory with the dot
 and then we redirect the file env.html to the folder of  /var/www/html/ in the workdir 
 so we go again to the run instruction and change the /var/www/html/env.html with the ./env.html
 which means the (current directory) create the file under the current directory 

 so we replace this 
 RUN  unzip code.zip && mv /var/www/html/$HTML-gh-pages/* /var/www/html/ && echo $HTML > /var/www/html/env.html
 with this 
 RUN  unzip code.zip && mv $HTML-gh-pages/* . && echo $HTML > ./env.html

 ADD https://github.com/mdn/$HTML/archive/refs/heads/gh-pages.zip  /var/www/html/code.zip

 now if you see the add instruction above workdir we are also using  again the directory  /var/www/html
 so we copy workdir and place it above the add instruction  and make appropriate changes to the add instruction
 e.g. make exactly the same thing as before.....we are going to add this  zip file to the current directory in a file called code.zip
 so  
  ADD https://github.com/mdn/$HTML/archive/refs/heads/gh-pages.zip  ./code.zip

  and we dont need the full path because we already are in the working directory via the  WORKDIR /var/www/html/ which is the same like we say 
  cd  /var/www/html/
  or everything under this workdir instruction will be run in its path and then all the paths that you will use (all of the relative paths) 
  will be under this directory  "workdir" 

  so with workdir we are saying 
  WORKDIR /var/www/html/ = ok i am already in this directory so i am going to download the file
  https://github.com/mdn/$HTML/archive/refs/heads/gh-pages.zip
  
  to this directory ./code.zip......as i am already in this directory 

  ADD https://github.com/mdn/$HTML/archive/refs/heads/gh-pages.zip  ./code.zip

then i am going to unzip the code.zip as for one more time i am already in this directory and move the mv $HTML-gh-pages/* 
which is the result of the instruction and the we are going to create a new file "env.html" and add in html p element 
with the text of the folder name 

RUN  unzip code.zip && mv $HTML-gh-pages/* . && echo $HTML > ./env.html

basically thats how the workdir works 
it saves a lot of typing because you dont need to repeat the same directory again if you just want to work on the same directory you just go ahead and defined 
the workdir  instruction  and point where your working directory is 


 FROM centos:7
 RUN  yum -y install httpd unzip
 ENV HTML beginner-html-site-styled
 WORKDIR /var/www/html/
 ADD https://github.com/mdn/$HTML/archive/refs/heads/gh-pages.zip  ./code.zip
 RUN  unzip code.zip && mv $HTML-gh-pages/* . && echo $HTML > ./env.html
 CMD apachectl -DFOREGROUND


so lets save the file above and lets try to build an image using the following commands


C:\Users\michael.kourbelis\Desktop\real stuff\realstuffv1 > docker build -t apachecode:v5 -f Dockerfile3 .
C:\Users\michael.kourbelis\Desktop\real stuff\realstuffv1 > docker ps
C:\Users\michael.kourbelis\Desktop\real stuff\realstuffv1 > docker rm -f 7e38fb0696fb
7e38fb0696fb
C:\Users\michael.kourbelis\Desktop\real stuff\realstuffv1 > docker run -d --name iimage -p 9090:80  apachecode:v5

 http://localhost:9090/



 now remember that iusing one image we can deploy as many containers as we want  but each container must have a 
 differentr name 
 different port 
 differeent image version

 and through these we have the same image running in multiple containers that have different name different id  and so on 
 in our cas e 5he version 4 contains no working directory in the docker file

 of course we can modify the code behind each version 
 no the image is one 
 but if we make copys of the folders that contain the code abd call it from the dockerfile possibly we can 
 i don try it but depending that we are developers and in developing everything is possible which is a phrase similar 

what we did is that we changee a couple of things to implement the working directory here  
 
________________________________________________________________________________________________________________________________
| Alpine Linux vs Debian: What are the differences?                                                                             |
|                                                                                                                               |
|    apline linux...                                                                                                   |
|  alpine-linux       linux     lightweight  security-oriented        |
|          functions                 |
|    security     destroy                |
| Task     accomplished      network protocol utilization    manipulation           |
|     flexible data distribution       port forwarding.... alpine-linux    |    
|   security-oriented lightweight linux distribution     musl libc   busybox                    |
|                                                                                                                               |
|     debian   universal operating system,  debian           |
|   linux kernel   Freebsd  linux   piece of software      Linus Torvalds  |  
|    thousands of programmers  ( ).                                                      |
| FreeBSD         kernal   ....                                 |
|                                                                                                                               |
|    "stackshare"  debian           approval  387 company stacks       |
|  390 developers stacks ( )     alpine linux    listed in 39 company stacks        |
| 17 developer stacks (    )                                                                          |
________________________________________________________________________________________________________________________________



 xxvii.metadata on the way! use labels to follow the best practices 
 ------------------------------------------------------------------
 in this video we are going to talk about labels in dockerfile 
 well a labelis nothing else but something similar to a tag and it is something that normally becomes the metadata of the image 
 so go ahead and open up our docker file and 
 a label instruction is something like this:
 Label (you just put the label, and then you start passing some metadata after ) it could be the versio of the image, normally what people put here is the maintainer
 maintainer = mike
 LABEL maintainer = mike
 or make a label that is the vendor of this applicationn
 LABEL vendor = companyb
 but basically labels are noithing else but metadatam they have not any functionality they are just to inform who maintains the app which version 
 is exposing it who is the vendor of it 
 you know all the metadata.....all the metadata that you want to put here you can just do it but the usual ones are the maintainer and the vendor that are widely used 
but you can put whatever you want here....lets put a random thing here ....LABEL random=yay

 FROM centos:7
 RUN  yum -y install httpd unzip
 LABEL maintainer=mike
 LABEL vendor=companyb
 LABEL random=yay
 ENV HTML beginner-html-site-styled
 WORKDIR /var/www/html/
 ADD https://github.com/mdn/$HTML/archive/refs/heads/gh-pages.zip  ./code.zip
 RUN  unzip code.zip && mv $HTML-gh-pages/* . && echo $HTML > ./env.html
 CMD apachectl -DFOREGROUND


 so lets save this and the process is known from now


C:\Users\michael.kourbelis\Desktop\real stuff\realstuffv1 > docker build -t apachecode:v6 -f Dockerfile3 .
and you can see the labels 

Step 3/10 : LABEL maintainer=mike                  ---> Running in b6e0b9ac3cb3
Removing intermediate container b6e0b9ac3cb3       ---> ef0d391c09b2
Step 4/10 : LABEL vendor=companyb                  ---> Running in b62f977d1119
Removing intermediate container b62f977d1119       ---> 3e103eebb6cb
Step 5/10 : LABEL random=yay

C:\Users\michael.kourbelis\Desktop\real stuff\realstuffv1 > docker ps
C:\Users\michael.kourbelis\Desktop\real stuff\realstuffv1 > docker rm -f 7e38fb0696fb
7e38fb0696fb
C:\Users\michael.kourbelis\Desktop\real stuff\realstuffv1 > docker run -d --name iimage -p 9090:80  apachecode:v6

 http://localhost:9090/

xxviii.quick tip:browse the content of an image by creating a container
-----------------------------------------------------------------------
in this video we are going to talk about users and how to handle users in a docker file, the first thing that we are going to do
is to take a look at our containers here we have the one above all the others are deleted so now according to video 
the version 5 of the image is the one that contains the workdir which means that the container of version 5 we have the working directory 
set as var/www/html
now there is something that i want to show you and that is that you can actually go inside of a runing container 
rememebr that  the container of the 5th version of the image is a guy that hasn't stop running 
so if we had it with us right now  we wanted to enter inside of this container 
remember that i told you that container is like a tiny thing that runs an operating system so we can exec or we can go inside of that container 
because its running one operating system with a bash terminal 
so now what we want to do is that we want to enter inside of the container and see whats inside of the container
remember that the container is a read and write layer that sits on top of the imageb and this actually the runtime of the image 
so now we are going to copy this name 
aaannd the question is how we enter into a container ?
well we type ___docker exec___ which allows us to exec or go inside of the container then we type 
-ti (which stands for terminal interactive,basically this allows to do interactive input  ) then we type the name of the container 
which was ___iimage___ and then we pass bash here   which is the terminal that we want to use 

docker exec -ti iimage bash 

now we can perform it and on the image that we have now to see how it looks like to be inside the container

C:\Users\michael.kourbelis\Desktop\real stuff\realstuffv1>docker exec -ti iimage bash
[root@ba3c68551531 html]#

in here [root@ba3c68551531 html]#  we are inside  of a container which is not your machine is something different  to exit from the container simply type 
exit 
[root@ba3c68551531 html]# exit


ok now we are inside the container lets type pwd which stands and displays for/the present working directory

C:\Users\michael.kourbelis\Desktop\real stuff\realstuffv1>docker exec -ti iimage bash
[root@ba3c68551531 html]# pwd
/var/www/html-------------------------->our working directory in the docker file, and once the container is created it holds all the metadata 
[root@ba3c68551531 html]#               so basically we can do even and echo on the environmental variable that we have created  e.g. 
                                        and displays it

[root@ba3c68551531 html]# echo $HTML 
beginner-html-site-styled
[root@ba3c68551531 html]#

the only thing that i want to show you for now is that you can exec inside of a container and you can take a look at everything that is inside of that container 
so if you type ll ......you will see the extracted code that we actually created 

toy are going to see this folder  ___beginner-html-site-styled-gh-pages___
which is the folder that was the result of the extraction 
and we still have this code....code.zip because we haven't delete it 

[root@ba3c68551531 html]# ll......or ls-l

[root@ba3c68551531 html]# ll
total 96
-rw-r--r-- 1 root root   689 Apr  4  2019 CODE_OF_CONDUCT.md
-rw-r--r-- 1 root root  6555 Apr  4  2019 LICENSE
-rw-r--r-- 1 root root   469 Apr  4  2019 README.md
drwxr-xr-x 2 root root  4096 Feb 21 14:28 beginner-html-site-styled-gh-pages
-rw------- 1 root root 60674 Jan  1  1970 code.zip
-rw-r--r-- 1 root root    26 Feb 21 14:28 env.html
drwxr-xr-x 2 root root  4096 Apr  4  2019 images
-rw-r--r-- 1 root root  1082 Apr  4  2019 index.html
drwxr-xr-x 2 root root  4096 Apr  4  2019 styles
[root@ba3c68551531 html]#


now if we put the dockefrile below and check for what are the relationships between the two you will see that 

the first thing here is that we have an environmental variable here in Dockerfile called $HTML
then we echo it from the container and its get displayed that means that the variable is available in the container execution 
then we just the worjking directoryb to /var/www/html/

and if you see if we try to log in to this current container we actually fell upon this path via the pwd command ..../var/www/html
if we didn't set any working directory then we fall in the root directory....i think

then what we do is that we add the file 
https://github.com/mdn/$HTML/archive/refs/heads/gh-pages.zip 
to the 
./code.zip file which if you look more closely to the container somewhere it mentions the ___code.zip__
and remember that we dont delete this file at any point and under no generally no
then we unzip the  code.zip file which actually gives you this folder 
___beginner-html-site-styled-gh-pages___
as a result of the instruction 
and you know that all of the email of the html files are iving there 
so we move all the files under this directory  ___beginner-html-site-styled-gh-pages___ 
which is this directory $HTML-gh-pages/*
and we move it to the current directory with the use of the dot .  
and we end upm with the files above when we perform ___ll____ in the container 
and finally we do an echo $HTML > ./env.html that adds to env.html the text of the variable $HTML to the current directory 
and that results in this file of the container 
env.html

now in the container what i want to do is to remove this folder ___beginner-html-site-styled-gh-pages___ 
and remove this file ___code.zip___
but we are going ot have some problems with the ownership and the users 

so in this video you see how to exec in a container you see that you can go inside of a container and you can browse all of the files, all the file system 
using the commands that you know 
and the container is actually a tiny operating system that is running there 
so you can at any time go inside and check what is going on inside of your container 

xxix.keep it up handle USERs in your dockerfile
-----------------------------------------------
hello and welcome back...now that we know that we can ___exec__ at any time into a running container
we are going to check the files that are extracted from the comand __ll__


C:\Users\michael.kourbelis\Desktop\real stuff\realstuffv1  >  docker exec -ti iimage bash
Error response from daemon: 
Container ba3c6855153128d8447802ffb16957de14d70e61cbfdbcc94f86f0606b12095f is not running

C:\Users\michael.kourbelis\Desktop\real stuff\realstuffv1  >  docker ps 

C:\Users\michael.kourbelis\Desktop\real stuff\realstuffv1  >  docker rm -f ba3c68551531
ba3c68551531

C:\Users\michael.kourbelis\Desktop\real stuff\realstuffv1 > docker build -t i7:v11 -f Dockerfile3 .
C:\Users\michael.kourbelis\Desktop\real stuff\realstuffv1 > docker run -d --name iimage -p 9090:80  i7:v11

C:\Users\michael.kourbelis\Desktop\real stuff\realstuffv1  >  docker exec -ti iimage bash

[root@ba3c68551531 html]# ll
total 96
-rw-r--r-- 1 root root   689 Apr  4  2019 CODE_OF_CONDUCT.md
-rw-r--r-- 1 root root  6555 Apr  4  2019 LICENSE
-rw-r--r-- 1 root root   469 Apr  4  2019 README.md
drwxr-xr-x 2 root root  4096 Feb 21 14:28 beginner-html-site-styled-gh-pages
-rw------- 1 root root 60674 Jan  1  1970 code.zip
-rw-r--r-- 1 root root    26 Feb 21 14:28 env.html
drwxr-xr-x 2 root root  4096 Apr  4  2019 images
-rw-r--r-- 1 root root  1082 Apr  4  2019 index.html
drwxr-xr-x 2 root root  4096 Apr  4  2019 styles
[root@a970a8a88b15 html]#


so in the firts place we are going to delete the following two folders 


i  . beginner-html-site-styled-gh-pages
ii . code.zip

but from the dockerfile because remember that 
if i go ahead and remove these from the container....remember that the container layer  is a temporary layer and if i go and do the deletion
like below 
ok in the next extraction we will not see them but the didn't removed completely the look like the removed  

[root@a970a8a88b15 html]# rm -rf  beginner-html-site-styled-gh-pages code.zip

[root@ba3c68551531 html]# ll
total 30
-rw-r--r-- 1 root root   689 Apr  4  2019 CODE_OF_CONDUCT.md
-rw-r--r-- 1 root root  6555 Apr  4  2019 LICENSE
-rw-r--r-- 1 root root   469 Apr  4  2019 README.md
-rw-r--r-- 1 root root    26 Feb 21 14:28 env.html
drwxr-xr-x 2 root root  4096 Apr  4  2019 images
-rw-r--r-- 1 root root  1082 Apr  4  2019 index.html
drwxr-xr-x 2 root root  4096 Apr  4  2019 styles
[root@a970a8a88b15 html]#


now if i perform exit from the container's mode and go back to my folder and delete the container 
C:\Users\michael.kourbelis\Desktop\real stuff\realstuffv1  >  docker ps 
C:\Users\michael.kourbelis\Desktop\real stuff\realstuffv1  >  docker rm -f a970a8a88b15

then ok it removed but and the files were supposedly removed but now lets launch a new container with the same image 
and remember that instead of the image we have all of the configuration 

C:\Users\michael.kourbelis\Desktop\real stuff\realstuffv1 > docker run -d --name iimage -p 9090:80  apachecode:v6

so now lets trye exec the container and perform the ll command 

C:\Users\michael.kourbelis\Desktop\real stuff\realstuffv1  >  docker exec -ti iimage bash

[root@ba3c68551531 html]# ll

[root@c7e4d7cedaf0 html]# ll
total 96
-rw-r--r-- 1 root root   689 Apr  4  2019 CODE_OF_CONDUCT.md
-rw-r--r-- 1 root root  6555 Apr  4  2019 LICENSE
-rw-r--r-- 1 root root   469 Apr  4  2019 README.md
drwxr-xr-x 2 root root  4096 Feb 21 14:28 beginner-html-site-styled-gh-pages
-rw------- 1 root root 60674 Jan  1  1970 code.zip
-rw-r--r-- 1 root root    26 Feb 21 14:28 env.html
drwxr-xr-x 2 root root  4096 Apr  4  2019 images
-rw-r--r-- 1 root root  1082 Apr  4  2019 index.html
drwxr-xr-x 2 root root  4096 Apr  4  2019 styles
[root@c7e4d7cedaf0 html]#

so you see that the files are again here although we delete them previously 
well because you created a new container and all the information is inside the image....
so basically if you want to do a permanent change you need to modify the image 
but you know that you cannot modify an image 
so basically you will need to build a new image 
so thats we are gonna do 

lets modify our dockerfile3 and add some lines there as we are going to use the USER instruction 
which allows us to switch users in a dockerfile

but first we need to create the user first because we dont have any user yet  
so now lets use the instruction RUN and via it we utilize the useradd which we add the user application

RUN useradd application

so now we have a user called application and we can use it
so now we are able to makes use of the instruction USER and switch user with the run instruction above 
because currently everything is run as root 
so we can do the following 

USER application

so remember Here

RUN useradd application

we made use of a linux instruction to add users which is useradd and we add a new user which is called application 
and then we switch to that user ...i.e. to that application user and then 
we will try to remove the files that are still missing here  ___$HTML-gh-pages___

so we will say run remove....,but remember that we are in this directory ___/var/www/html/___ because this is the working directory 
so we makes use of a linux command and remove the code.zip and also remove ths folder ___$HTML-gh-pages___
but probably we will have an error here because of permissions 
so we remove it and thn go to search the error

RUN rm -rf code.zip  $HTML-gh-pages



complete 

RUN useradd application
USER application
RUN rm -rf code.zip  $HTML-gh-pages


so lets go and see when we extracted all the files of the container with their permissions 


[root@c7e4d7cedaf0 html]# ll
total 96
-rw-r--r-- 1 root root   689 Apr  4  2019 CODE_OF_CONDUCT.md
-rw-r--r-- 1 root root  6555 Apr  4  2019 LICENSE
-rw-r--r-- 1 root root   469 Apr  4  2019 README.md
drwxr-xr-x 2 root root  4096 Feb 21 14:28 beginner-html-site-styled-gh-pages
-rw------- 1 root root 60674 Jan  1  1970 code.zip
-rw-r--r-- 1 root root    26 Feb 21 14:28 env.html
drwxr-xr-x 2 root root  4096 Apr  4  2019 images
-rw-r--r-- 1 root root  1082 Apr  4  2019 index.html
drwxr-xr-x 2 root root  4096 Apr  4  2019 styles
[root@c7e4d7cedaf0 html]#

as you can see everything is under the ___root user___ 
you can even see that once we get inside of the container that root user is the user that is coming by default 
and all of the file above are being owned by the root user 

so now that we created another user which is called "application user" and then we switch it that user 
and noiw if we tried to delete one of these file we are going to have errors becasue the application user is not the 
owner of these files...so we will have errors  

so now lets try to build this image to see this in action 

lets buiild the the version number seven 

 FROM centos:7
 RUN  yum -y install httpd unzip
 LABEL maintainer=mike
 LABEL vendor=companyb
 LABEL random=yay
 ENV HTML beginner-html-site-styled
 WORKDIR /var/www/html/
 ADD https://github.com/mdn/$HTML/archive/refs/heads/gh-pages.zip  ./code.zip
 RUN  unzip code.zip && mv $HTML-gh-pages/* . && echo $HTML > ./env.html
 RUN useradd application
 USER application
 RUN rm -rf code.zip  $HTML-gh-pages
 CMD apachectl -DFOREGROUND

C:\Users\michael.kourbelis\Desktop\real stuff\realstuffv1 > docker build -t apachecode:v7 -f Dockerfile3 .

Step 12/13 : RUN rm -rf code.zip  $HTML-gh-pages
 ---> Running in 19d9df5e3aff
rm: cannot remove 'code.zip': Permission denied
rm: cannot remove 'beginner-html-site-styled-gh-pages': Permission denied

the errors, we cannot remove these files using the user application because as i told you these files are owned by the root user 
so how can we solve it 
ok so lets go to the Dockerfile3 and in linux we have something that looks like the change owner command
so lets go inside of a container to show you the command 


C:\Users\michael.kourbelis\Desktop\real stuff\realstuffv1  >  docker exec -ti iimage bash

now before we change the user we must first add the application user because we dont have that user
remember that all of these changes are temporary.....
if you want a permanent change you will need to modify the dockerfile 
but here we are just testing it  

[root@ba3c68551531 html]# useradd application

now we add the user application which is great and now we go ahead and change the ownership of the files below:

drwxr-xr-x 2 root root  4096 Feb 21 14:28 beginner-html-site-styled-gh-pages
-rw------- 1 root root 60674 Jan  1  1970 code.zip

and how do we pass that ownership to the application user, well this can be achieved through the command su application inside of a container

[root@ba3c68551531 html]# su application
[application@c7e4d7cedaf0 html]$ whoami
application
[application@c7e4d7cedaf0 html]$


now again if i try to remove these files above 

[application@c7e4d7cedaf0 html]$ rm -rf code.zip we see that the "permission is denied" because if i clear the screen 
i will see that the root user is again  the owner of all the files and the application user doesn't have permissions on these files 
so how do we fix it 

well its super simple....lets exit from the container but lets notice that we are inside of the container again because we were exited from the application user
not from the root user 

    [application@c7e4d7cedaf0 html]$ exit
    exit
    [root@c7e4d7cedaf0 html]#

now how do we fix the error and how do we give permission to the application user?
well we can go back cd.. here and you see that the parent folder of all the folders of the container files is the "html" remember "/var/www/html"
so see this 

[root@c7e4d7cedaf0 html]# cd ..
[root@c7e4d7cedaf0 www]# ll
total 8
drwxr-xr-x 2 root root 4096 Jan 25 14:09 cgi-bin
drwxr-xr-x 1 root root 4096 Feb 21 14:28 html
[root@c7e4d7cedaf0 www]#

and from here we can do the chown (change owner) linux command to change the ownership of this folder and all of the file inside of the folder 

so via the following command we say please man change the owner and as the new owner use the application user : and the application user as a group and 
apply this configuration to html folder recursively -R
which means that now all of the files in this directory (html)
so 
[root@c7e4d7cedaf0 www]# chown application:application html -R

and now if we do an ll we see that the application user is now the owner of the html folder (drwxr-xr-x 1 application application 4096 Feb 21 14:28 html)
[root@c7e4d7cedaf0 www]# ll

---------------------------------------------------------------
[root@c7e4d7cedaf0 www]# chown application:application html -R
[root@c7e4d7cedaf0 www]# ll
total 12
drwxr-xr-x 2 root        root        4096 Jan 25 14:09 cgi-bin
drwxr-xr-x 1 application application 4096 Feb 21 14:28 html
[root@c7e4d7cedaf0 www]#
----------------------------------------------------------------

so lets change directory to --> cd html /

[root@c7e4d7cedaf0 www]# cd html/
[root@c7e4d7cedaf0 html]#

and now if we do  an ll i can see that the  application user is the owner of all of the container's files right now 


 [root@c7e4d7cedaf0 html]# ll
total 104
-rw-r--r-- 1 application application   689 Apr  4  2019 CODE_OF_CONDUCT.md
-rw-r--r-- 1 application application  6555 Apr  4  2019 LICENSE
-rw-r--r-- 1 application application   469 Apr  4  2019 README.md
drwxr-xr-x 1 application application  4096 Feb 21 14:28 beginner-html-site-styled-gh-pages
-rw------- 1 application application 60674 Jan  1  1970 code.zip
-rw-r--r-- 1 application application    26 Feb 21 14:28 env.html
drwxr-xr-x 1 application application  4096 Apr  4  2019 images
-rw-r--r-- 1 application application  1082 Apr  4  2019 index.html
drwxr-xr-x 1 application application  4096 Apr  4  2019 styles
[root@c7e4d7cedaf0 html]#

which means that now if we create the user application with ___su application___ and we try to remove the files that we want
we realise soon that we can  

[root@c7e4d7cedaf0 html]# rm -rf code.zip

so basically we need to automate all of these process in the Dockerfile 
so lets get out of this user (application user) 
[root@c7e4d7cedaf0 html]# exit 
   lets get out of this container and go to our machine...how do you know that you are in your machine....well you know hahahahhah


   so lets modify our Dockerfile3

   before 
        FROM centos:7

        RUN  yum -y install httpd unzip

        LABEL maintainer=mike

        LABEL vendor=companyb

        LABEL random=yay

        ENV HTML beginner-html-site-styled

        WORKDIR /var/www/html/

        ADD https://github.com/mdn/$HTML/archive/refs/heads/gh-pages.zip  ./code.zip

        RUN  unzip code.zip && mv $HTML-gh-pages/* . && echo $HTML > ./env.html

        RUN useradd application

        USER application

        RUN rm -rf code.zip  $HTML-gh-pages

        CMD apachectl -DFOREGROUND

so now we already added the user application (RUN useradd application) so thats great 
and we switched to that user (USER application) its like we doing ___su application___
we actually switched using the user instruction and then we tried to remove the code.zip file and the html folder 
but the question here is 
what are we missing ?
and well we are missing the change on permission 

remember that we must do it before we switching to the user because once we switch to this user (user application) 
then this user will onlybe able to do things on files owned by him 
so we need to do that ownership here  e.g. 

we can actually say change the owner and please put the application user and the appliacation group on /var/www/html and please do it recursively
RUN useradd application && chown application:application /var/www/html -R
then we add the user 
USER application

so in a nutshell 
RUN useradd application && chown application:application /var/www/html -R

ok user added and now make that user the owner of this folder /var/www/html
remember that now we are here /var/www/html/ at this level and we want the user application to be the owner of the html folder 
so now that the user application is thw owner of this folder and is owner of all of the files inside of that folder we can switch to this user and then we can just remove 
the files that we no longer need.

   after 
        FROM centos:7

        RUN  yum -y install httpd unzip

        LABEL maintainer=mike

        LABEL vendor=companyb

        LABEL random=yay

        ENV HTML beginner-html-site-styled

        WORKDIR /var/www/html/

        ADD https://github.com/mdn/$HTML/archive/refs/heads/gh-pages.zip  ./code.zip

        RUN  unzip code.zip && mv $HTML-gh-pages/* . && echo $HTML > ./env.html

        RUN useradd application && chown application:application /var/www/html -R

        USER application

        RUN rm -rf code.zip  $HTML-gh-pages

        CMD apachectl -DFOREGROUND

so lets save this dockerfile and lets build a new image with the version number 7 as you remember the version number 7 failed before


C:\Users\michael.kourbelis\Desktop\real stuff\realstuffv1 > docker build -t apachecode:v7 -f Dockerfile3 .


Step 10/13 : RUN useradd application && chown application:application /var/www/html -R ---> Running in 64dea93e548a
Removing intermediate container 64dea93e548a                                           ---> 0d20b70439de
Step 11/13 : USER application                                                          ---> Running in a05bbb927888
Removing intermediate container a05bbb927888                                           ---> 75d0d44d01d1
Step 12/13 : RUN rm -rf code.zip  $HTML-gh-pages                                       ---> Running in da12a4fe268b
Removing intermediate container da12a4fe268b                                           ---> de12c2cc83c2



C:\Users\michael.kourbelis\Desktop\real stuff\realstuffv1 > docker run -d --name iimageei -p 9091:80  apachecode:v7

C:\Users\michael.kourbelis\Desktop\real stuff\realstuffv1  >  docker exec -ti iimage bash

[root@c7e4d7cedaf0 html]# ll

now hat i see here is that the files are not deleted and why this is happening 

total 104
-rw-r--r-- 1 application application   689 Apr  4  2019 CODE_OF_CONDUCT.md
-rw-r--r-- 1 application application  6555 Apr  4  2019 LICENSE
-rw-r--r-- 1 application application   469 Apr  4  2019 README.md
drwxr-xr-x 1 application application  4096 Feb 21 14:28 beginner-html-site-styled-gh-pages
-rw------- 1 application application 60674 Jan  1  1970 code.zip
-rw-r--r-- 1 application application    26 Feb 21 14:28 env.html
drwxr-xr-x 1 application application  4096 Apr  4  2019 images
-rw-r--r-- 1 application application  1082 Apr  4  2019 index.html
drwxr-xr-x 1 application application  4096 Apr  4  2019 styles
[root@c7e4d7cedaf0 html]#


this is because of the followings.....




lets do a __docker ps -a___ but before lets  do its ps 

C:\Users\michael.kourbelis\Desktop\real stuff\realstuffv1>docker ps
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                  NAMES
c7e4d7cedaf0        apachecode:v6       "/bin/sh -c 'apachect"   2 hours ago         Up 3 hours          0.0.0.0:9090->80/tcp   iimage


we see that our container is not there and why 

C:\Users\michael.kourbelis\Desktop\real stuff\realstuffv1>docker ps -a
CONTAINER ID        IMAGE                                                                     COMMAND                  CREATED             STATUS                     PORTS                  NAMES
503ac70ddb52        apachecode:v7                                                             "/bin/sh -c 'apachect"   7 minutes ago       Exited (1) 7 minutes ago                          iimageei
9172d66b2705        apachecode:v7                                                             "/bin/sh -c 'apachect"   8 minutes ago       Created                                           iimagee
19d9df5e3aff        sha256:1ab8ab6458086c213c39f5f714a8a66fece1770247451b55fd030d408dd58709   "/bin/sh -c 'rm -rf c"   About an hour ago   Exited (1) 2 hours ago                            boring_heyrovsky
c7e4d7cedaf0        apachecode:v6                                                             "/bin/sh -c 'apachect"   2 hours ago         Up 3 hours                 0.0.0.0:9090->80/tcp   iimage

C:\Users\michael.kourbelis\Desktop\real stuff\realstuffv1>


we see that the container with the name iimageei is exited but we dont know why 
now how do we fi=nd or how do we find the reason by which a container died 
well 
you can just copy the name of the container (iimageei) 
and  use a new docker command called __logs__

C:\Users\michael.kourbelis\Desktop\real stuff\realstuffv1>docker logs iimageei
time="2022-02-22T12:53:53+02:00" level=error msg="Error parsing media type:  error: mime: no media type"
AH00558: httpd: Could not reliably determine the server's fully qualified domain name, using 172.17.0.3. 
Set the 'ServerName' directive globally to suppress this message
(13)Permission denied: AH00058: Error retrieving pid file /run/httpd/httpd.pid
AH00059: Remove it before continuing if it is corrupted.

C:\Users\michael.kourbelis\Desktop\real stuff\realstuffv1>


you can see that ____Permission denied: AH00058: Error retrieving pid file /run/httpd/httpd.pid_____

permuission denied to retrieve  pid file /run/httpd/httpd.pid
and why is it complaining about permissions ?
well its because we set-switched to  the application user in the docker file as the owner of the file and 
the application user doesn't have permissions to start the service ( CMD apachectl -DFOREGROUND)
so what we can do is to go to the docker file and realize that the application user is the user that is working on this dockerfile 
so this user is trying to start the service but it can't as it doesn't have the permission or the power to do that 
so what we are gonna do is to add a simple line 
 exactly above the 
 CMD apachectl -DFOREGROUND.......the line that switch back to the root user 
 USER root
 
 and thats it if we switch back to the user route then that user root will be able to 
 start this service  CMD apachectl -DFOREGROUND



so once again

C:\Users\michael.kourbelis\Desktop\real stuff\realstuffv1 > docker build -t apachecode:v7 -f Dockerfile3 .

C:\Users\michael.kourbelis\Desktop\real stuff\realstuffv1 > docker run -d --name iimageei -p 9091:80  apachecode:v7

C:\Users\michael.kourbelis\Desktop\real stuff\realstuffv1  >  docker exec -ti iimage bash

ti lathos exei ginei stis apo panw dyo grammes?

[root@ca95f9791364 html]# ll
total 32
-rw-r--r-- 1 application application  689 Apr  4  2019 CODE_OF_CONDUCT.md
-rw-r--r-- 1 application application 6555 Apr  4  2019 LICENSE
-rw-r--r-- 1 application application  469 Apr  4  2019 README.md
-rw-r--r-- 1 application application   26 Feb 22 11:14 env.html
drwxr-xr-x 1 application application 4096 Apr  4  2019 images
-rw-r--r-- 1 application application 1082 Apr  4  2019 index.html
drwxr-xr-x 1 application application 4096 Apr  4  2019 styles
[root@ca95f9791364 html]#


now we se that the two files delete it because the container is up and running as we switched back to the user root which allows us 
to start processes  in a  container so if you type docker logs iimageei

C:\Users\michael.kourbelis\Desktop\real stuff\realstuffv1>docker logs iimageei
time="2022-02-22T13:23:12+02:00" level=error msg="Error parsing media type:  error: mime: no media type"
AH00558: httpd: Could not reliably determine the server's fully qualified domain name, using 172.17.0.2. Set the 'ServerName' directive globally to suppress this message

C:\Users\michael.kourbelis\Desktop\real stuff\realstuffv1>

and now if you go to the localhost:9091....you will see to batman ntymeno spiderman

so in this video you learn how 
to use the user instruction in a docker file 
to switch users 
to add users 

xxx.make your image flexible use ARGs in the build process
-----------------------------------------------------------
hello and welcome back here what we learn around arguments in the dockerfile
there is something that is called args in a dockerfile which allows us to pass input when we are going to build  an image 
like kind of a parameter right   
so say that you want to pass something like aparameter to your build and you want that value to be taken in the build of your image 
so how does it work 

so lets try to do something, first we try to create a user dynamically

so below "FROM centos:7"
we are gonna use an arg....ARG thats how we define args in the dockerfile so the argument will be USER and you can give it a default value 
like application  or you leave it empty....in our case we are going to put a default value for now

ARG user=application...so we are creating an argument which is gonna be the user and its value will be the application  by default
so now it is time to reference that user  and this must be done 
above the line  
"RUN rm -rf code.zip  $HTML-gh-pages"

so we say 
USER $user...... so basically we put a dollar sign here referencing to this user 

so now what we are going to do is we are going to build the image and we are going to pass a different name which is not going to be application
its going to be "app" whatever it is and then that value should be used in the USER instruction
and also in the run instruction replace the name of the user, the value and the group   e.g. 

RUN useradd $user && chown $user:USER $user /var/www/html -R
USER $user

now these instructions are gonna take the value that will be inputted from here  ARG user=application

so you know if you dont pass any arguments you are going to have the "application" by default but if you passing other values 
then of course this user in our ARG instruction is going to be overriden 
so we are going to add that user that we input 
we are going to change the permissions to that user   RUN useradd $user && chown $user:USER $user /var/www/html -R


 and we are going to switch that user --> USER $user




 FROM centos:7
 ARG user=application
 RUN  yum -y install httpd unzip
 LABEL maintainer=mike
 LABEL vendor=companyb
 LABEL random=yay
 ENV HTML beginner-html-site-styled
 WORKDIR /var/www/html/
 ADD https://github.com/mdn/$HTML/archive/refs/heads/gh-pages.zip  ./code.zip
 RUN  unzip code.zip && mv $HTML-gh-pages/* . && echo $HTML > ./env.html
RUN useradd $user && chown $user: $user /var/www/html -R
USER $user
 RUN rm -rf code.zip  $HTML-gh-pages/
 USER root
 CMD apachectl -DFOREGROUND


 vres to lathos apo panw kai giati den ftiaxnetai to image?

so lets save this docker file and lets see how it works, but here we are goinf to add something new to the build command
something which is like --built-arg
if you are not sure go to google.com and look for it ____built args in docker file_____
so we use that build-arg and then we pass to it the argumemnt that we created i.e. user=MIke

so basically whats going to happen is that in our docker file  we will be creating a user that is not going to be application but instead its gona be MIke

----------------------------------------------------------------------------------------------------------------------------------------
C:\Users\michael.kourbelis\Desktop\real stuff\reals tuffv1 > docker build  -t  iop8:v1 -f Dockerfile3 -q --build-arg=user=mike  .
flag provided but not defined: --build-arg
See 'docker build --help'.
C:\Users\michael.kourbelis\Desktop\real stuff\reals tuffv1 > docker build  -t i7:v8 -f Dockerfile3   USER=${mike} .

 docker build  -t  iop8:v1  --build-arg=user=mike  .
 docker run -d --name iop1 -p 9091:80 iop8:v1 



i . docker run -d --name i9 -p 9091:80  iop8:v1 (docker build  -q --build-arg user=mike .) cat /user   
3ddd96ae4bdcd27e0e30a00ab808ad2e5793536a14d737c5767f6a3b22bd0bfa
Error response from daemon: OCI runtime create failed: container_linux.go:380: starting container 
process caused: exec: "(docker": executable file not found in $PATH: unknown
ii. docker run   iop8:v1 $(docker build  -q --build-arg user=mike .) -d --name i9 -p 9091:80   
Error response from daemon: OCI runtime create failed: container_linux.go:380: starting container 
process caused: exec: "$(docker": executable file not found in $PATH: unknown
iii. docker run -d --name i9 -p 9091:80  iop8:v1 (docker build -t i7:v8 -f Dockerfile3  -q --build-arg user=mike .) cat /user   
3ddd96ae4bdcd27e0e30a00ab808ad2e5793536a14d737c5767f6a3b22bd0bfa
Error response from daemon: OCI runtime create failed: container_linux.go:380: starting container 
process caused: exec: "(docker": executable file not found in $PATH: unknown
iv. docker run -d --name i9 -p 8080:80  iop8:v1 (docker build -q --build-arg user=mike .) 

docker run -it $(docker build -q .)

to thema einao oti den mporoume me tipota na xrhsimopoihsoume to --build-arg    overide th timh user sto dockerfile.....    

so to continue with the video lets hit enter and see what goes on the video
first you see that we actually add a new layer on top of everything so that means that the image is going to rebuild completely because remember that we are modifying our 
parent and that means that all of the subsequent layers are going to be modified as well 

what we are going to do to test it is that we are going to turn this image into a container 
we are going to run a container using the image above 
we are going to exec inside the container and we are going to see if the user mike was created 

because remember that in the dockerfile we are passing an argument______ ARG user=application
and here 
 
RUN useradd $user && chown $user:$user /var/www/html -R
           ------
we are using the value

and in this case we pass as abuild arg the user mike and thus we can use it 

so lets create our container 


docker run -d --name i9 -p 9091:80  apachecode:v78 

and through the docker ps we make sure it is running 
now lets go inside th container 

docker exec -ti nameofcontainer and lets take a look at the files 
through "ll"
so if you see one user called mike was created by the dockerfile following the instruction --build-arg user=mike  and the value was taken from here 
and went to the $user int RUN instruction 

so now if you want to test it inside the container become the "su mike" and you can see that you can be the superuser mike 
but if you try to become the application user you wouldn't be able to become that user because that user doesn't exist 
remember that we built a completely new image in which the user is mike and not application
so you can pass as many arguments as you want in a dockerfile 



when the layers are modified therefore the image need to be modified also because when we are modifying the parent layer it means that all of 
the subsequent layers are going to be modifier due to this change 



C:\Users\michael.kourbelis\Desktop\real stuff\reals tuffv1 > 
docker build  -t ap:v1 -f Dockerfile3  .
C:\Users\michael.kourbelis\Desktop\real stuff\realstuffv1 >
docker run  $(docker build -q --build-arg user=mike .)
docker run 
C:\Users\michael.kourbelis\Desktop\real stuff\realstuffv1 > docker build  -t apachecode:v78 -f Dockerfile3 .


C:\Users\michael.kourbelis\Desktop\real stuff\reals tuffv1 > docker build  -t apachecode:v78 -f Dockerfile3  .
C:\Users\michael.kourbelis\Desktop\real stuff\realstuffv1 > docker run -d --name i9 -p 9091:80  apachecode:v78  
docker run -d --name i9 -p 9091:80 iop1:v78 (docker build -t iop1:v78 -f Dockerfile3 -q --build-arg environment=production .) cat /value_of_environment 
docker run (docker build -t iop1:v78 -f Dockerfile3 -q --build-arg environment=production .) -d --name i9 -p 9091:80 iop1:v78 
docker run $(docker build -q --build-arg environment=production .) cat /value_of_environment 


after a lot of tries we fail we see it again later 


xxxi.what is cmd?
------------------
hello and welcome back in this video we are gonna talk about cmd instruction
probably you already know that the cmd instruction allows the container to be alive 
the commant you put here :CMD -->"apachectl -DFOREGROUND"
is the command that will be executed once you create a container based on this image 
so now lets go deeper and lets see how exaclty it works in a container 
so lets go and create a new image which we are going to modify this existing image i.e. our Dockerfile3 
we are going to leave this Dockerfile3 or image without CMD 
and there3fore wenever we create a container its not going to work....the container will exit 
so lets save it and lets build  this image 

remember thatwe now need to pass all of these parameters and we are going to tag the version 10 
and great now in this image we dont have cmd 
so yes we already have an image which is the apache with version 10 and this image doesn't have cmd 
so now what happens if i want to create a container using this version this image which has no cmd 
so lets do docker ps 
and you see that the container is not alive 
and if you do docker ps -a which stands for all the containers exited and running you see that 
our container is exited 
why it exited ?
well because it didn't have cmd, well indee it has a cmd but this is the centos  cmd  which doesn't keep alive the container 
so one tricky thing that you need to know is that to keep alive a container you need a process running  of course 
and that procees should run in full grown (foreground) mode
as long as the process is running in the foreground the container will be alive 
if the process dies for some reason and it doesn't execute in the foreground the container exits immediately  





C:\Users\michael.kourbelis\Desktop\real stuff\realstuffv1 > docker build  -t iop1:v10 -f Dockerfile3 .

C:\Users\michael.kourbelis\Desktop\real stuff\realstuffv1 > docker run -d --name iop9 -p 9091:80  iop1:v10

C:\Users\michael.kourbelis\Desktop\real stuff\realstuffv1 > docker ps --all

so lets see how is this thing 

CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                      PORTS               NAMES
895555cc6012        iop1:v10            "/bin/bash"         50 seconds ago      Exited (0) 50 seconds ago                       iop9


so you know now that the container has the cmd as "bin/bas" because its been taken from the centos image which we are using in the from instruction
now what we are going to do is to remove this container   

C:\Users\michael.kourbelis\Desktop\real stuff\realstuffv1 > docker rm -f 895555cc6012

and we will do a trick to keep alive the container using bas and we are going to run this again but wit ___-ti___
which is a terminal and interactive  and at the end we are going to pass bash 
well lets keep bash for a surprise later 
basically what you are telling in centos image is to get this tag and give you  an interactive terminal because remember that currently the cmd 
is currently bash (is being bashed) 
so if you pass this (-ti) yoy basically keep the container alive so we can test it 
so lets check this out 

C:\Users\michael.kourbelis\Desktop\real stuff\realstuffv1 > docker run -d -ti --name iop9 -p 9091:80  iop1:v10
e2bff33effdc5843dcf7b7478f69b32727ac27a77d80abf2d3e97ba1255486b8

C:\Users\michael.kourbelis\Desktop\real stuff\realstuffv1 > docker ps --all
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS                  NAMES
e2bff33effdc        iop1:v10            "/bin/bash"         27 seconds ago      Up 27 seconds       0.0.0.0:9091->80/tcp   iop9


but this is not a good practice it should be done only for testing proposes because you are actually starting a budget process 
and a bash process probably is not the process that you want to monitor in your application 

probably you want to start a database service 
                           a web server and you want that whenever the service dies the container to exit because otherwise you are not going to know 
                           if your process is being executed correctly, 
so well now that we know that if we pass this (-ti).....a container withour cmd will be bash and will be alive 
we can go inside of this container and we can start testing how this thing about for our work works....

so lets get inside of this container 

C:\Users\michael.kourbelis\Desktop\real stuff\realstuffv1 > docker exec -ti iop9 bash

and now that we are inside the container remember that we expose the port 9091, so now if you go to google.com
or my bad i mean 
http://localhost:9091/

you want see anything because there is no service running, we create it we indeed create a container using the image 
and you know that the image contains everything that you need 
so this goes that the container already contains the code and everything 
but 
you if you see the container is not executing any valid command to start the apache service, so there comes the question  and it is 
how the we start the  apache service if we dont have cmd?
you can do  systemctl   start httpd because you dont  have dmd in a container 
instead you should be using the package and pass some parameters to keep it alive 
so if you dont know how to do this you just go to ggogle.com and you type ____apache start in foreground centos____

so lets use this line /usr/sbin/httpd -DFOREGROUND

so lets copy and paste it inside the container (which is atiny operating system) in cmd and through what is happening below we
are going to execute the command
so i know the command is exactly like this but the utilities are apachectl so apachectl and then we pass this 
so basically we have two options foreground and background 
with foreground we keep processes....you know on foreground of course thats why its called foreground 
buut the thing is that you cannot.....that if you put a process in foreground mode you cannot use this terminal becasue the output from __/usr/sbin/httpd -DFOREGROUND___

is this 

AH00558: httpd: Could not reliably determine the server's fully qualified domain name, using 172.17.0.2. 
Set the 'ServerName' directive globally to suppress this message

and it is obvious that this is a stack i cannot do anything i press enter and it cursor walks like it is in boulevard avenue
the only thing that i see are the logs that are shown by this command (apachectl -DFOREGROUND) which is being executed  
so this command actually starts the httpd process inside of the container 
so if you see i am running a container which has no cmd or well it has a cmd but its been bash and that doesn't really do to much 
but the thing is that as long as we dont have any cmd we are just testing this inside of the container 
we actually start the process inside of the container is foreground mode ......i started the service 
so if i go to http://localhost:9091/  and refresh i will see my we server up and running 
of course there is something in foreground mode which is running  

so this is the scenario that you always need to look for 
you always need to make sure that the command that you use for cmd its going to run on foreground mode 
because as i told you as long as the process is running the containers are running and the container knows that the process is running because 
its in foreground mode   if i exit the process by hitting ctrl+c and refresh the site on google the service will stop and nothing is displayed  
as the service was killed 
and that exaclty happens with that container 
if the process which is in foreground mode exits then the container itself exits 
so if you try something like apachectl -DBACKGROUND 
that is going to work and this is going to create a process inside of this container as you see here  

now refresh the browser and you see that it works perfectly 


but now through "ps aux" you see that the procees is not running in foreground mode and that means that if you had that as cmd 
then your container is going to be dead because the container thinks that the process exited because its in the backround 
and not in the foreground mode........  


USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root         1  0.0  0.1  11844  2844 pts/0    Ss+  11:01   0:00 /bin/bash
root        16  0.0  0.1  11844  2964 pts/1    Ss   11:11   0:00 bash
root        50  0.0  0.2 224096  6044 ?        Ss   11:54   0:00 /usr/sbin/httpd -DBACKGROUND
apache      51  0.0  0.3 224232  6128 ?        S    11:54   0:00 /usr/sbin/httpd -DBACKGROUND
apache      52  0.0  0.3 224096  6128 ?        S    11:54   0:00 /usr/sbin/httpd -DBACKGROUND
apache      53  0.0  0.3 224096  6128 ?        S    11:54   0:00 /usr/sbin/httpd -DBACKGROUND
apache      54  0.0  0.3 224096  6128 ?        S    11:54   0:00 /usr/sbin/httpd -DBACKGROUND
apache      55  0.0  0.3 224096  6128 ?        S    11:54   0:00 /usr/sbin/httpd -DBACKGROUND
apache      56  0.0  0.3 224096  6128 ?        S    11:54   0:00 /usr/sbin/httpd -DBACKGROUND
root        57  0.0  0.1  51748  3508 pts/1    R+   11:57   0:00 ps aux
[root@e2bff33effdc html]#


now we can do it in two ways exited the container in first place the remove this container in the second 
and we are going to build a new image 

so lets go to the docker file  and modify it and then remember that foreground (CMD apachectl -DFOREGROUND)

is a good one that we need to use which keeps the process in the foreground but if we just type DBACKGROUND (CMD apachectl -DBACKGROUND)
all of these in the dockerfile of course......
and then we just built this image with the version 10 
lets build this image with the 

C:\Users\michael.kourbelis\Desktop\real stuff\realstuffv1 > docker build  -t iop1:v10 -f Dockerfile3 .

and lets create the container using that image....you could think that the container is going to live because you are
providing the  cmd 
but thats not the case because as i told you the command gets executed, the process starts on the background and then docker thinks 
that the process exited and therefore the container is going exit   

C:\Users\michael.kourbelis\Desktop\real stuff\realstuffv1 > docker run -d --name iop9 -p 9091:80 iop1:v10

C:\Users\michael.kourbelis\Desktop\real stuff\realstuffv1 > docker ps -a
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                     PORTS               NAMES
342e30dd187d        iop1:v10            "/bin/sh -c 'apachect"   4 seconds ago       Exited (0) 4 seconds ago                       iop9

but if you see at the logs then it actually start the process 
but as the process was not in the foreground the container exited 
so now lets remove this container 

and lets put the cmd in foreground mode for you to be able to see it  lets go to the dockerfile and write DFOREGROUND in the place of  DBACKGROUND
which keep the container in foreground mode 

command docker ps --no-trunc allows us to see the entire output and you can see that the process  is executed in the foreground mode and this is in foreground 
so this guy is alive 

so we see how related are the processes in the container because if as told you if the process apachectl -DFOREGROUND exits then the container is going to 
exits and as long as the process is alive the  container is going to be alive 
so to show you this 
what i am going to do is that i am going to go inside of the container and i will the process manually 


C:\Users\michael.kourbelis\Desktop\real stuff\realstuffv1 > docker exec -ti iop9 bash
[root@43f40a0d12d6 html]# ps aux
USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root         1  0.0  0.1  11704  2592 ?        Ss   13:35   0:00 /bin/sh /usr/sbin/apachectl -DFOREGROUND
root         9  0.0  0.3 224096  7656 ?        S    13:35   0:00 /usr/sbin/httpd -DFOREGROUND
apache      10  0.0  0.3 224096  6136 ?        S    13:35   0:00 /usr/sbin/httpd -DFOREGROUND
apache      11  0.0  0.3 224096  6136 ?        S    13:35   0:00 /usr/sbin/httpd -DFOREGROUND
apache      12  0.0  0.3 224096  6136 ?        S    13:35   0:00 /usr/sbin/httpd -DFOREGROUND
apache      13  0.0  0.3 224096  6136 ?        S    13:35   0:00 /usr/sbin/httpd -DFOREGROUND
apache      14  0.0  0.3 224096  6136 ?        S    13:35   0:00 /usr/sbin/httpd -DFOREGROUND
root        15  0.0  0.1  11844  2984 pts/0    Ss   13:36   0:00 bash
root        30  0.0  0.1  51748  3436 pts/0    R+   13:36   0:00 ps aux
[root@43f40a0d12d6 html]#



so remember we are inside of the container here docker exec -ti iop9 bash
the container is running this process apachectl....which keeps alive the container and the website 
but if we kill this process it doesn't matter if the process exits automatically or if something happens to the process and it exits 
then the container itself should exit 
so i want you to see that the container now is running but if i go inside of the container and then i just list the available processes 
and then i kill the process then what should happen is that the container is going to die because the only thing 
that keep it alive is the process  that runs in it so if i kill the process then the container will be on the clouds abouve
[root@43f40a0d12d6 html]# pkill -9 httpd
[root@43f40a0d12d6 html]#
C:\Users\michael.kourbelis\Desktop\real stuff\realstuffv1>

now if we go to the browser and hit refresh we have nothing as the container is no longer live and why the container 
is no longer live its because the process that started the container died and if the prcess dies then the container follows 
so through docker ps we dont see any running conytainers but if we do docker ps -a 
we see that the process exited 

cmd is the core of the conatiner cmd allows your container to be alive and as long the process you put in cmd ia alive then the conatine ris alive


xxxii.understand the output from the cmd
-----------------------------------------
hello in this video we are going to talk about cmd again as it is a very important instruction for docker container 
and it is the intstruction that keeps alive the container itself 

so now i just want to show you some cool things that you can do on the cmd instruction 
the first thing that you need to know is that let us firts create a container and an image 

C:\Users\michael.kourbelis\Desktop\real stuff\realstuffv1>docker rmi -f sha256:ddf5e
C:\Users\michael.kourbelis\Desktop\real stuff\realstuffv1>docker ps -a
C:\Users\michael.kourbelis\Desktop\real stuff\realstuffv1>docker rm -f  d14753c4c73f




C:\Users\michael.kourbelis\Desktop\real stuff\realstuffv1 > docker build  -t iop1:v10 -f Dockerfile3 .
C:\Users\michael.kourbelis\Desktop\real stuff\realstuffv1 > docker run -d --name iop2 -p 9091:80 iop1:v10



C:\Users\michael.kourbelis\Desktop\real stuff\realstuffv1 > docker logs -f iop2

C:\Users\michael.kourbelis\Desktop\real stuff\realstuffv1 > docker exec -ti iop9 bash


and now you see that the container is alive and i thing that i already thought one command called 
docker logs that allows you to see the output of the CMD instruction 

C:\Users\michael.kourbelis\Desktop\real stuff\realstuffv1>docker ps -a
C:\Users\michael.kourbelis\Desktop\real stuff\realstuffv1>docker ps -a
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                  NAMES
9a2cb961eac4        iop1:v10            "/bin/sh -c 'apachect"   3 minutes ago       Up 3 minutes        0.0.0.0:9091->80/tcp   iop2

C:\Users\michael.kourbelis\Desktop\real stuff\realstuffv1>docker logs 9a2cb961eac4
time="2022-02-25T13:11:40+02:00" level=error msg="Error parsing media type:  error: mime: no media type"
AH00558: httpd: Could not reliably determine the server's fully qualified domain name, using 172.17.0.2. Set the 'ServerName' directive globally to suppress this message

yes because we want the econtainer's name.......

C:\Users\michael.kourbelis\Desktop\real stuff\realstuffv1 > docker logs iop2
C:\Users\michael.kourbelis\Desktop\real stuff\realstuffv1>docker logs iop2
time="2022-02-25T13:12:19+02:00" level=error msg="Error parsing media type:  error: mime: no media type"
AH00558: httpd: Could not reliably determine the server's fully qualified domain name, using 172.17.0.2. 
Set the 'ServerName' directive globally to suppress this message



yes because we didn't provide th flag -f.....what if we provide it we took the same........
remember that whenever we started the apachectl -DFOREGROUND this was the output we where seen 

AH00558: httpd: Could not reliably determine the server's fully qualified domain name, using 172.17.0.2. 
Set the 'ServerName' directive globally to suppress this message
now that this process is started you can see that this ia actually in foreground mode 
so if you do this ____docker logs -f iop2____
you are actually seeing the execution of the process itself 
and if your process created any kind of logs you are going to see these logs aftre you hit this ____docker logs -f iop2_____
so my point is that whwnever you put on your cmd you are going to be able to see it using docker logs
so if the process that you start to create some kind of logs 
                                           some kind of request  
                                           some kind og log that you can see .......you can do it, you can taka a look at the logs by using the command the we have 
mention above, but remember that these will only show you the logs that are related to the CMD instruction 

but what do i mean by that?
lets just try something for you to understand 


lets create a new file which we call cmd.sh....i.e. we create a script a simple bash script with bam boom no i am kidding
 
 it starts with #!/bin/bash

so we open our whole folder from our visual code then we select our folder that we are gonna create our cmd.sh File
and we do it (yooooo)

so in our sh script we can do some things like 

#!/bin/bash
echo "starting httpd"  and then you can do 
apachectl -DFOREGROUND   ---->and then this should start the process  inside of the container 
and then you can say 
you can make even and the validations here e.g. 

if the last execution is equal to 0 then that means it was good 
if ["$?"=0]; then
echo "this went good"

then you can say echo "this went good"

and then you say else 
you can make another echo that says go on vacations as there was an error starting the services 
and finally yoi close the if statement with "fi"

complete example

#!/bin/bash
echo "starting httpd"  
apachectl -DFOREGROUND

if ["$?"=0]; then
echo "this went good"
else 
echo "go on vacations as there was an error starting the services"
fi


now you are going to see that  this will be printed in the screen starting httpd 
and then we will try to start the proces (apachectl -DFOREGROUND)
and do a simple validation with the if statements 
so what we are going to do now is that we will be editing our Dockerfile3 and we will be using the COPY
instruction somewhere 
more specifically below USER root

COPY cmd.sh /cmd.sh.......here we say please docker copy  the cmd.sh file that i just created copy to the root of the container (/cmd.sh)

RUN chmod +x /cmd.sh......then  if you want you can create a run instruction and give executable permissions to this script (cmd.sh)
                          because normally in linux you need to give executable permissions in order to execute a script  

cmd /cmd.sh..............and finally you can erase the "apachectl -DFOREGROUND" from cmd instruction and replace it with /cmd.sh

rememeber  
we are copy the file that we just created outside of the container 
we created a simple bash script which prints out  a starting httpd...then tries to start the service 
and
if something goes wrong then it will print the error or it will print an error message 
we give executable permissions to this guy and then in the end we execute this----> cmd /cmd.sh 



now with a more close look to our cmd.sh we will notice that our validation in the if statement will never come 
because this alwasy be in the foreground mode   and thus after the 
apachectl -DFOREGROUND
 
the validation will never goes to the validation of.........if
so we keep cmd.sh 

as simple as the one below 

#!/bin/bash

echo "starting httpd"  
apachectl -DFOREGROUND

and we are doing exactly the same thing we just copy the file....and then we just define this file 
CMD /cmd.sh

remember that if you take a look at the file (cmd.sh) the command that will keep your service alive is the 
apachectl -DFOREGROUND
so there is no problem here 


Dockerfile3
------------

 FROM centos:7
 ARG user=application
 RUN  yum -y install httpd unzip
 LABEL maintainer=mike
 LABEL vendor=companyb
 LABEL random=yay
 ENV HTML beginner-html-site-styled
 WORKDIR /var/www/html/
 ADD https://github.com/mdn/$HTML/archive/refs/heads/gh-pages.zip  ./code.zip
 RUN  unzip code.zip && mv $HTML-gh-pages/* . && echo $HTML > ./env.html
 RUN useradd $user && chown $user:$user /var/www/html -R
 USER $user
 RUN rm -rf code.zip  $HTML-gh-pages/
 USER root
 COPY cmd.sh /cmd.sh
 RUN chmod +x /cmd.sh
 cmd /cmd.sh


so lets build the image 

C:\Users\michael.kourbelis\Desktop\real stuff\realstuffv1 > docker ps -a
C:\Users\michael.kourbelis\Desktop\real stuff\realstuffv1 > docker rm -f 9a2cb961eac4
C:\Users\michael.kourbelis\Desktop\real stuff\realstuffv1 > docker images
C:\Users\michael.kourbelis\Desktop\real stuff\realstuffv1 > docker rmi -f sha256:7b749  sha256:eeb6e



C:\Users\michael.kourbelis\Desktop\real stuff\realstuffv1 > docker build  -t iop1:v10 -f Dockerfile3 .
C:\Users\michael.kourbelis\Desktop\real stuff\realstuffv1 > docker run -d --name iop2 -p 9091:80 iop1:v10

everything is ok, we hit "docker ps" and we see our container up and running 

C:\Users\michael.kourbelis\Desktop\real stuff\realstuffv1 > docker ps 
CONTAINER ID        IMAGE               COMMAND                CREATED              STATUS              PORTS                  NAMES
7fc127606384        iop1:v10            "/bin/sh -c /cmd.sh"   About a minute ago   Up About a minute   0.0.0.0:9091->80/tcp   iop2

C:\Users\michael.kourbelis\Desktop\real stuff\realstuffv1>

and now if we type "docker logs" to see the output of the cmd and we paste the name of the container the that's cool
you can see 
time="2022-02-25T15:35:54+02:00" level=error msg="Error parsing media type:  error: mime: no media type"

starting httpd...----->this is what we wrote in cmd.sh


the below output comes from the execution of the apachectl -DFOREGROUND

AH00558: httpd: Could not reliably determine the server's fully qualified domain name, using 172.17.0.2. 
Set the 'ServerName' directive globally to suppress this message


in a nutshell we echo starting httpd
and then we are start the process  (apachectl -DFOREGROUND) with the output to be  

AH00558: httpd: Could not reliably determine the server's fully qualified domain name, using 172.17.0.2. 
Set the 'ServerName' directive globally to suppress this message

so in this video  we learn somehow CMD works as its pretty important  that the process that you put is always in foreground mode 



C:\Users\michael.kourbelis\Desktop\real stuff\realstuffv1 > docker logs -f iop2

C:\Users\michael.kourbelis\Desktop\real stuff\realstuffv1 > docker exec -ti iop9 bash

---------------------------------5.Docker images Learn about Dockerfiles------------------------------end

start----------------------------6.Docker images - build advanced images---------------------------------

xxxiii.Be carefull with the context
------------------------------------
here we are going to learn sometihing which we call "the context" in docker 
you might have noticed that whenever you try to be in a docker image you might have seen a word on top of the build 
that says "context"
and probably you might have wondering what is that thing 
and thats what we are going to learn 
so lets try to rebuild the image that we build in the previous lesson which is this one 


C:\Users\michael.kourbelis\Desktop\real stuff\realstuffv1 > docker build  -t iop1:v10 -f Dockerfile3 .

and this one provides the steps of its creation so above all of the steps there is a line that 
says:

sending build context to docker daemon 5.733MB

so what is this?
lets go to create the container if this image and get inside of it to see it thoroughly.....

C:\Users\michael.kourbelis\Desktop\real stuff\realstuffv1 > docker run -d --name iop2 -p 9091:80 iop1:v10
C:\Users\michael.kourbelis\Desktop\real stuff\realstuffv1 > docker exec -ti iop2 bash
[root@d805fed084ba html]# ll
total 32
-rw-r--r-- 1 application application  689 Apr  4  2019 CODE_OF_CONDUCT.md
-rw-r--r-- 1 application application 6555 Apr  4  2019 LICENSE
-rw-r--r-- 1 application application  469 Apr  4  2019 README.md
-rw-r--r-- 1 application application   26 Feb 25 14:19 env.html
drwxr-xr-x 1 application application 4096 Apr  4  2019 images
-rw-r--r-- 1 application application 1082 Apr  4  2019 index.html
drwxr-xr-x 1 application application 4096 Apr  4  2019 styles
[root@d805fed084ba html]#

and now we take a look at the size of those files through (du -sch *) 
we can see that this size is actually this "92K     total"
so its omething similar to whats been sent 

[root@d805fed084ba html]# du -sch *
4.0K    CODE_OF_CONDUCT.md
8.0K    LICENSE
4.0K    README.md
4.0K    env.html
60K     images
4.0K    index.html
8.0K    styles
92K     total
[root@d805fed084ba html]#

so when you try to build an image you see that you actually pass this . in the end of the build command 
which basically means the current directory or the context and the context basically means the current directory 
where the docker file is located and all of that subdirectories that you can find in that parent directory 
so basicall this is what that dot means 

so now what happens if we try to build this image outside of this context ?
lets try to go back ( in the cmd ) we are go one level back here "cd .."

C:\Users\michael.kourbelis\Desktop\real stuff\realstuffv1 > docker exec -ti iop2 bash
[root@d805fed084ba html]# ll
total 32
-rw-r--r-- 1 application application  689 Apr  4  2019 CODE_OF_CONDUCT.md
-rw-r--r-- 1 application application 6555 Apr  4  2019 LICENSE
-rw-r--r-- 1 application application  469 Apr  4  2019 README.md
-rw-r--r-- 1 application application   26 Feb 25 14:19 env.html
drwxr-xr-x 1 application application 4096 Apr  4  2019 images
-rw-r--r-- 1 application application 1082 Apr  4  2019 index.html
drwxr-xr-x 1 application application 4096 Apr  4  2019 styles


[root@d805fed084ba html]# cd..
  
[root@d805fed084ba www]# ll
total 8
drwxr-xr-x 2 root        root        4096 Jan 25 14:09 cgi-bin
drwxr-xr-x 1 application application 4096 Feb 25 14:19 html
[root@d805fed084ba www]#

you can see that we have this cgi-bin  

docker build  -t iop1:v10 -f Dockerfile3 .


no i think that it is time to move to linux..........

i was very tired on friday 25/2/2022 tosday its monday 28/2/2022...........lets start cousre 26 again

so in 26 we are going to learn something that we call 
the context in docker 
you might have noticed that whenever you try to build a docker image  you see a word on top of the build that says.....context
and you may be probably wondering what is that thing and that's we are gonna learn 
so lets try to rebuild the image that we built in the previous lesson which is the following...

C:\Users\michael.kourbelis\Desktop\real stuff\realstuffv1 > docker build  -t image_a:v10 -f Dockerfile3 .

"sending build context to docker daemon 5.755MB"

is displayed at the begining of the creation of every image as our image goes up instead of down.....
so the phrase above is on top of every image and we are wondering what is that?
you see in this current directory 

C:\Users\michael.kourbelis\Desktop\real stuff\realstuffv1 > docker run -d --name image_b -p 9091:80 image_a:v10


now in the case that we enter the container and list the files with ...ll...
C:\Users\michael.kourbelis\Desktop\real stuff\realstuffv1 > docker exec -ti image_b bash

we are gonna see that we have a bunch of files in this current directory
[root@d805fed084ba html]# ll
total 32
-rw-r--r-- 1 application application  689 Apr  4  2019 CODE_OF_CONDUCT.md
-rw-r--r-- 1 application application 6555 Apr  4  2019 LICENSE
-rw-r--r-- 1 application application  469 Apr  4  2019 README.md
-rw-r--r-- 1 application application   26 Feb 28 08:17 env.html
drwxr-xr-x 1 application application 4096 Apr  4  2019 images
-rw-r--r-- 1 application application 1082 Apr  4  2019 index.html
drwxr-xr-x 1 application application 4096 Apr  4  2019 styles
now in the case we take a look at the size of those files we can see that this size is actually this (92K     total)
so its something similar to whats been sent 
[root@f694cbbd276a html]# du -shc *

4.0K    CODE_OF_CONDUCT.md
8.0K    LICENSE
4.0K    README.md
4.0K    env.html
60K     images
4.0K    index.html
8.0K    styles
92K     total
[root@f694cbbd276a html]#

so when you try to build an image you see that you actually pass this "." in 
docker build  -t image_a:v10 -f Dockerfile3 .
which means 
current dierctory or the context
and the context basically means the current directory where the dockerfile is located and all of the 
subdirectories that you can find in the parent directory   
so basically that is what that dot at the end of the build command means
so what happens that 
if we try to build this image outside of this context....so lets try to go back, we go one level back via the "cd .."

----------------------------------------------------------------------------------------------------------------
and we must find a folder that is the parent folder that contains all the files that we have create Dockerfile, Dockerfile2, Dockerfile3 cmd.sh
but i dont see a thing of that
as we are in the working directory of apache which is ..../var/www/html/.... and i dont know how to go to this folder

des gia mount folder apo ton container sto current leitourgiko 
----------------------------------------------------------------------------------------------------------------

in the video tells that the parent directory is the docker-images that contains  all of this files and this is because o mapas sto video
exei ta dockerfiles tou kai genika ola ta arxeia sto centos leitourgiko tou 
me ip172.31.87.182

kai egw twra prpei na dw gia mount folder

lets try some stuffs here, our curent run command doesn't provode any access to our local file 

C:\Users\michael.kourbelis\Desktop\real stuff\realstuffv1 > docker run -d --name image_b -p 9091:80 image_a:v10

so lets modify it 

docker run -v C:/Users/michael.kourbelis/Desktop/real stuff/realstuffv1:/var/www/html -d --name image_c -p 9091:80 image_a:v10
Error response from daemon: mount denied:
the source path "/Users/michael.kourbelis/Desktop/real"
doesn't contains colon

C:\Users\michael.kourbelis\Desktop\real stuff\realstuffv1>


docker run -v /Users/michael.kourbelis/Desktop/real stuff/realstuffv1:/var/www/html -d --name image_c -p 9091:80 image_a:v10



Volume mounting
What is more common and arguably more useful is to mount volumes to containers with the -v flag. 
This allows for direct access to the host file system inside of the container and for container processes 
to write directly to the host file system.

Docker Volumes on Windows - Introducing the `G` Drive


Storing State in Docker Volumes
Using volumes is how you store data in a Dockerized application, so it survives beyond the life of a container. You run your database container 
with a volume for the data files. When you replace your container from a new image (to deploy a Windows update or a schema change), you use the same 
volume, and the new container has all the data from the original container.

The SQL Server Docker lab on GitHub walks you through an example of this.

You define volumes in the Dockerfile, specifying the destination path where the volume is presented to the container. Here's a simple example 
which stores IIS logs in a volume:

#escape=`
FROM microsoft/iis  
VOLUME C:\inetpub\logs  
You can build an image from that Dockerfile and run it in a container. When you run docker container inspect you will see that there is a mount 
point listed for the volume:

"Mounts": [
            {
                "Type": "volume",
                "Name": "cfc1ab55dbf6e925a1705673ff9f202d0ee2157dcd199c02111813b05ddddf22",
                "Source": "C:\\ProgramData\\docker\\volumes\\cfc1ab55dbf6e925a1705673ff9f202d0ee2157dcd199c02111813b05ddddf22\\_data",
                "Destination": "C:\\inetpub\\logs",
                "Driver": "local",
                "Mode": "",
                "RW": true,
                "Propagation": ""
            }
        ]
The source location of the mount shows the physical path on the Docker host where the files for the volume are written - in C:\ProgramData\docker\volumes. 
When IIS writes logs from the container in C:\Inetpub\logs, they're actually written to the directory in C:\ProgramData\docker\volumes on the host.

The destination path for a volume must be a new folder, or an existing empty folder. Docker on Windows is different from linux in that respect, 
you can't use a destination folder which already contains data from the image, and you can't use a single file as a destination.

Docker surfaces the destination directory for the volume as a symbolic link (symlink) inside the container, and that's where the trouble begins.



C:\Users\michael.kourbelis\Desktop\real stuff\realstuffv1 > docker build  -t image_a:v10 -f Dockerfile3 .


docker run -it --name image_b -p 9091:80 image_a:v10 --mount src="C:\Users\michael.kourbelis\Desktop\real stuff\realstuffv1",dst=c:\var\www\html,type=bind centos:7

docker run -it --name image_b --volume src="C:\Users\michael.kourbelis\Desktop\real stuff\realstuffv1",dst=c:\var\www\html,type=bind centos:7






C:\Users\michael.kourbelis\Desktop\real stuff\realstuffv1 > docker run -it --volume pwd:/var/www/html centos:7 bash    -d --name image_b -p 9091:80 image_a:v10


C:\Users\michael.kourbelis\Desktop\real stuff\realstuffv1 > docker exec -ti image_b bash

docker run -v C:/Users/michael.kourbelis/Desktop/real stuff/realstuffv1:/var/www/html -d --name image_c -p 9091:80 image_a:v10

docker run -it --volume //C/Users/michael.kourbelis/Desktop/real/realstuffv1:/var/www/html

docker run -it --volume //C/Users/michael.kourbelis/Desktop/real/realstuffv1:/var/www/html centos:7


docker run -ti --volume  //C/Users/michael.kourbelis/Desktop/real/realstuffv1:/var/www/html  /bin/bash


so according to video is what happens if we try to run the build command insteaf of
C:\Users\michael.kourbelis\Desktop\real stuff\realstuffv1 > docker build  -t image_a:v10 -f Dockerfile3 .
from 
C:\Users\michael.kourbelis\Desktop\real stuff > docker build  -t image_a:v10 -f Dockerfile3 .
so 
the first thing that we get is an error saying hey i cannot find Dockerfile3 in this directory 

ok lets pass the correct path for these dockerfile which is the "docker-images" as in this folder is where we have the Dockerfile3 
C:\Users\michael.kourbelis\Desktop\real stuff > docker build  -t image_a:v10 -f docker-images/Dockerfile3 .

and then 
you see that the image is getting built but if you look more close  at the last layer well its not the last it the step 16 out of 18 
actually failed because it tried to copy a file which is "called cmd.sh" the file that we create that starts the service   "apachectl -DFOREGROUND"
and is in docker-images folder and we dont have that file un the contect above
so that the importance of context in docker 

if yoy want this image to be succesfully build the you cannot use this contex "." because then you dont have the necessary files to build you image 
so where are those files 
yeeees they are in the docker-images folder, so yes you can do this....you can call the Dockerfile3 but to know that this file copies one file which 
is suspected to be in the current directory which is called cmd.sh
and if we put the dot in the docker build it will obviously going to fail as because the file is not here 
lets take a look at the Dockerfile3 and see that it tries to copy cmd.sh to the current directory via  " COPY cmd.sh /cmd.sh" 

so thats the importance of the context, to make this succesful you may pass the docker-images as the context 

C:\Users\michael.kourbelis\Desktop\real stuff > docker build  -t image_a:v10 -f docker-images/Dockerfile3 docker-images/

so in this way that we replace . with docker-images/ is like we are saying 
hey docker please look the docker please look the dockerfile3 in docker-images 
and
the context or the folder that contains all of the dependencies that i am defining in this dockerfile 
all the necessary files that i am going to copy most of the times is going to be only the files that you want to copy 
and generally all the files that i want to copy are inside docer-images 

so now if we hit enter we have accomplish succesfully our task and thats because you are providing a correct path for the docker file and thats 
because you are actually passing the correct context 
were all the needed fuzz that your image needs are located 
now you know what is context in docker is and how to use it properly 


xxiv.Dockerignore-start ignoring the things that you don't need
----------------------------------------------------------------

in this video we are going to talk about something called dockerignore 
and it is something important when we talk about we talking about context 
so lets browse to our docker-images folder  and if we try to build our image using our wrong context "docker-images/" and wrong path docker-images/Dockerfile3
the build up is going to complain  as the docker-images folder is not found here and of course have a lot of wromng stuff here:

C:\Users\michael.kourbelis\Desktop\real stuff > docker build  -t image_a:v10 -f docker-images/Dockerfile3 docker-images/

so lets put the proper arguments in these folder to be able to build this image 


C:\Users\michael.kourbelis\Desktop\real stuff > docker build  -t image_a:v10 -f Dockerfile3 .

so in if you see here the context is some megabytes lets say 5 megabytes 
and this becasue the total size of the files in the current directory is  five megabytes 
but now wgat happens if we go on level back and try to build this image again by passing docker-images as the context 

C:\Users\michael.kourbelis\Desktop\real stuff > docker build  -t image_a:v10 -f Dockerfile3 .

then the size will be again 5 megabytes because we are providing this folder docker-images as the context 
but what happens if we provide a different context   ?
of course the image is gonna fail but whats gonna happen with the size of the files if you see its actually growing a lot 
and of course it fails as it doesn't find the cmd file that we ar lookin for 
but the master wants us to see that now as we are providing the current directory as context for Docker now we dont have 5 megabytes anymore we have 79.71MB
but why?
well if you remember . means the context and the context in this current directory is 79 megabytes and how do we know that 
well its because i have some folder for this purpose 
and if we take a look at the total size (du -shc *) of these folders you will see that its actually getting around it but it looks like 79 mega bytes  
thats why we are having these huge context in here its because we are providing this . folder as the context 
and if you see here we have a bunch of files here that we dont use so below what it follows is to know what to ignore in our context...
so lets say for some reason for some weird reason you need or you must build your image in  this directory and you  must provide this directory as your contacts 
for some reason....for some reason you cannot delete the folder linuxfacilito.online
but of course you need this folder (docker-images) because here is where you have all your images 
so you know that this folder is five megabytes in size and the files below it 
-linuxfacilito.online
-templates
 are a little bit heavier, so how we ignore these 2 files........well that is where the docker ignore comes in
 so somewhere there is a file called docker ignore which is actually a hidden file exactly as a gitignore file that allows you to ignore folders or files in your context 
 so now lets say that we want to create a new docker ignore file and the dockerignore files should live in the root of your context 
 in this case the root of our context  is the following
 
 -docker-images
 -linuxfacilito.online
 -templates

so thats why we are creating our files here, if we create a file we save it and we live it empty  



C:\Users\michael.kourbelis\Desktop\real stuff\realstuffv1 > docker run -it -d --name image_b -p 9091:80 image_a:v10


C:\Users\michael.kourbelis\Desktop\real stuff\realstuffv1 > docker exec -ti image_b bash
[root@85091d7f1b22 html]# ll -a
total 56swap file by the name ".dockerignore.swp"
drwxr-xr-x 1 application application  4096 Feb 28 13:26 .2
drwxr-xr-x 1 root        root         4096 Feb 28 12:34 ..
-rw------- 1 root        root        12288 Feb 28 13:22 .dockerignore.swp
-rw-r--r-- 1 application application   689 Apr  4  2019 CODE_OF_CONDUCT.md
-rw-r--r-- 1 application application  6555 Apr  4  2019 LICENSE
-rw-r--r-- 1 application application   469 Apr  4  2019 README.md
-rw-r--r-- 1 application application    26 Feb 28 12:34 env.html
drwxr-xr-x 1 application application  4096 Apr  4  2019 imagesthe case,
-rw-r--r-- 1 application application  1082 Apr  4  2019 index.htmlame
drwxr-xr-x 1 application application  4096 Apr  4  2019 styles


so now i have the gitignore in the same level  with styles and README.md 
so now the question is how do i ignore these 2 files using docker ignore well and the answer is easy 
whenever you build an image then its going to look for a docker ignore file in the context that you provide 
so as we providing the current directory as context ---> .
the docker will look for a hidden file called docker ignore in this growing context and docker will ignore all of the files or directorie inside of this file
so lets say that we want as told you we want to ignore 
styles and README.md 

lets take a look at the sizer of this folder 
[root@85091d7f1b22 html]# du -sh README.md 
4.0K    README.md
[root@85091d7f1b22 html]# du -sh styles
8.0K    styles
[root@85091d7f1b22 html]#       

we cannot delete them but we can ignore them becauase we dont want it in the context as is taking a lot 
and if we have a huge context then it may impact our builds because you know we are having a bunch of files that we dont need but docker things that we need it 
so he use it when building the image 
so now let us perform an ignore of these two files just to see the process 

so now lets try to execute the command that we try to execute before and lets see if docker is ignore what it tolds it to ignore as you see now the context is 6 megabytes 
and its not 79 nas before 
now if we go to dockerignore and comment out the  README.md we see that the size of the context grows 

please jhave this as a rule try your context to be as light as possible because otherwise we will have perfoming issues when we build our images 
so if you need to delete a file go and do it and if you cannot delete it ignopre it

xxxv.lets talk about best practices when building images
---------------------------------------------------------

here we are going to talk about best practices when we built docker images,
the first thing that you have in mind is that your container should have only one service running 
of course sometimes you may need to run two processes in one container and thats ok
but as long as its possible for you please try to build only one service per container 
the second thing is that your contacts should be small and now you should know what i mean when i say that the context should be small
because we learned that in the previous lesson that....and that means that you souldn't include files in your contacts that you are not going to use 
or if you have files in your context that should be ignored then just use the docker ignore file to ignore them 
the third thing is that you should avoid installing uneccessary packages....

lets say that you are building an apache web server 
(what do you mean by saying night observer?) only for serving a static content but when you are creating the docker file you say it would be 
nice you have a text editor in this container 
no.....why are you going to do that ?
your container shouldn't contain packages that you are not going to use.......please try to install only the things that you need as in the case that you install
things that you are not going to use the image gets bigger and bigger and thats not the idea 
and the final thing is that you should use less layers in your images,
what i mean by saying less layers ?

lets go to our terminal and lets take a look at that 
lets browse to our docker images directory (cd docker-images)
and lets create a dockerfile....Dockerfile4 and then we just start "FROM nginx:alpine"
and then we are gonna do something 
do you remember that route directory for nginx well me too 
so after a research we know that the route directory is /usr/share/nginx/html/index.html
so with the following command 
echo "1" >> /usr/share/nginx/html/test.html
  
we will echo 1 and then we redirect this output to some file lets say test.html
if the file doesn't exist then the linux command (>> /usr/share/nginx/html/test.html) will create the file 

so lets say the you want to run 

Dockerfile4 

FROM nginx:alpine
echo "1" >> /usr/share/nginx/html/test.html


three times so you could do something like this 


FROM nginx:alpine

RUN echo "1" >> /usr/share/nginx/html/test.html
RUN echo "2" >> /usr/share/nginx/html/test.html
RUN echo "3" >> /usr/share/nginx/html/test.html


and probably this is going to work because you are actually appanding to this file.....>> /usr/share/nginx/html/test.html
so lets try to build this image and lets see what is going to happen


C:\Users\michael.kourbelis\Desktop\real stuff > docker build  -t image_a:v10 -f Dockerfile4 .

C:\Users\michael.kourbelis\Desktop\real stuff\realstuffv1 > docker run -it -d --name image_b -p 9091:80 image_a:v10

http://localhost:9091/test.html

it echoes 1 2 3 

but there is a better way to do this by saying less layers as you see we have 4 layers 

1 FROM nginx:alpine
2 RUN echo "1" >> /usr/share/nginx/html/test.html
3 RUN echo "2" >> /usr/share/nginx/html/test.html
4 RUN echo "3" >> /usr/share/nginx/html/test.html

and why do we have four layers from the time that we can have two using one run isntruction 
this can be achieved by bash commands by backslashes which means that everything is going to be in one line 

FROM nginx:alpine
RUN \ 
 echo "1" >> /usr/share/nginx/html/test.html && \  
 echo "2" >> /usr/share/nginx/html/test.html && \ 
 echo "3" >> /usr/share/nginx/html/test.html 

&& i am keeping the same line 


so in this way we optimize the way that the dockerfile is reading 

but what if we want to do it even better 
we can create an environment variable and we can say webfile and then we can give this value  /usr/share/nginx/html/test.html

ENV   webfile 

and then we can say 

echo "1" >> $webfile && \


FROM nginx:alpine
ENV   webfile  /usr/share/nginx/html/test.html
RUN \ 
 echo "1" >> $webfile && \  
 echo "2" >> $webfile && \ 
 echo "3" >> $webfile 

 so if something inside your docker file is repeated more than once you can create an enviromental variable and use it 
 and if its possible for you to run more than one instruction in the same run then its going to be super cool as you are saving a lot of layers 

 so keep in mind 
 you can use enviromental variables that things that are repeated a lot.....
 and if possible you could run a lot of instruction in one single run instruction 
 and in that way you optimize the structure of your image 

 lets create a new image to see that plays


C:\Users\michael.kourbelis\Desktop\real stuff > docker build  -t image_q:v11 -f Dockerfile4 .

C:\Users\michael.kourbelis\Desktop\real stuff\realstuffv1 > docker run -it -d --name image_cc -p 9090:80 image_q:v11

http://localhost:9091/test.html

C:\Users\michael.kourbelis\Desktop\real stuff\realstuffv1 > docker exec -ti image_c bash 

  
xxvi.building an image with http+ssl/tls + php i
------------------------------------------------

good morninng, hello hi.......
in this video we are going to talk about a build of a docker image which will have an apache server running  
and this apache server will have _____ssl_____ or in other words https.
so in our working directory 
we have a folder with the name 
"startbootstrap-sb-admin-2" which we will use it to include code that we are gonna use it for our website more than usual we will create this folder
at the same level with our Dockerfile and also we are going to create another folder that we call "ssl" 

and we are going to move the "startbootstrap-sb-admin-2" to  folder "ssl"
so now if go inside ssl that becomes my context and in this context i only have this html code =  startbootstrap-sb-admin-2
so if we take a look inside that folder we see that we have a bunch of files...static files at heart:
    -README.md 
    -bower.json
    -data 
    -dist 
    -gulpfile.js
    -index.html
    -js
    -less
    -package.json
    -pages
    -vendor

so now what we want to do is to change the name of this folder like html_ssl,
so now what do we need to build our image ?
of course we need a dockefile as we dont have as we dont have a dockerfile here we create one 


------------------------------------------------------------------------------------------------------------------
#we are starting  
FROM centos:7
#the we install apache and php as probably we want to install some php stuff on our image 
#and also we are going to install php-mysql
 RUN  yum -y install httpd php-mysql
 #now we are going to copy the code because we want the folder that we have just create "html_ssl"
 #and this folder is that we are going to copy to "/var/www/html" which is a root directory for apache by default
 copy html_ssl /var/www/html
 #and the in order to test the php installation here we are going to run a instruction here which will echo the php info  
 #and if we see this then the installation was succesful....so the line below is a simple string that we will redirect ">" to 
 #a file which will be called php.html
 RUN echo "<?phpinfo(); ?>" > /var/www/html/back.php 

 #and we are going to create cmd for that installation which 
 #is going to be 
 cmd apachectl -DFOREGROUND

#so at the very first of this dockerfile we install http, php, mysql 
#then we are copying the code from our local folder in our context html_ssl to the images 
#and then we are just creating a new file called back.php that is a file that runs the php function before it  and display the php installation
#and said to us that the installation was succesful
#so lets save this and create our image 

------------------------------------------------------------------------------------------------------------------

find the error on the above dockerfile


C:\Users\michael.kourbelis\Desktop\real stuff > docker build  -t apache_ssl:v1 -f Dockerfile4 .
C:\Users\michael.kourbelis\Desktop\real stuff > docker build  -t apache_ssl:v1 .

here we see our dependencies installed 

Installed:
  httpd.x86_64 0:2.4.6-97.el7.centos.4     php-mysql.x86_64 0:5.4.16-48.el7

Dependency Installed:
  apr.x86_64 0:1.4.8-7.el7
  apr-util.x86_64 0:1.5.2-6.el7
  centos-logos.noarch 0:70.0.6-3.el7.centos
  httpd-tools.x86_64 0:2.4.6-97.el7.centos.4
  libzip.x86_64 0:0.10.1-8.el7
  mailcap.noarch 0:2.1.41-2.el7
  mariadb-libs.x86_64 1:5.5.68-1.el7
  php-common.x86_64 0:5.4.16-48.el7
  php-pdo.x86_64 0:5.4.16-48.el7

so now we are going to create a container using this image to test that everything goes good 

C:\Users\michael.kourbelis\Desktop\real stuff\realstuffv1 > docker run -it -d --name image_a -p 9090:80 apache_ssl:v1

we hit enter and booooom we take the big hash, so now we can go to our browser hit our localhost on port 9090
now that we made a simple change on our dockerfile we need to build-rebuild the version2 of our image 
and also create a new container with different name and different port

C:\Users\michael.kourbelis\Desktop\real stuff > docker build  -t apache_ssl:v2 .
C:\Users\michael.kourbelis\Desktop\real stuff\realstuffv1 > docker run -it -d --name image_aii -p 9092:80 apache_ssl:v3

http://localhost:9090/test.html

C:\Users\michael.kourbelis\Desktop\real stuff\realstuffv1 > docker exec -ti image_c bash 



well that is the dockerfile 
 FROM centos:7
 RUN  yum -y install httpd php php-mysql
 COPY ssl /var/www/html
 RUN echo "<?php phpinfo();?>" >/var/www/html/back.php  
 CMD apachectl -DFOREGROUND


C:\Users\michael.kourbelis\Desktop\real stuff > sudo docker build  -t apache_ssl:v1 .

find the differences with the dependencies above......

Installed:
  httpd.x86_64 0:2.4.6-97.el7.centos.4        php.x86_64 0:5.4.16-48.el7
  php-mysql.x86_64 0:5.4.16-48.el7

Dependency Installed:
  apr.x86_64 0:1.4.8-7.el7
  apr-util.x86_64 0:1.5.2-6.el7
  centos-logos.noarch 0:70.0.6-3.el7.centos
  httpd-tools.x86_64 0:2.4.6-97.el7.centos.4
  libedit.x86_64 0:3.0-12.20121213cvs.el7
  libzip.x86_64 0:0.10.1-8.el7
  mailcap.noarch 0:2.1.41-2.el7
  mariadb-libs.x86_64 1:5.5.68-1.el7
  php-cli.x86_64 0:5.4.16-48.el7
  php-common.x86_64 0:5.4.16-48.el7
  php-pdo.x86_64 0:5.4.16-48.el7


C:\Users\michael.kourbelis\Desktop\real stuff\realstuffv1 > sudo docker run -it -d --name image_a -p 9090:80 apache_ssl:v1

and now it is working we print the phpinfo and we see that we have a super old version of php and in videos forward we see how to install 
most recent versions of php
in the next video we are going to install the ssl certificates for this webserver

xxxvii.building an image with http+ssl/tls + php ii
----------------------------------------------------
hello and welcome back....here we are gonna learn how to create ssl certificates and how to configure those certificates 
in our web server that runs in a docker container 
so the first thing that we need to do is of course creating the certificates 
but what if we don't know how to create these kind of certificates ?...what we should do ?
in other cases we go to google and find the answer and type
self signed certificates in linux one line, and you see the following huge line:

openssl req -new -newkey rsa:2048 -days 365 -nodes -x509 -keyout server.key -out server.crt

so this line requests a new ssl certificate (-new -newkey) and  then will give you as an output 
one file called server.key and another file called server.crt

and basically what is upon the line above is subtle signs, certificates that we are going to use 
so we are go to our terminal we are gonna copy and paste this line and see what happened and replace the keyword server with docker

openssl req -new -newkey rsa:2048 -days 365 -nodes -x509 -keyout docker.key -out docker.crt



lets go to linux...........

copy an paste te line above but first lets enter in the container that we create


C:\Users\michael.kourbelis\Desktop\realstuff\realstuffv1 > sudo docker exec -ti image_a bash 

well inside the container we get a message that bash openssl: command not foundso we exit the container
and perform this in this:

mike@mike-VirtualBox:~/Desktop/realstuff/realstuffv1$ openssl req -new -newkey rsa:2048 -days 365 -nodes -x509 -keyout docker.key -out docker.crt

Can't load /home/mike/.rnd into RNG
140197320589760:error:2406F079:random number generator:RAND_load_file:Cannot open file:../crypto/rand/randfile.c:88:Filename=/home/mike/.rnd
Generating a RSA private key
..............+++++
.........................................+++++
writing new private key to 'docker.key'
-----
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter '.', the field will be left blank.
-----
Country Name (2 letter code) [AU]:
State or Province Name (full name) [Some-State]:
Locality Name (eg, city) []:
Organization Name (eg, company) [Internet Widgits Pty Ltd]:
Organizational Unit Name (eg, section) []:
Common Name (e.g. server FQDN or YOUR name) []:localhost
Email Address []:
mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1$ ls
cmd.sh  docker.crt  Dockerfile  docker.key  htmlcode  mapas  ssl


Common Name (e.g. server FQDN or YOUR name) []:localhost........
in that we type either our localhost if we are in it or the ip address of the os (ip you use to see the services on your web browser )
that we are working on e.g. 35.171.121.237
in everything else we just skip it with enter

now lets perform an ls to see what we have

from the ls in that folder we can see that now we have some files 

mike@mike-VirtualBox:~/Desktop/realstuff/realstuffv1$
-cmd.sh  
-docker.crt  
-Dockerfile  
-docker.key  
-htmlcode  
-mapas  
-ssl

you can see that you have docker.crt   docker.key i.e. files that installed through the line of openssl
docker.crt and   docker.key are the 2 files that we are gonna use to configure our ssl in dockerfile

now we have these two certificates here 
but we need them into the final image 

so we are going to copy these two certificates to the image through the Dockerfile
docker.crt .......to the final image----------->  /docker.crt
so in the dockerfile above and above the CMD instruction we are going to add a COPY instruction that does what is said above


COPY docker.crt /docker.crt
COPY docker.key /docker.key

so the final image will contain these two certificates, now we need to find out how to tell apache to use this certificates
in order to display them in the browser 

so lets go to google again and type 

______apache ssl centos 7_______centos 7 as we are actually using this operating system or this linux distribution 

so the guys in 

https://www.techrepublic.com/article/how-to-enable-https-on-apache-centos/

are telling us that the first thing we need to do is to install the following dependencies ( mod_ssl and openssl)
and with a look to our Dockerfile we can see that we have httpd php and php-mysql
so mod_ssl and openssl are required for apache to run ssl or https so lets go to our Dockerfile and copy these two files
on the installation line of this file

sudo yum install mod_ssl openssl


 FROM centos:7
 RUN  yum -y install httpd php php-mysql mod_ssl openssl
 COPY ssl /var/www/html
 RUN echo "<?php phpinfo();?>" >/var/www/html/back.php  
 COPY docker.crt /docker.crt
 COPY docker.key /docker.key
 CMD apachectl -DFOREGROUND


 and thus this will be followed by two thing 
 i.total erase of images and containers 
 ii.create new image version 

 we choose the first option




mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1$     sudo docker images
[sudo] password for mike: 
REPOSITORY   TAG       IMAGE ID       CREATED             SIZE
apache_ssl   v1        73ddc53189c1   About an hour ago   418MB
centos       7         eeb6ee3f44bd   5 months ago        204MB

mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1$      sudo docker ps -a
CONTAINER ID   IMAGE           COMMAND                  CREATED             STATUS             PORTS                                   NAMES
707535b16924   apache_ssl:v1   "/bin/sh -c 'apachec"   About an hour ago   Up About an hour   0.0.0.0:9090->80/tcp, :::9090->80/tcp   image_a

mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1$ sudo docker rm -f 70753
70753
mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1$ sudo docker rmi -f 73dd eeb6


so now lets build again our image and create its container


mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1$  sudo docker build  -t apache_ssl:v1 .
mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1$  sudo docker run -it -d --name image_a -p 9090:80 apache_ssl:v1
mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1$  sudo docker exec -ti image_a bash 

one thing that need to be mentioned is that later we have many tools to install 
and the best practice is to seperate them in lines 
or in other words use multilines for long strings and thats great 

multiline example 

RUN \
      yum -y install \
      httpd   \
      php      \ 
      php-mysql \ 
      mod_ssl    \ 
      openssl


and remember when we use the backslash it means that we are in the same line
so wew use this backslash to make dockerfile looks like more organized


now we need to of course generate the private key and we already did that, that's cool
and now we need to create a virtual host and in the link below they are telling us how to do it 


<VirtualHost *:443>
      ServerAdmin email@address
      DocumentRoot  "/var/www/html/adorkable/"
      ServerName AdorkableDesigns
      ServerAlias adorkable
      ErrorLog /var/www/html/adorkable/error.log

<Directory "/var/www/html/adorkable/">
         DirectoryIndex  index.html index.php
         Options FollowSymLinks
         AllowOverride All
         Require all granted
</Directory>
</VirtualHost>

and we are going to create a new file and we are going to save this file to our docker host as we 
are going to copy this file to the image later
so the file is going to be called 
"ssl.conf"
and this file will basically contain the configuration for apache in ssl 
so on the above text we are not gonna need the Directory instructions
and for the server admin we can put example@it.com
while for DocumentRoot we can put the default web root of apache 
server name will be either the same ip or the same dns that you are using  to request something on your web browser
so we are going to use localhost or 127.0.0.1
ServerAlias is not going to be used 
and the server log is in position to accept whatever you put....and with this we end with this configuration 

<VirtualHost *:443>
      ServerAdmin email@address
      DocumentRoot  "/var/www/html"
      ServerName localhost
      ErrorLog /var/www/html/error.log
</VirtualHost>


so we have the ssl.config outside of the container well outside of the image because 
so what we are going to do in our dockerfile 
is that we go and create a COPY instruction that copies the ssl.conf file to /etc/httpd/conf.d/default.com
which is the default configuration of http
so in this case we are going to overide a configuration with this configuration --->ssl.conf
now lets save the dockerfile and build the image afain


mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1$  sudo docker build  -t apache_ssl:v1 .
mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1$  sudo docker run -it -d --name image_a -p 443:443 apache_ssl:v1



so lets recap a little bit 
the first thing that we do is to start from centos.....you can do from debian, ubuntu alpine or from your favorite 
distribution
but please keep in mind and probably this process will vary a little bit then 
we use the command
 
 RUN  yum -y install httpd php php-mysql mod_ssl openssl

to install some tools some of them are mod_ssl and openssl which are required for https 
then we are copying some code so we can see something good on the browser with the following line
 COPY ssl /var/www/html

then we create a new file with the php instruction to see that php is correctly installed 

 RUN echo "<?php phpinfo();?>" >/var/www/html/back.php  
 
 finally we copy the certificates that we just created-install to same location with the image 
 COPY docker.crt /docker.crt
 COPY docker.key /docker.key


 and as a last instruction we are copying the configuration file to the default location of httpd in centos
 COPY ssl.conf /etc/httpd/conf.d/default.com
 at last we use the CMD instruction that starts the service in the container
 CMD apachectl -DFOREGROUND

 now we are going to take a look at our running containers and we use -a to display the exited containers also 

 mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1$  sudo docker ps -a

 but now we arer going to filter the command to bring us specific containers for example containers with the name apache
 so we can do something like -f=name (filter the attribute name)......-f=name=apache (and look for all of the containers that 
contain the string apache)
  mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1$  sudo docker ps -a -f=name=apache
  but
our implementation name is image_a

now we are going to remove the container that we create before in order to change the 9090 port and make it 443 which is the default 
port for https
and of course you need to map that in the https port in the container ---> 443:80--->443:443
so this         443              :        443 
       means that is your host          and that port is the  container's port      
       machine's port and your 

so basically you are mapping the port 443 and your machine to port 443 in the container 
then you can call apache and bla bla bla



mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1$  sudo docker build  -t apache_ssl:v1 .
mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1$  sudo docker run -it -d --name image_a -p 443:443 apache_ssl:v1

so now lets go to our broswer and hit 
http://localhost:443

and we have 

Bad Request

Your browser sent a request that this server could not understand.
Reason: You're speaking plain HTTP to an SSL-enabled server port.
Instead use the HTTPS scheme to access this URL, please.

so lets review our ssl.conf file and see if we are missing something and yes we have missed
and that is the path for the certificate  when we talk about ssl 
because remember that we copied those certificates to the dockerfile

 COPY docker.crt /docker.crt
 COPY docker.key /docker.key

but we are not providing the value or the path in ssl.conf, so lets go to google and try to find something 
for example
______https vhost apache_____


so as the 
https://cwiki.apache.org/confluence/display/httpd/namebasedsslvhosts
are saying that te following lines are in position to provide the certificates path 
and we are going an open up our ssl.conf file and paste these lines below:


  SSLEngine on
        SSLCipherSuite ALL:!ADH:!EXPORT56:RC4+RSA:+HIGH:+MEDIUM:+LOW:+SSLv2:+EXP

        SSLCertificateFile      /etc/ssl/star.example.com.crt
        SSLCertificateKeyFile   /etc/ssl/star.example.com.key


but we are going to remove " SSLCipherSuite " and we are going to keep the :

    SSLCertificateFile     
    SSLCertificateKeyFile   

but we need to point to the cert and the key file and if you remember in our Dockerfile we said that we copied 
the certificate (docker.crt) to    /docker.crt and
the key         (docker.key) to   /docker.key

so we are going to ssl.conf file and provide the paths
so 

  SSLCertificateFile      /etc/ssl/star.example.com.crt-----------> SSLCertificateFile      /docker.crt
  SSLCertificateKeyFile   /etc/ssl/star.example.com.key-----------> SSLCertificateKeyFile  /docker.key



  so let save this and build the image again 

mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1$  

sudo docker build  -t apache_ssl:v1 .

mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1$ 

openssl req -new -newkey rsa:2048 -days 365 -nodes -x509 -keyout server.key -out server.crt

mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1$  

sudo docker run -it -d --name image_b -p 9091:80 apache_ssl:v2


http://localhost:9091


mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1$  sudo docker exec -ti image_a bash 


now if you are going to see your web page which was previously served on http and now its displaying 
exactly the same content but its been served over https so now you may be wondering why the not secure label 
is been shown in the browser 
well this is happening because we created the certificate and this is for testing purposes  
thats why its not secure 
but the idea here is you learn how to use ssl certificates in docker container using any web server like apache 
nginx or whatever you want to use 

once you create your image through the build command
the cool stuff is that you must not wondering about configuring the ssl certificates again
you dont need to worry about installing the packages 
because everything is contained in the image 
and once you create one container based on that image which contains the configuration then you are free to go see
your site with all of your certificates, configurations and back usp
to see it in practice delete the container refresh the page on the browser see that nothing is displayed and then go 
and create the same container again but that must be based in the build image the name of the new container doesn't caree us too much 


xxxviii.what is a dangling image?
---------------------------------
here we are going to learn about dangling images, 
we are going to learn what is a dangling image 
we are going to learn how dangling images are created and we are going to learn how to find and destroy 
those images.
Now lets get started and see how a dangling image looks like
now if you type 
docker images you will probably see normall images and paranormal images e.g. images that have no name or tag
but instead they have "<none>"
what do this images mean ?
to give an answer to this we must see how these images are created......
and to demonstrate this we are going to create a new directory which is going to be called "dangling" and inside this directory
we are going to create a basic docker file.....
we save this and lets go and build this dockerfile 



mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/dangling$  sudo docker build  -t dingdang:v1 .


so from the time that we dont assign any tag in the -t flag we are going to take then by default its gonna be latest
dingdang:latest  and so we are not going to assign any tag here and then we are going to provide the context --> .


mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/dangling$  sudo docker build  -t dingdang .


once we do this our image will be built so if you type docker images ytou see your image on top 
with in repository dangling and with the assigned tag latest

mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/dangling$  sudo docker images

REPOSITORY   TAG       IMAGE ID       CREATED         SIZE
dingdang     latest    84ead2c82257   2 minutes ago   5.59MB
alpine       latest    c059bfaa849c   3 months ago    5.59MB

mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/dangling$


but now lets say that we want to build a new image using exactly this name "dangling"
so what is gonna happen? what if i go ahead and modify this docker file and then they modify one 
parent layer 
and instaed of 
FROM alpine
RUN echo file1
RUN echo file2

i made this 

FROM alpine
RUN echo file01
RUN echo file2

remember that these layer (RUN echo file01, RUN echo file2) are subsequent layers or the child layers are going to be modified 
so lets save this dockefile and lets build it again with the same name 

*but remember that images are read only so you cannot modify images instead if you want to do any modification you are 
basically creating a new image.....

mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/dangling$  sudo docker build  -t dingdang .


so now if i hit enter on the line above basically i am not modify the previous image 
in fact i am creating a new image 
and that can be reassured from the sudo docker images command that displays the image that we create and the previous one 
with the same name became <none> 

but for the above to be succeed we must change something in the dockerfile if we dont then we dont do work 

sudo docker build  -t dingdang .
mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/dangling$ sudo docker images

REPOSITORY   TAG       IMAGE ID       CREATED          SIZE
dingdang     latest    86c2077aaf37   4 seconds ago    5.59MB
<none>       <none>    84ead2c82257   20 minutes ago   5.59MB
alpine       latest    c059bfaa849c   3 months ago     5.59MB

mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/dangling$ 

so now we have a new "dingdang" image and below we have its previous image with its previous configuration
but as we didn't provide a new tag the tag that we assigned which is "dingdang" the dingdang:latest was removed 
from this image and was put into the new image 
so now remember this id "86c2077aaf37" which ends in f37
we are going to make another change in the dockerfile 

FROM alpine
RUN echo file010
RUN echo file2


we are gonna save it and remember that the id of the image above ends in f37
so now if we going to build a new image what is gonna happen is builting a new image with 
the same name the same tag 

mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/dangling$ sudo docker images
REPOSITORY   TAG       IMAGE ID       CREATED          SIZE
dingdang     latest    5d5a0ac58705   4 seconds ago    5.59MB
<none>       <none>    86c2077aaf37   11 minutes ago   5.59MB
<none>       <none>    84ead2c82257   31 minutes ago   5.59MB
alpine       latest    c059bfaa849c   3 months ago     5.59MB
mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/dangling$ 


if you look more carefully the output above then you see that a new image is created and 
the image that ends in f37 becomes a dangling image because its using exactly the same name 
a more close look reveals that the name dingdang and lates were removed from the f37 and go to 705
so basically thats how dangling images are created 
and then in the future these images will only be eating space so basically they are orphan images 
so now two things :

mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/dangling$  sudo docker build  -t dingdang .

i.how to avoid creating dangling images ?
  by using tags


  FROM alpine
  RUN echo file010
  RUN echo file2
  mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/dangling$  sudo docker build  -t dingdang:v1 .
  FROM alpine
  RUN echo file011
  RUN echo file2
  mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/dangling$  sudo docker build  -t dingdang:v2 .


mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/dangling$ sudo docker images
REPOSITORY   TAG       IMAGE ID       CREATED          SIZE
dingdang     v2        5d5a0ac58705   4 seconds ago    5.59MB
dingdang     v1        86c2077aaf37   11 minutes ago   5.59MB
<none>       <none>    84ead2c82257   31 minutes ago   5.59MB
alpine       latest    c059bfaa849c   3 months ago     5.59MB
mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/dangling$ 


now we can see that these images are diferent and a dangling image is created because the name is removed from one 
image and put into another, so if you put tags and make sure that your images have unique names then you wont be 
dealing with dangling images 
so in this lesson you learned about dangling images you learned how dangling images are created 

in the next video we are going to learn how to remove those images......

xxxix.removing dangling images
-------------------------------
so in this video we are going to learn how delete those dangling images 

mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/dangling$ sudo docker images
[sudo] password for mike: 
REPOSITORY   TAG       IMAGE ID       CREATED          SIZE
dingdang     latest    5d5a0ac58705   21 minutes ago   5.59MB
<none>       <none>    86c2077aaf37   33 minutes ago   5.59MB
<none>       <none>    84ead2c82257   53 minutes ago   5.59MB
alpine       latest    c059bfaa849c   3 months ago     5.59MB
mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/dangling$ 


so this list depicts a lot of things, so you see images which are normal images 
dingdang     latest    5d5a0ac58705   21 minutes ago   5.59MB

and you are going to see dangling images 
<none>       <none>    86c2077aaf37   33 minutes ago   5.59MB
<none>       <none>    84ead2c82257   53 minutes ago   5.59MB

so the story is known when you want to delete one two or three even 100 danglig images you can do it
but what happens if you have 456.090.9877---then i dont know......
so now that i know 
to remove 456.090.9877 at once 

there is something cool in the docker images command....i.e. you can pass a filter and filter by some attributes 
and one attribute is dangling 

so you can say "docker images -f dangling=true"
in other words please docker filter all the images were the attribute dangling is true


mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/dangling$ sudo docker images -f dangling=true
REPOSITORY   TAG       IMAGE ID       CREATED             SIZE
<none>       <none>    86c2077aaf37   42 minutes ago      5.59MB
<none>       <none>    84ead2c82257   About an hour ago   5.59MB
mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/dangling$ 

but now how do you remove those dangling images ?
from the time that we dont have a name we must use the id 
so we have another coold flag that allows us to print those dangling images' ilrsD
and this flag is the queue or -q

mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/dangling$ sudo docker images -f dangling=true -q
86c2077aaf37
84ead2c82257
mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/dangling$ ^C


so basically you can make a for loop here and removing all of the image
but the easiest way to do it is to type this

sudo docker rmi -f $(docker images -f dangling=true -q)

and basically what you tell is....
docker please remove everything which is a dangling image basically this thing $(docker images -f dangling=true -q)  
executes the command

so if i make a change and replace docker rmi -f with echo

sudo echo $(docker images -f dangling=true -q)


Got permission denied while trying to connect to the Docker daemon socket 
at unix:///var/run/docker.sock: 
Get "http://%2Fvar%2Frun%2Fdocker.sock/v1.24/images/json?filters=%7B%22dangling%22%3A%7B%22true%22%3Atrue%7D%7D": 
dial unix /var/run/docker.sock: connect: permission denied


How to Fix Docker Permission Denied Error on Ubuntu
https://linuxhandbook.com/docker-permission-denied/

Fix 1: Run all the docker commands with sudo

If you have sudo access on your system, you may run each docker command with sudo and you wont see this
Got permission denied while trying to connect to the Docker daemon socket anymore.

sudo docker ps -a

But running each and every docker command with sudo is super inconvenient. You miss adding sudo to the 
beginning and youll get permission denied error again.


Fix 2: Running docker commands without sudo

To run the docker commands without sudo, you can add your user account (or the account you are trying to fix 
this problem for) to the docker group.

First, create the docker group using groupadd command. The group may already exist but running the group 
creation command wont hurt.

sudo groupadd docker

Now that you have the docker group, add your user to this group with the usermod command. I am assuming that you are 
trying to do it for your own user account and in that case, you can use the $USER variable.


sudo usermod -aG docker $USER


verify that your user has been added to docker group by listing the users of the group. 
You probably have to log out and log in back again.

abhishek@itsfoss:~$ groups
abhishek adm cdrom sudo dip plugdev lpadmin sambashare docker

If you check your groups and docker groups is not listed even after logging out, you may have to restart Ubuntu. To avoid that, you can use the newgrp command liks this:

newgrp docker

now again run

sudo echo $(docker images -f dangling=true -q)
sudo docker rmi -f $(docker images -f dangling=true -q)

so now you know how to finf dangling images and how to remove them 
so keep in mind that you should build your images using tags and you should always have values in the repository and the tag 
attributes 
and after a time if you want to delete all the versions  then you can just go ahead and remove the old version that
you dont need anymore 


xl.Note did you see 502 errors in nginx?
-----------------------------------------

Thers is a chance that you might find 502 erros when installing nginx + php7.1
if so please change this :
--enablerepo=ius && yum clean all
to this
--enablerepo=ius-archive && yum clean all

xli.back to building create an image with nginx + php 7
--------------------------------------------------------
here in this video we are going to learn how to create an image with nginx and php7
so the first thing that we are going to create is a new directory for the context because 
remember that the context is way more important.
In the context you should only include the things that you are going to use 
so we move to our nginx directory 




mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/dangling$
mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/dangling$  cd ..
mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1$ cd nginx/
mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/nginx$ 



and now what we are going to do is top create a dockerfile, remember that you can name your dockerfile like you want
but we must call it with flag -f nameofdockerile


so we start from centos 
-FROM centos:7
then we are going to install nginx for centos if you go to ggogle and Type
 
install nginx on centos 7......https://www.digitalocean.com/community/tutorials/how-to-install-nginx-on-centos-7

and after that we see that we have two options to install nginx in linux 

i.is to install the epel repository which is a repository that has some extra packages
or
ii.using the nginx repository directly 

but in this course we are going to use the following lines as we dont need to install any extra package...we only need to create one file and then we are done
if you follow the previous guide then you will need to install two packages epel release and then you need to install nginx
so we only need to install one package 

so we divide this implementation to steps 

step 1. configure nginx repo for centos 7

we need to create a file in this location ----> /etc/yum.repos.d/nginx.repo with this content

[nginx]
name = nginx repo
baseurl=http://nginx.org/packages/mainline/centos/7/$basearch/
gpgcheck=0
enabled=1

so thats great how do we do this in docker ?


well its super simple we are gonna copy the content above to a file we call nginx.repo, and then of course we copy this file to the dockerfile
but if you want to be a little bit organize you can create a directroy called repo and then you can put your nginx.repo inside this folder
so 
you can make mv nginx.repo repo/----->move nginx.repo to repo/ 

mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/nginx$  mv nginx.repo repo/

and you have a file inside of the folder or make it somehow differently lets say that we are inside of repo it could be conf/
so lets say that in this file---->"conf" we want to save all the configuration files 

mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/nginx$  mv repo/ conf 

and in this way we rename repo to conf so now inside conf we have nginx.repo that has all the configuration files......
remember that "conf/nginx.repo" is a relative path from the dockerfile in our context 
so in our Dockerfile we copy our nginx.repo....to this location /etc/yum.repos.d/nginx.repo

COPY conf/nginx.repo /etc/yum.repos.d/nginx.repo

so that's great 

step 2-install nginx on centos 7

and this basically achieved through the following instruction
RUN yum install .y nginx

so now we are ready to build our image 

through -f we are gonna use the specific dockerfile and finally we are gonna provide the current context which is the current directory
more specifically nginx folder 
mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/nginx$ sudo docker build -t nginx:v1 -f Dockerfilenginx .


we have ubuntu terminal to return 
no package available
Error nothing to do
the command '/bin/sh -c yum -y install nginx' returned a non-zero code 1


yes because our dockerfile install the nginx first and then copies the file 

wrong
from centos:7
run yum install -y nginx
copy conf/nginx.repo /etc/yum.repos.d/nginx.repo

right
from centos:7
copy conf/nginx.repo /etc/yum.repos.d/nginx.repo
run yum install -y nginx

now we are going to install php 7
how do we install php 7 on centos 7 well we dont really know and for that we go to google and give a hit 
about that 

___install php 7 on centos 7____
and as i told you we have many ways to install a packeg in linx but to install php7 we have more ways on how to do it 
and from the fact that php 7 is not a part of the basic repository in centos:7 
we need to install an external  repository and retrieve the files from there 
a wide range of people use remi to achieve this but we are not these people we are opposite ones e.g. the range of wide or white spelling is yours 
xaxaxaxxaxaxaxaaxaxax
so we..us...we will use the ius---->install ius in centos 7....so this huba buba ius has a lot of things in that repository 
so if you go and start on your own big mistake get back here.......
we go to https://ius.io/gettingStarted/  aaaand we dont foundf anything awesome

well i cannot find a thing i copy the link from the video i see it and i write it on my own in dockerfile

we say 
RUN                         \
    yum install -y nginx &&  \
    yum install -y https://centos7.iuscommunity.org/ius-release.rpm


now that we install the repository like this...the second move is to retrieve the files from this repository 
keyword here to google: php7 in ius in centos 7 and somewhere there is a link that bears the name "packages ius"
so we need to install some packages  see below:
 ....rpm && \
  yum -y install \
  php71u-fpm \
  php71u-common \
  php71u-cli


  one thing that must be mentione is that we can install php for pdo for postgress, for cache for mysql add the libraries you want
  and increase the list above



  so here we install nginx from this repository /etc/yum.repos.d/nginx.repo
  and then install the ius repository and from this repository we install  
  -php71u-fpm                                                             
  -php71u-common                                                           
  -php71u-cli

and in linux we have a line that is in position to enable the repo and of course you can pass the name of the repo which is ius
anf if you want to clean some temporary files you can say "&& yum clean all" and yum will clean all of the cache and you know temporary files that 
created in the download.....because the idea in docker is that the final image to be as small as possible and should have as few layers as possible  
.... --enable repo=ius && yum clean all


 so the complete doeckerfile with nginx package and the php packages 

 from centos:7
copy conf/nginx.repo /etc/yum.repos.d/nginx.repo
RUN                                                                  \
    yum install -y nginx &&                                           \
    yum install -y https://centos7.iuscommunity.org/ius-release.rpm && \
  yum -y install                                                        \
  php71u-fpm                                                             \
  php71u-common                                                           \
  php71u-cli  --enable repo=ius && yum clean all


so now how do we know of this works....well lets go and try to build this image..........


the right dockefrile is below i.e. the one that creates the image


 from centos:7
copy conf/nginx.repo /etc/yum.repos.d/nginx.repo
RUN                                                                  \
    yum install -y nginx &&                                           \
    yum install -y https://centos7.iuscommunity.org/ius-release.rpm && \
RUN  yum -y install php71u-fpm   php71u-common    php71u-cli  --enable repo=ius; yum clean all




  yum -y install                                                        \
  php71u-fpm                                                             \
  php71u-common                                                           \
  php71u-cli  --enable repo=ius && yum clean all


one last thing the 
https://centos7.iuscommunity.org/ius-release.rpm
ios deprecated 
and we use https://repo.ius.io/ius-release-el7.rpm in its place


so remmeber in this video you saw a lot of errors and how to surpass them you learn hoe to install nginx
and how to install an external repository and how to install packages from that repository using docker 

mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/dangling$  sudo docker run -it -d --name image_a -p 443:443 apache_ssl:v1

xlii.do you like challenges? lets keep building our nginx image
---------------------------------------------------------------
in this lesson we are going to finish the configuration and the creation for our docker image that will have 
nginx and  php.....so far we only have nginx and phph installed in this image 
now can you tell me what else is missing ?
well if you dont know.....no worries but we are going to find it out.....the next thing that we are going to do is to configure nginx 
because in nginx we need to apply an extra configuration for php to work 
so lets go to google and type 

____nginx php fpm vhost____
and we must find the link below
https://gist.github.com/lukearmstrong/7155390

and then obtain the code below which is a super nginx configuration and you see here that we have 
the listen port the server name .....the logs and from the line 
location ~ \.php it starts the php configuration  :


server {
	listen 80;
	server_name .example.co.uk.dev;

	access_log /usr/local/var/log/nginx/example.co.uk-access.log;
	error_log  /usr/local/var/log/nginx/example.co.uk-error.log error;

	root /var/www/example.co.uk/public;
	index index.php index.html;

	location / {
		try_files $uri $uri/ /index.php?$query_string;
	}

	location ~ \.php {
		fastcgi_index index.php;
		fastcgi_pass unix:/usr/local/var/run/php-fpm.socket;

		include fastcgi_params;
		fastcgi_split_path_info ^(.+\.php)(/.+)$;
		fastcgi_param PATH_INFO $fastcgi_path_info;
		fastcgi_param PATH_TRANSLATED $document_root$fastcgi_path_info;
		fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
	}

	# Prevents caching of css/less/js/images, only use this in development
	location ~* \.(css|less|js|jpg|png|gif)$ {
		add_header Cache-Control "no-cache, no-store, must-revalidate"; 
		add_header Pragma "no-cache";
		expires 0;
	}
}

so we copy the code above and we are going to reuse it......and now we are gonna create a file under the configuration folder (conf) that we created 
which is going to be named 
"nginx.conf" and we will paste this code above in this file.......
the first thing that we need to do is to give it a server name and in the server name you can put your 
ip
dns
localhost or whatever you are using in your web browser 

in our case we are using our localhost 127.0.0.1......or we will see it....
then everything is ok until the root
where there we must provide some folder which could be like /nginxphp:
so no worries the "nginxphp" folder is not exist but we are going to create it in the level of the dockerfile

so lets save that and open up our dockerfile (Dockerfilenginx) 
but remember that the nginx.conf file which is inside the conf folder as we need to copy it.....
so lets modify our docker file 
and the next instruction is to copy it this file which is the nginx configuration that we found in internet to 
and we will put this file to the default nginx configuration and that is "/etc/nginx/conf.d/default.conf"

COPY conf/nginx.conf  /etc/nginx/conf.d/default.conf

but the default.conf is a file that we are specifying a folder which is /nginxphp that will work as web root as webroot for our webserver 
and to create that directory we need to create it above the copy instruction above

so we say 
RUN mkdir /nginxphp



RUN mkdir /nginxphp
COPY conf/nginx.conf  /etc/nginx/conf.d/default.conf


and if you are wondering why we use this name=nginxphp 
then remember that in this file 
conf/nginx.conf  we are specifying exactly the same name in  the root directory of the web server 
if you want check it with the cat command


mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/nginx$ cat conf/nginx.conf
and check the root that nginxphp folder is the root folder of this configuration
so thats why we are creating this folder  nginxphp
so now lets try to build this image  and see if we have any errors 


 from centos:7
copy conf/nginx.repo /etc/yum.repos.d/nginx.repo
RUN                                                                  \
    yum install -y nginx &&                                           \
    yum install -y https://centos7.iuscommunity.org/ius-release.rpm && \
RUN  yum -y install php71u-fpm   php71u-common    php71u-cli  --enable repo=ius; yum clean all
RUN mkdir /nginxphp
COPY conf/nginx.conf  /etc/nginx/conf.d/default.conf



so the build is succesful and we didn't have any problems, so now the last thing to do is to start the sevices inside this container
so we need to start nginx as well as php fpm 
but how we can do it id if we cannot start two processes in foreground mode ?.....because if you start one process in foreground 
mode then you cannot start the other one because the screen is going to be completeley stuck......

then what we should use as CMD......?
well lets just create a container and see what happens 

mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1$  sudo docker build  -t nginx:v1 -f dockerfilenginx .
mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1$  sudo docker run -it -d --name image_a -p 9090:80 apache_ssl:v1
mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1$  sudo docker exec -ti image_a bash 



now remember that this image does not have cmd instruction in the dockerfile and thus the container is going to die 
and this can be depicted from the following command 
mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1$ docker ps -a 

if we see the status of it we see that is in exited.....so do you remember how we keep a container alive to test it 
well lets remove the above container first and lets continue 
so to keep alive a container we use bash via the flag -ti along with the -d flag you ---> -dti

mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1$  sudo docker run   -dti --name image_a -p 9090:80 apache_ssl:v1

then that means that bash will actually be a stack....you are asking for an interactive terminal and thats why this process is alive 
but remember that in the command you should put the process itself 
you cannot or you shouldn't put bin/bashed at the process because what if you start your nginx server and it dies then you are not going to know when 
it dies and the idea is that your container dies when your process dies 
but for now we are goin to keep this like this to test 

so if we go inside of this container and test what we did is to go inside it and test what we did
and basically in the container we have everything that we did in the configuration.......
do you remember that we created an nginxphp folder well that folder we use it below...
[root@cf6af59cf4bf /]# ls /nginxphp/
do you remember a file  that we created in /etc/nginx/conf.d/default.conf
[root@cf6af59cf4bf /]# cat /etc/nginx/conf.d/default.conf
well that file is indeed in the container 
so everything that you do in the image will be in the container 
so now what we want to do is to find a way to start the php process and the nginx process both 
----one in the background 
----one in the foreground..............as we cannot start both in the foreground 




review.........

mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1$  sudo docker build  -t nginx:v1 -f Dockerfilenginx .

with -dti we keep alive a container using bash so basically if you pass this flag  it means that basch will actually be a stuck 
and basically yopu are asking for an interactive terminal and thats why the process later is alive 
but remember that in the process you should put the process itself you cannot or you shouldn't put bin bash as the process 
because what if you start your nginx server and it dies then you are not going to know when it dies 
and the idea is that your container dies when your process dies 
so for now we keep this like this to test 

mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1$  sudo docker run -dti --name imagea -p 9090:80  nginx:v1
mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1$  sudo docker exec -ti image_a bash 
[root@cf6af59cf4bf /]#

now do you remember that we create an nginxphp folder well that folder exists here
[root@cf6af59cf4bf /]# ls /nginxphp/
do you remember that we create a file in /etc/nginx/conf.d/default.conf

so now what we will want to do is to find a way to start the php process and the nginx process both 
----one in the background 
----one in the foreground..............as we cannot start both in the foreground 
..............as we cannot start both in the foreground 

so how do we start php ?
well if you type.....ps aux 

[root@cf6af59cf4bf /]# ps aux

then you will see the current processes and the only process that we have now is bin/bash
but now we want to start php in the background so that 
we can do /usr/sbin/php-fpm
[root@cf6af59cf4bf /]# /usr/sbin/php-fpm
now if we hit enter we already started in the background 

now when i run this command it displays to me the following 
[root@64cf47683004 sbin]# php-fpm
[03-Mar-2022 15:47:22] Notice: fpm is running, pid 48
[03-Mar-2022 15:47:22] Notice: ready to handle connections
[03-Mar-2022 15:47:22] Notice: system monitor interval set to 10000ms


and now i must hit ctrl+c to exit and then if i hit ps aux i didn't see the php running so it means that it didn't started 

see this 
https://stackoverflow.com/questions/60756815/configuration-php-dockerfile-from-ubuntu-image



now lets move on and see how do we install nginx in the foreground.........

so we use the "daemon-off" instruction basically this is the line -->nginx -g "daemon off;"

so if we paste the above line in the container it will complained and displays the following line


[root@cf6af59cf4bf /]# nginx -g 'daemon off;'
nginx: [emerg] open() "/usr/local/var/log/nginx/example.co.uk-access.co.uk-access.log" failed (2: no such file or directory)

and this is because the file : example.co.uk-access.co.uk-access.log does not exist 
but the 
/usr/local/var/log/nginx/example.co.uk-access.co.uk-access.log
defined in our configuration 

remember if we hit cat /etc/nginx/conf.d  and the look for the default.conf..... cat /etc/nginx/conf.d/default.conf
[root@cf6af59cf4bf /]# cat /etc/nginx/conf.d/default.conf

and if we take alook at this configuration file we will see that the 

access_log is pointing to /usr/local/var/log/nginx/example.co.uk-access.log;
and the 
error_log  is pointing to /usr/local/var/log/nginx/example.co.uk-error.log error;

but the nginx above tells us that this folder doesn't exist and this is because that these folders doesn't exist in the image
because rememebr that we too this configuration from the internet 
so  that may happen to you in the future......so lets go to our  nginx.conf and we are going to remove those paths:
  -access_log is pointing to /usr/local/var/log/nginx/example.co.uk-access.log;
  -error_log  is pointing to /usr/local/var/log/nginx/example.co.uk-error.log error;
and we are going to add some paths that are available 

in this case we can use this path......nginxphp

and we can make the like the ones below
access_log /nginxphp/access.log;
error_log /nginxphp/error.log error;

and then i think that this should solve this......

but in order for the changes to take effect we need to rebuild a new image for these changes to take effect 
so below  we rebuild the image and create a new container as the previous one is using the previous image



mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1$  sudo docker build  -t nginx:v1 -f Dockerfilenginx .
mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1$  sudo docker run -dti --name imagea -p 9090:80  nginx:v1
mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1$  sudo docker exec -ti image_a bash 

and now if we go to the file /etc/nginx/conf.d/default.conf

[root@cf6af59cf4bf /]# cat /etc/nginx/conf.d/default.conf

we can see the changes that are already applied to nginx.conf
but now one thing that we must see that if we run ps aux we see that the php process is not running 
so we run 
[root@cf6af59cf4bf /]# /usr/sbin/php-fpm

and we see that the above message is displayed:

[root@64cf47683004 sbin]# php-fpm
[03-Mar-2022 15:47:22] Notice: fpm is running, pid 31
[03-Mar-2022 15:47:22] Notice: ready to handle connections
[03-Mar-2022 15:47:22] Notice: system monitor interval set to 10000ms

we move on and run the nginx 

[root@cf6af59cf4bf /]# nginx -g 'daemon off;'

we take an empty line and we say that nginx is not complained anymore because we solved the issue and its important that you understand
what about the isuues are about and how to solve it 
as in your life you are going to face these problems every day 

so now lets go to out browser in or port 9091

mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1$  sudo docker build  -t nginxx:v2 -f Dockerfilenginx .
mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1$  sudo docker run -dti --name imageaa -p 9091:80  nginxx:v2

with http://localhost:9091       

you will see that the nginx server is up and running, of course if we kill the process in this container you see that nginx is not displayed 
so these lines are
first line we start the php service in the background 
[root@cf6af59cf4bf /]# /usr/sbin/php-fpm
and we start the nginx with the following command in the foreground and to keep alive the container based on the status of nginx 
[root@cf6af59cf4bf /]# nginx -g 'daemon off;'

_________________________________________________
so we are exited from here and we are going to create a new file in the configuration folder which 
is going to be a script with the name start.sh 
and in there i will write the followings:

#!/bin/bash
#then we are starting php and then we are going to execute our line and we print somethng in the terminal with echo 
#in order to see that we are in a good path
echo '** starting php **'
/usr/sbin/php-fpm
#and then we say start nginx with the line that we found from the internet 
echo '** starting nginx **'
nginx -g 'daemon off;'

now this script (start.sh) will be executed in the container because remember that in this script we just defined the things that 
we did manually but when you are building an image everything should be automated 
so as you might imagine we are going to copy this script to the image 
so we are going to open up our dockerfile and we are going to copy the start.sh in the configuration folder to the /start.sh
and make sure that this script has executable permissions otherwisae yu cannot execute it, unless we have a command that is 
change mode and allows you to give permissions to a file, so in this case we want to give executable permissions to the file 
but we shoul d this below the line  COPY conf/start.sh /start.sh  because above this line we dont know that start.sh exist
because we haven't copied and after the line start.sh does exist because we already copied so we say 
run change mode please give executable permissions to this file : start.sh
or else RUN chmod +x /start.sh

COPY conf/start.sh /start.sh
RUN chmod +x /start.sh

finally we use the CMD instruction we just provide this file (start.sh) which we copied from the conf folder and we gave executable permissions 
and finally we use just put in this file as the cmd for this image 

CMD /start.sh

so whenever we create a container from this image its should print to the output starting php and it should start php in the background then it 
prints nginx and start nginx in the foreground

now lets save this dockerfile and lets build this image 

mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1$  sudo docker build  -t nginx:v1 -f Dockerfilenginx .

and you see that the lasy layers that are modified 

RUN chmod +x /start.sh
CMD /start.sh

becuase from 
COPY conf/start.sh /start.sh.....and above they didn't have any modification that our docker uses our cache....
so great the last thing that we need to do is create the container that uses the latest version or the image that we have created 


mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1$  sudo docker run -dti --name imagea -p 9091:80  nnginx:v1

the browser tells me the connection was reset

because we have the -ti flag with the cmd who knows
lets remve the container and lets build another one

now one thing that messes arounf with the nginx is the php line of start.sh......./usr/sbin/php-fpm

so in this video we completed the configuration for nginx and mereley php and you learn how to install everything from scratch 

now as challenge add some code resources for this section can be found around and put them in the web root of this webserver above and thus 
whenever you refresh your page you see the html page 
and also create a php info page which uses the php info funtion  to validate that php is actually working  






so now we dont have to pass the -ti flag because we already provide the CMD instruction which will keep alive the container 





with http://localhost:9091   


mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1$  sudo docker exec -ti image_a bash 




xliii.lets solve the challenge from the previous lesson
--------------------------------------------------------
hello and welcome back in this video we are going to solve the challenge of the previous lesson 
we are going to do two things 
the firs one will be displaying a php info page 
the second one will be displaying an html code 


so lets go with the first one and see how did it go......
i need to acknowledge it was a little bit complicated but i just really wanted to see if you could debug it as debuuging in it 
is super important as you  really need to handle things that are not working as you expect 
so lets just solve the challenge 

so we now are gonna see how to debug it and how to find the errors which is the most important thing 
ok so remember that we had a container up and running 

mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1$  sudo docker build  -t nginx:v1 -f Dockerfilenginx .

mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1$  sudo docker run -d --name imagea -p 9090:80  nginx:v1

and this container is on port 9090 



so the first thing that we want to do is to create a simple php file which will contai the php info function 
so we can create inside the nginx folder the php file with the following command

mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/nginx$ vi test.php

and we can say 
open php 
<?php phpinfo();?>

so now that we have created the file we need to copy it to the dockerfile

so thats easy we open the dockerfile and copy it to the web root of this nginxphp web server 
remember that in the configuration file of (nginx.conf) we define the root directory of nginx in the folder nginxphp

so we need to copy the teest.php to the folder of /nginxphp
COPY test.php /nginxphp in order to see it in the browser 
so we save that and we try to build the image

mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1$  sudo docker build  -t nginx:v1 -f Dockerfilenginx .

mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1$  sudo docker run -d --name imagea -p 9090:80  nginx:v1

now we type localhost:9090/teest.php 
and we see a 502 bad gateway 
why is that and this is a tricky part that a few can solve it 
ok the first thing that you must have in mind always is that when you are dealing with webservers you always have to take a look 
at the logs 
and where are the logs of this server?
well if you rememebr we have a confoguration in the conf folder the " nginx.conf " which defines the access log and the error log 
so probably in the file of " error.log " we have some information that will help us understand why this php is not working 
so lets go inside of this container to debug this container  

mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/nginx$  sudo docker exec -ti imagea bash 
[root@cf6af59cf4bf /]# 

its quite important to go inside of the container and remember that in the configuration of this container if we go here
cat /etc/nginx/conf.d/default.conf
we can see that we have the error log in the /nginxph/error.log error;
so if we just do a tail which allows us to follow the file then you are going to see a bunch of logs 

[root@cf6af59cf4bf /]# tail -f /nginxphp/error.log


[root@c0c8d650b4c4 /]# tail -f /nginxphp/error.log
2022/03/04 15:07:27 [error] 8#8: *1 directory index of "/nginxphp/" is forbidden, client: 172.17.0.1, 
server: localhost, request: "GET / HTTP/1.1", host: "localhost:9090"
2022/03/04 15:07:34 [crit] 8#8: *1 connect() to unix:/usr/local/var/run/php-fpm.socket failed (2: No such file or directory) 
while connecting to upstream, client: 172.17.0.1, server: localhost, request: 
"GET /teest.php HTTP/1.1", upstream: "fastcgi://unix:/usr/local/var/run/php-fpm.socket:", host: "localhost:9090"
2022/03/04 15:08:53 [crit] 8#8: *3 connect() to unix:/usr/local/var/run/php-fpm.socket failed (2: No such file or directory) 
while connecting to upstream, client: 172.17.0.1, server: localhost, request: 
"GET /teest.php HTTP/1.1", upstream: "fastcgi://unix:/usr/local/var/run/php-fpm.socket:", host: "localhost:9090"


so if we do is to leave some spaces by hitting some enters in the ubuntu terminal refresh the browser and see the terminal  again
we see that we have a critical error here 
2022/03/04 15:36:23 [crit] 8#8:
and this happened because this directory does not exist :  No such file or directory
and now we have a hint : to unix:/usr/local/var/run/php-fpm.socket failed
again the same error...aha


2022/03/04 15:36:23 [crit] 8#8: *5 connect() to unix:/usr/local/var/run/php-fpm.socket failed (2: No such file or directory) 
while connecting to upstream, client: 172.17.0.1, server: localhost, request: "GET /teest.php HTTP/1.1", 
upstream: "fastcgi://unix:/usr/local/var/run/php-fpm.socket:", host: "localhost:9090"
[root@c0c8d650b4c4 /]# tail -f /nginxphp/error.log
2022/03/04 15:07:27 [error] 8#8: *1 directory index of "/nginxphp/" is forbidden, 
client: 172.17.0.1, server: localhost, request: "GET / HTTP/1.1", host: "localhost:9090"
2022/03/04 15:07:34 [crit] 8#8: *1 connect() to unix:/usr/local/var/run/php-fpm.socket failed
 (2: No such file or directory) while connecting to upstream, client: 172.17.0.1, server: localhost, request: 
 "GET /teest.php HTTP/1.1", upstream: "fastcgi://unix:/usr/local/var/run/php-fpm.socket:", host: "localhost:9090"
2022/03/04 15:08:53 [crit] 8#8: *3 connect() to unix:/usr/local/var/run/php-fpm.socket failed (2: No such file or directory) 
while connecting to upstream, client: 172.17.0.1, server: localhost, request: 
"GET /teest.php HTTP/1.1", upstream: "fastcgi://unix:/usr/local/var/run/php-fpm.socket:", host: "localhost:9090"



now we are going to exit from the container with ctrl+C
and go to our docker host : mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/nginx$ 
and you know it because if you type docker ps yopu are able to see your containers running 
so here we can open up our nginx.conf that is inside the conf folder 
and we are going to try   to look at the line that was displayed in the error
and the line thar was displayed the error is the following locatiion were the error was pointing
unix:/usr/local/var/run/php-fpm.socket 
and effectively we dont have this folder in  the container i mean the following folder doesn't exist in the container 
so if you remember the error is pretty similar to the error that we previosuly had here e.g. to the 
access_log /nginx/access.log;
error_log /nginxphp/error.log error;

so how can we solve it ?
the firts one is to pass the correct path for the socket 
the secomd is to use the correct port where the php fpm runs........so we are going to use the port in here, just for you to know how to use the port 
because with that configuration you already know how to use the socket,
so lets use the port.....
if you dont know how to use the port then you go to google and search for that so lets say: 
php fpm unux port : php-fpm: configuration the listen Directive | Directive | Servers for hackers 
and the  in that we look for this argument in the configuration file (nginx.conf) which is "fastcgi_pass" and yes we find it 
we just simple pass the localhost with the port or correspondingly ip and port
the default port where php-fpm runs   is 127.0.0.1:9000......fastcgi_pass 127.0.0.1:9000;......in this case you are not using any files but 
instead you atre using the port 
so now that we think that we found the issue...we are going to save this file and remember that we need to rebuild the image for this change to take effect
so now we are going to build the image and create the container after  



mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/nginx$  sudo docker build  -t nginx:v1 -f Dockerfilenginx .



after we built the image we perform the command docker ps i dont know why but we must do it please imagine the reason......

mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/nginx$ docker ps 
alright if we have remove all the containers the output hears in the name of kolokithia toumpana, lets create the container 


mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/nginx$  sudo docker run -d --name imagea -p 9090:80  nginx:v1

ok we get our hash and thus we can go to our browser and hit the below line:


http://localhost:9090   


review video 43.......


44.basics for multiStage Build in Docker
-----------------------------------------
in this video we are going to talk about a ferature in Docker called "multiStage Build"  the idea of this feature is to reduce the size of the final image 
becasue the size on Docker matters the size of the images matters 
so now if you type "docker images" you see that:  

Repository    Tag     Image ID      Created            size
nginx         v5      654646rt      345 years ageo     323MB
nginx         v4      65vgh46rt     345 years ageo     5.53MB

you see that some images are lightweight some other are a little bit heavy and that actually depends on how you build the image i.e.
which image you pick as....from....if you pick up as centos, devian then you have different sizes and those sizes have an impact to the final image 
so now in multi stage build we can reduce the size of the final image 
lets make a basic example 
first of all we are going to create a new folder that we call "multistage" and in that folder we create a dockerfile that we start from centos
in order to see the size of this image and we can see that the centos image is 202mb
that means that our result image wil at least be 200 megabytes in size because its taken the centos image as a base 
so we know that we already have 200 megabytes here 
so now if you try to build this image "docker build -t test-multi" we see exactly the same size 
in linux we have a cool command that is the fallocate command that allows us to create files with the size we want, for example lets say that we want 
to create a file with  10 megabytes  "fallocate -l 10M file1"  
and then if you take a look at the size of the file through the command "du -sh file1" you will see that the file is 10MB 
so we are going to use this feature to explain this thing about multi-stage build 
we remove files in docker through the command........rm -rf file1
so we are going to create files like this in our dockerfile 
so from the Centos we have 200 megabytes 
and now we are going to run a command that says......RUN fallocate -l 10M  /opt/1 and the same goes for /opt/2

so lets build this image and see if we get a size similar to the expected one 
so 

mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage$  sudo docker build  -t myfile .
mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage$  du -sh myfile ........nooooooooo
mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage$  docker images 

Repository    Tag       Image ID      Created            size
myfile        latest    654646rt      345 years ageo     225MB
nginx         v4        65vgh46rt     345 years ageo     5.53MB


so now we are going inside our dockerfile and think about something.....we think around a maven application and we will be installing 
dependencies
packages 

i.e. comonents that increase the size of the image 
and then the result of all of these processes will give you a jar file which is going to be i dont know five megabytes in size 
but you already installed like 2o megabytes in dependencies but you only want the jar file which is 50 megabytes in size 
so we are going to create the jar below the final run command 
so we say 
RUN fallocate -l 5M /opt/jar 
it s not really a jar file.....we make it for testing proposes 

but why would you need to save all of these dependencies if they are basically trash.....you dont need them you only need the jar, 
so how do we do this ?
well remember the alpine image and its a super tiny image and also we spoke about a multi stage build in docker 
and what the nulti stage build in docker allows you is that it basically helps you to retrieve a file a specific file from a previous stage 

so lets divide stages in the dockerfile

#stage 1, delimited from the from instruction  
from centos:7
run fallocate -l 10M /opt/1
run fallocate -l 10M /opt/2
run fallocate -l 5M /opt/jar
#stage 2,uses the alpine from instruction
from alpine and everyting we put below it will belongs to the stage number two
from alpine 
#so lets say here we staring a java image or something like that....a java environment and we want to copy the file from the jar folder above 
#to the stage number two  and we want to run it as we dont want all the size from the dependencies fo the stage number 1,
so how do we do this ?
the first thing that we can do is that we copy and then give the first stage an alias e.g. from centos as build for example 
and then you specify the build alias from the from of the stage number one in the from of the second stage and also we say that we want to copy 
the jar file that was created in this process and then we paste that file to some different location for example to ther root 

copy --from=build /opt/jar /jarfile.jar

and then finally we put our cmd instruction or whatever we want to run our application, but the main idea is that the resulting image will have 
the two layer below i mean it will only have the last stage in your image:

from apline 
copy --from=build /opt/jar /jarfile.jar

so if we define more than one from instruction then the last one will be the final image 
and actually you are in position to retrieve all of the files that you need fro every stage and thus 
the final image makes the efficent use of components that are needed seriously

so lets build this image on order to see how it works
but remember that before the stage number 2 the image was 225 megabytes but now what happens if we try to build this new image 


from centos:7
run fallocate -l 10M /opt/1
run fallocate -l 10M /opt/2
run fallocate -l 5M /opt/jar
from apline 
copy --from=build /opt/jar /jarfile.jar

mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage$  sudo docker build  -t myfile .

mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage$  sudo docker build  -t myfile .
mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage$  du -sh myfile ........nooooooooo
mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage$  docker images 

Repository     Tag       Image ID      Created            size
myfilea        latest    654646rt      345 years ageo     10.8MB
nginx          v4        65vgh46rt     345 years ageo     5.53MB

so why it is 10 megabytes in size ?
well its because the base image that yopu are using here is in the second stage is alpine and alpine is five megabytes in size 
and then youa are copying from build which is the previous step which is the previous step the file that is 5 megabytes and that the 
resulting image is 10 megabytes 
so as you see this is supergreate because even though when you created all of these files and even though you created from a heavy image 
like centos which is 200 megabytes in size 
even though you started from here - centos and create a bunch of files at the end you saved the file that you needed and its going to be reflected at your final image 

at the next video we are going to see how to create a docker file using a real world application and we arte going to build a tiny job application using 
multi stage 

45. Got the idea lets build a real image with mutli stage
----------------------------------------------------------
in this video i am going to create a dockerfile and in this dockerfile we are going to have two stages 
in the first one we are going to use a maven application because we are going to build a maven application 
and in the second stage we are going to use a java docker image because we are going to run that "jar" using java 

so the first thing that we are gonna do is took around for "Docker maven" and we are gonna search for the 
official maven image in docker
as i told you most of these vendors of open source applictions theu already have their own official docker images. 
so to download the maven image you hit 
docker pull maven and you see that you have a lot of tags available here e.g. maven:3.6-jdk-11-slim
for our example we are going to use the alpine tag as alpine is super tiny and is good to use it
so lets start, the first stage brings the alpine maven and in the second stage we are going to use an open jdk image 
which is for java so we look around for "docker openjdk" and we found some things about its official image i.e. 
we can pull the lates version of openjdk with the comand below:
docker pull openjdk

or if the latest version of this image is not desired we can use a plethora of avialable tags from the page which hosts the information of this image



#stage 1
from maven:3.6-alpine
#stage 2
from openjdk:8-alpine


from recent research the maven image is about 122Mb
and 
the openjdk is 105mb

so we are going to use maven image to package our application and then we are gonna copy the jar that we created in maven image 
and we are gonna put the jar in the second stage of our Dockerfile 
so lets go to our Dockerfile and the first thing that we need to do in the maven stage is to write some  java code 
we go to google and type 
maven sample application 
if you have never worked with maven before you need to know that maven looks like for a file called "pom.xml" which is a file that are a lot of dependencies that are 
defined and those dependencies are needed to built our application our jar in this case 
basically you go the pom's directory and here you type maven package and maven looks for pom.xml and maven will download all of the dependencies required for you 
now we are going to copy the maven file of github to the multistage folder 
so we are going to use the 

copy instruction to copy a local folder to somewhere in the image, in the copy instruction if the folder doesn't exist the through this 
it is gonna be created, we already have the "app-maven" in our image 
the next thing that we need to do is to change directory to this directory --->/app
so lets use the workdir  and we are gonna use the directory (/app) that we created 
so from the time we say 
workdir /app......thats it we are in app folder and once we are here we can run an instruction and we can say 

RUN mvn package......and as i told you maven will look for a file called pom.xml and maven  will download all of the dependencies that are required to build the application 
and after maven downloads the dependencies then the jar will be built 


#stage 1
from maven:3.6-alpine
copy app-maven /app
workdir /app
run mvn package
#stage 2
#from openjdk:8-alpine

so now we are using only one stage of this image and save the current state of it....built it and run it in order to see how it works 
so lets try to built the image from the dockerfile


mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage$  sudo docker build  -t myfile .


if we accomplish this succesfully we can see the jar tha was built,
so now lets take a look at the size of the image through the keyword "grep" that filters images per name so it is easier for us to search,
so somewhwere in the terminal there is the path of the jar 
[INFO] building jar: /app/target/my-app-1.0-SNAPSHOT.jar 
which is the path where the jar was built inside of the image, so we are going to modify our dockefrile image again 
and now we are going to start in the second stage, so in the second stage we are going to use openjdk and we are going to copy from the previous step 
but we need to put an alias in the stage of the first from in order to be able to call it from the second stage 

#stage 1
from maven:3.6-alpine as builder 
copy app-maven /app
workdir /app
run mvn package
#stage 2
from openjdk:8-alpine
copy --from=builder /app/target/my-app-1.0-SNAPSHOT.jar /app
CMD java -jar /app.jar


in a nutshell we copy this file "/app/target/my-app-1.0-SNAPSHOT.jar"
from 
the stage one and remember the this path is the path that maven gave us after its built was completed....and we are going to copy it to the current stage 
of some location...lets say  "/app"
and the we are gonna give the CMD instruction that says java -jar and we pass to it the path (app.jar) which is the path of the current stage 

so what happened here ?

remember, below we created a maven application, we built a jar, we download all the dependencies 

#stage 1
from maven:3.6-alpine as builder 
copy app-maven /app
workdir /app
run mvn package


and in the stage 2 below we just copying the jar from the previous stage via the builder alias and we are not copying any kind of dependencies 
we are not copying any temporary files we are not copying anything else but only the jar that we need, and finally we just ruuning the app.jar via 
the cmd instruction 

#stage 2
from openjdk:8-alpine
copy --from=builder /app/target/my-app-1.0-SNAPSHOT.jar /app.jar
CMD java -jar /app.jar


so lets save it and letsbuild the version 2 of this image and lets see how it works...well it works lets take a look at the size 
to sum up we the second version contains the second stage that contains only the required stuff and you see that the size is smaller than every else image in previous stages

mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage$  sudo docker build  -t appmaven:v2 .


now lets create a container for this image that we just created 

mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage $  sudo docker run -d appmaven:v2
ok we get the hash 
now if you take a look at you container is n ot alive (docker ps) you cannot see it here and thats because the process running the container only 
prints the hello world and exits 
so if you type .....docker logs and the hash the you will see the hello world that comes form the jave -jar that we wrote in cmd 

so nwo if you create another container with exactly the same image but with a different name e.g. 

mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage $  sudo docker run -d --name app appmaven:v2

and then you perform the docker logs with the name as the parameter and not the whole hash it will displays hello world which is nothing else but
thee functionality of this jar file in the cmd instruction

diladi to prwto run egine me v2 h v1 xwris to flag --name kai eprepe na to kalesoume me olo to hash 
kai to deytero egine me to flag  --name opote mporesame na to kalesoume mono me to onoma tou  

mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage$  du -sh myfile ........nooooooooo
mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage$  docker images 


46.check your knowledge
-----------------------
the idea of this article is that you solve the following problem using what have you learned.
At work you have a request to create a basic docker image which will be taken as a base for all of the web apps.
Your task is to create a Dockerile with the following specifications and deliver it to your boss:

operating system base : Debian

tools to install      : Apache (latest version)
                        php 7.0

you must use best practices
you should check that the image works by creationg an index.php with the php info function.


quiz 2: feel comfortable with images ? lets check it 

question 1 
given this line : ENV animal chicken 
whats the name of the variable?
--->animal
question 2
consider this line 
from centos 
which tag is being used?
--->the latest 
question 3
look at the following lines : user foo
                              user bar
                              run echo "hello, its $(whoami)" > /tmp/user.txt

what will be the content of the /tmp/user.txt file?
--->bar
question 4
you have 2 files in your current directory like this :
file1 -> 10M
file2 -> 15M

you also have a .dockerignore file with this context size :

$ cat  .dockerignore
file2

if you build the image in this directory, what will be the context size?
---> 10M

question 5
you want to install multiple packages using only one layer in your dockerfile.
how would you do it?

---> RUN yum -y install httpd php


you must review the question number 3


---------------------------------6.Docker images - build advanced images------------------------------end







-----------------------------------------          -----------------------------------------
-----------------------------------------  review  -----------------------------------------
-----------------------------------------          -----------------------------------------








start----------------------------7.Docker containers - learn how containers work in depth----------------

47.what is docker container?
---------------------------
hello and welcome back to the introduction of these containerss section in this section we are going to learn 
a lot about containers 
we are going to learn how to create containers and how to do a lot of hacks with containers 
we are going to understand what is a container,
how is the filesystem structure ?
what is the difference between a docker host and a docker container 
how to copy files, how to manage users 

and generally you will have an awesome time..........

but also we need to talk about some basics that we must keep in mind 




so the first thing that you must keep in mind is that a container is  nothing else but a runtime presentaion of an image 
   the second thing is that the containers are temporary so that means that if you do any change to that container,
   once you destroy a container all of the changes are going to be gone 
if you want a permanent change you need to apply that change to the image 
so you probably will need to build a new image because as i told you that file system or the read and write layer of the containers are temporary 
if you destroy the container everything that was inside of that container that is not in the image is going to be deleted 
the third thing is that the container is basically a layer with read and write permissions 

and the last thing that you need to rememeber is that you can create as many containers as you want from one single image 


48.listing and creating containers
-----------------------------------
hello and chicabaoum baoum
in this lesson we are going to be taking a look at some cool things that we already saw in previous lessons 
so the first thing that we are going to saw here is the ....Docker run.... command
and remember that the DSocker run command allows you to create containers 
and to know the  .....Docker run....command has a lot of possible options 
i.e. 
if you type ....Docker run --help, you are going to see all the things that you can use 
for example you can add cpu limits (cpu quota int) 
            you can put a detach mode 
            you can dns 
            you can add hostnames 
            you can add IPs (Ip6 string)
            you can add labels 
            you can add memory limits 
            you can add names 

in order to create a container you basically need an image of course 
so now lets create an image.....we have no images created so lets work with the nginx alpine image
basically we work with the image appmaven v4

mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage$  docker images 


Repository      Tag     Image id        Created         size
appmaven        v4      e1d56ghjak78    16 hours ago    105MB

you can create as many containers as you want on an image as it is super easy 
                 
mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage$   docker ps -a

container id      image            command                       created         status                      ports      names
cfeejh786hjhgh    appmaven:v4      "/bin/bashsh-c 'java -jar'"   16 hours ago    exited (0) 16 hours ago                app
34344344vdcvhg    appmaven:v4      "/bin/bashsh-c 'java -jar'"   16 hours ago    exited (0) 16 hours ago                gracious_easley h me alla logia kolokithia toumpana
   
so lets create another container you type the command below 

                                                                    with -d we create the container in the background
mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage$  docker run -d  appmaven:v4
                                                                                after -d flag we must 
                                                                                specify the name of 
                                                                                the image that this 
                                                                                containers goes to...


now if you do docker ps-a you see a new container in the list              
mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage$   docker ps -a

container id      image            command                       created         status                      ports      names
7686gxzhahnjgh    appmaven:v4      "/bin/bashsh-c 'java -jar'"   7 seconds ago   exited (0) 5 seconds ago                cranky_sanderson
cfeejh786hjhgh    appmaven:v4      "/bin/bashsh-c 'java -jar'"   16 hours ago    exited (0) 16 hours ago                app
34344344vdcvhg    appmaven:v4      "/bin/bashsh-c 'java -jar'"   16 hours ago    exited (0) 16 hours ago                gracious_easley h me alla logia kolokithia toumpana


so with docker run command you can create containers 
  with docker ps you can see you running containers 
  with dockewr ps -a (or --all) you can see you running and not running containers



so anothe thing that i wanted to tell you is that probably you are going to find a lot of things like this in internet 
i.e. if you type docker container ls 
the output is the same with the docker ps -a, but what happens in  docker container ls is that it is exaclty the same command with docker ps
but some years ago the docker wanted to segregate the commands for containers and for images for simplicity 
so you can type docker container and the output is the same with docker ps
the same goes for 
docker run appmaven:v4 = docker container create appmaven:v4


we must keep in  mind how to create a container and how to list a container because we will be using it in the future 

49.Remove and rename the containers 
-----------------------------------

with the docker ps you see all the running containers  and in you running containers you will always have a container id (327dsgd647a676)
which is a unique hash or a unique id which is created for your container 
then you always have your image (appmaven:v4) which is the image name that was used to start this container 
then you will see the cmd ("nginx -g 'daemon of....'") of this container which is defined in the image the you see time creation of this image 
then you see the status i.e. if it is up or exited 
then you see the port thing i.e. in what decibel that container listens to e.g. 80/tcp and basically this means which ports are being mapped to these containe
and finnaly you see the name of the container if you put a name to your container with the flag --name then you see your name or else 
you see that you container has a name of kolokithia toumpana or else a very strange name

to deleteb a container you write docker rm -f container name or container id 
or without -f 
you must first stop the container first and the remove it 


now we go to ggogle and look around for the jenkins image in docker.....docker pull jenkins
so to downnload the image you must use the command "docker pull jenkins/jenkins"  

so lets perfor a simple pull of that image to our linux machine 

mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage$  docker pull jenkins/jenkins
....
status: downloaded newer image for jenkins/jenkins:lastest
docker.io/jenkins/jenkins:lastest
mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage$

so now if we type docker images and filter them through the keyword grep to display only the images with the jenkins name we should see our image
mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage$  docker images | grep jenkins
we will see something like that:
jenkins/jenkins   lates     25fg677bszs 19 hours ago 460MB 


so now we are going to create a container using this image so we can type docker run -d --name jenkins jenkinshan:v1 
unable to find image 'jenkinshanL:v1' locally
docker: error response from daemon: pull access denied for jenkinshan, repository does not exist.......

yes this is because the name of our image is jenkins/jenkins from the time that we didn't provide a name of our desire so we must use this name

mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage$  docker run -d --name jenkins jenkins/jenkins

we must do this 
mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage$  docker run -d jenkins/jenkins

ok we see the hash of our container and now if we do docker ps we see our container up and running, but for example what if you forgot to set a name for this container
container id      image               command                   created         status             ports                   names 
dd6ah628dshj      jenkins/jenkins     "/sbin/tinn---/usr/..."   11 seconds ago  up 9 seconds ago   8080/tcp, 5000/tcp      cool_hypatia

well there is a cool command for this that listens the name "docker rename", so our previous image has the random name  "cool_hypatia" and our new name is kolikithiatoumpana 

mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage$ docker rename docker rename cool_hypatia kolikithiatoumpana

now if we do docker ps we will see in the name attribute the name of kolikithiatoumpana

in this video we learn how to remove a container how to force a container to be removed how to rename a running container 

50.More tips start, stop, Map Ports!
------------------------------------
hello in this video we are going to learn how to map ports on a container, so through the docker ps command we see the exact ids that we want to remove.
now we are gonna talk about the run instruction which is publish....and publish allows you to expose a port in a container 
for example whta happens if you want to create a jenkins container for example lets try to create this....lets give a name lets say jenkins and then we pass the jenkins 
slash jenkins image that we just downloaded then.....how do you access this service (jenkins/jenkins) on your browser 
well as we see from above this container uses the port 8080, what happens if you want to access this service using this port 
well if you go to your browser and you type your operating system's ip or localhost and then we pass the port like this "os'sip:8080"
in the browser i am unable to connect even though that the course is displays that the site cant be reached......
so what can we do is to map the port of the container to the docker host because remember that the container above is a tiny operating system an isolated process 
so if you wanted to access that service you need to share the port with your host and your container 
so how do you do that ?
so lets remove the kolokithia toumana and create another container but now we are going to expose the port

--publish instruction or simply -p allows us to expose the port of the container, so  we already know that jenkins for this container is running on port 8080
and inside of this container you need to map that port to some port in our local machine, so for example we can map it on port 9090 of our machine or any othe free port \

mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage$  docker run -d --name jenkins -p 9090:8080 jenkins/jenkins 

so we run it and now in the docker ps section we see something different regarding the port....we have this interface 0.0.0.0 which means that your host listens on all
of the interfaces and is exposing the port 9090 and this port is being mapped to the container port 8080 
so if you go to the port 8080 you are not going to see anything because 8080 is the port of the container and 9090 is the port of your local machine (or your docker host)


before 
container id      image               command                   created         status             ports                   names 
dd6ah628dshj      jenkins/jenkins     "/sbin/tinn---/usr/..."   11 seconds ago  up 9 seconds ago   8080/tcp, 5000/tcp      cool_hypatia
after 
container id      image               command                   created         status             ports                                                    names 
dd6ah628dshj      jenkins/jenkins     "/sbin/tinn---/usr/..."   11 seconds ago  up 9 seconds ago   5000/tcp, 0.0.0.0:9090->8080/tcp. :::9090->8080/tcp      cool_hypatia

so if you want to access the sevice you need to access this port and the this port (9090) will do a forward internally to this port 8080 and that will be displayed 
on your web browser, 
so if you type your localhost:9090 you can see that you have a jenkins server up and running in that port from our docker container.


now remember that from an image we create as many containers we want but each container must have a different name and a different port regarding our port..not 
the image's port

now remember that the port to the left relates to your docker host 8080:8080 and the port on the right relates to the container port

one thing that must be noted here is that if we stop a container we do nothing more than killing the process without removing it 
if you want go and hit docker ps -a instead of docker ps 
you will see your container in the list but in an exited status 
so if we want to start again the container that we stopped we need to do a docker ps -a grab the name or the id of the container and simplt type docker start
e.g. 
mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage$ docker start container's id or container's name then your container is now up and running go to the browsers then
hit refresh and see your container to run 
here we learn how to map a port of our docker machine to the port of a docker container 
     we also learned how to stop a running container without deleting it using docker stop container's id or name

then we learned how to see this stopped containers and then how to start them again
docker stop doesn't completely remove a container but it makes to be on an exited status 

51.understand the container's filesystem
----------------------------------------
hello and welocme back 
in this video we are going to learn the difference between the docker container's filesystem and the docker host filesystem 
so how do we rmove all of the containers we have ? well thats a good question i will think it all day and i answer it tommorow...

if we type docker ps we see our running containers but if we type docker ps -a we see all containers exited and no
now if we add the flag -q to the docker ps -a we are going to retrive all the ids of our containers...
do you remememer its pretty similar to what we showned in the dangling images using the id 

mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage$ docker ps -a -q

so now how do we remove those containers well we type..... docker rm -f $(docker ps -a -q)
please be carefull as this command destroys all of your containers 
so now we are going to create a new container 

mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage$  docker run -d --name jenkins -p 8080:8080 jenkins/jenkins 

we wait a little bit for the service to be ready and when its ready we see that jenkins asking us a kind of a key....a secure key to unlock 
jenkins to make sure that we are the administrators  
so remember that the path below should be inside of the container : 
/var/jenkins_home/secrets/initialAdminPassword

now remember two things, we have two file systems now our host's file system which is the docker host file system where we can see all of our running containers 
here you have all of your folder and all of your stuff this with ....ll.... 
and then you have the container's file system which is completely diferent because remeber that the container is another os runing isolately 
so to enter inside the container we give the command "docker exec -ti container's name bash"

mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage$  docker exec jenkins bash
jenkins@c2eb5b805622:/$
.....and now you see that you are inside the jenkins container and no longer inside of your machine because if you type ls here you see completely 
different things....now you know that you are inside of the container because if you perform a docker ps exactly before you give the 
" docker exec jenkins bash" coomand and you see the container's id and then type the " docker exec jenkins bash" you see that the id is the same 
and that is because the id of the container is the hostname for the container
so if you type echo $HOSTNAME you obtain the container's id and if you go outside the container and type exactly the same line you realize that you obtain
the hostname of your OS
i.e. 
jenkins@c2eb5b805622:/$  echo $HOSTNAME
jenkins
jenkins@c2eb5b805622:/$ exit
exit
mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage$ echo $HOSTNAME
mike-virtualbox
mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage$ whoami
mike
mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage$ docker exec -ti jenkins bash 
jenkins@c2eb5b805622:/$  whoami
jenkins 
jenkins@c2eb5b805622:/$ ls /tmp/ 
git_lfs_pub.gpg hsperfdata_jenkins jetty-0_0_0_0-8080-war-_-any-5423951470016971213 winstone6129314358760634906.jar
jenkins@c2eb5b805622:/$ exit
exit
mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage$ ls /tmp/ 
different things from what is inside the container 

so you can thing a container like a super tiny operating system like a super tiny little machine that is running a completely different file system from your docker 
host file system and all of the files that you created there are going to be completely isolated 
so for example if you create a file in the container with 
jenkins@c2eb5b805622:/$ touch /tmp/hello
jenkins@c2eb5b805622:/$ ls /tmp/.....then you see the file is there 
git_lfs_pub.gpg hello hsperfdata_jenkins jetty-0_0_0_0-8080-war-_-any-5423951470016971213 winstone6129314358760634906.jar


but if you try to see the tmp file of your docker host you will not find this folder there, so its a completely different file system 

so now if we go back to our web browser jenkins is asking us for a key and it is telling us that the key is in a file called  

/var/jenkins_home/secrets/initialAdminPassword

so lets copy this location above and go to our docker host and we type 

mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage$ cat /var/jenkins_home/secrets/initialAdminPassword...you get a greek salad with yogurt
cat : /var/jenkins_home/secrets/initialAdminPassword: no such file or directory

in other words the path above doesn't exist as you dopnt have jenkins installed on your computer 
so thats what we are going to do is to go inside our container and type exactly the same line you get some results 
and realize that the file is indeed exits and contains like a hashtag which is going to be used later to configure jenkins in your browser 

mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage$ docker exec -ti jenkins bash
jenkins@c2eb5b805622:/$  cat /var/jenkins_home/secrets/initialAdminPassword
c0b44ba56c0349199ac6e4c158f70355
jenkins@c2eb5b805622:/$ 

but the idea here is to understand that the container has a completely different file system from your docker host 
so the files you create here are completely different from your docker host file 
and thats why when you remove a container everything is gone and your docker host is not affected 
thats why when you install a package in your container you are not affecting you docker host because its a completely different file system  

so now if you go and obtain the hashtag and put in jenkins you see that you log in and you can install jenkins 

now you know whats the difference between your docker hosts file system and whats the difference between your containers file system......

52.Do you like variables ? lets learn how to create them in containers
----------------------------------------------------------------------
in this video we are going to learn about enviromental variables in containers, if you remember we spoke about enviromental variables to the dockerfile\
at the image section and we learn how to create enviromental variable for our images 
so now lets just recap on that.....lets go to our docker images folder 

mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage$ cd docker-images/

and we open our dockerfile there with the view to modify it a little bit


from centos:7
run yum -y install httpd
copy html-code /var/www/html
cmd apachectl -DFOREGROUND

here we add an environmental variable.....ENV  vari 1a

from centos:7
ENV  vari 1a
run yum -y install httpd
copy html-code /var/www/html
cmd apachectl -DFOREGROUND

now if we are gonna built this image 
                                                                                              
mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images$ docker built -t env .

then once your image is completed you can take a look at your images and more thorouhly filter the env image with grep

mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images$ docker images | grep env 
yopu will see your image there 
and ifn you take alook at your dockerfile then you will see that in the image we should have one enviromental variable 
with the name vari that has a value 1a
now lets remove our containers ion order to create our new container that is going to use our image 

mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images$ docker ps -a 

mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images$ docker rmi -f $(docker ps -a -q)


our new container has the --name env and used the env image that was builted above, now we hit enter and we create our container 

mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images$ docker run -d --name env env
ok we get the hash, now lets perform a docker ps with the view to see that container and of course to use its name to gain access, but keep in mind that 
this container is a completely different file system from your docker host


mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images$ docker exec -ti env bash
[root@150e4fdb8b36]# 

so now if you take a look at your enviromental variable via the env | grep vari then you see 
that we have one environment variable with the value 1a
[root@150e4fdb8b36]# env | grep vari

outside of the container there is no way to find this variable as it is only available inside the container to see the value you can also echo it 
[root@150e4fdb8b36]# echo vari

remember that this value has been taken from the dockerfile as the dockerfile has an env instruction that defines an enviromental variable 
that hears the name vari and  has a value 1a

ok youy already knew this....you know how to create enviromental variables for images 
but how do we create an enviromental variable for a container ?
wee thats a good question.........
lets look
[root@150e4fdb8b36]#  echo $test 

of course we have nothing because this variable doesn't exist.=, but what if i want to create only a variable called test in runtime execution?
only in the container but without using the dockerfile....how would i do it ?
well lets exit this container and remove that container that we created about 10 minutes ago 
[root@150e4fdb8b36]# exit 
exit 

mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images$ docker rm -f 150e4fdb8b36

and lets create a new container with a new thing that must be revealed......and it is that in the docker run command we have an option 
which is -e and it stands for --environment  and basically if you type -e and look your bank account at the same time you become billionaire
but in this case we select the second option which is that with -e we can pass one enviromental variable for our container 
and you see this is outside the dockerfile it doesn't really matter if you have enviromental variables in you docker file or if you dont have,
because if you pass this -e instruction and you pass to this the text "test = eimai meagalh paixtoura" and you hit enter then a new container will be created 
with the enviromental variables that are defined in image env

mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images$ docker run -d --name env -e "test = eimai meagalh paixtoura" env


to go inside the container we can use the hash of the image or simply the name of it 

mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images$ docker exec -ti env bash
[root@150e4fdb8b36]# echo $test 
eimai meagalh paixtoura
[root@150e4fdb8b36]#  env | grep  test 
test=eimai meagalh paixtoura

so we see that the variable is available without the need of the dockerfile but if you type "env | grep vari" which is a variable that has been taken
from the dockerfile its indeed here 

mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images$ docker build -t env .
mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images$ docker run -d --name env -e "test = eimai meagalh paixtoura" env



so basically you can have in the container variables coming from your dockerfile or you can have variables come from the creation of the container 
by pass the flag -e (which stands for enviroment) then you pass the name of the variable and its value anf its gonna be available in the runtime of the container
but what happens if you define a variable with the same name with the dockerfile, lets see

mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images$ docker run -d --name env -e "vari=eimai meagalh paixtoura" env

the containew will be created and the value of the dockerfile's variable will be overwritten by the value of the container's one....

so in this video you saw how to use enviroment variables in containers, 
how to use the enviroment variables from your dockerfile 
how to create new enviroment variables for a new container 
and 
how to overide existing enviromental variables with a different value 

53.lets launch a Mysql container for the first time
----------------------------------------------------
in this video we are going to see how to create a mysql container, so the first thing that we are going to do is to create a container first,
so we are going to use an official image of mysql ---> docker mysql image 
and here you will find one nysql image for docker and there you can find all of the available tags  (docker pull mysql)
we are going to use the 5.7 version which is the most popular one 

and you know you can pull the omage before creating the container or you can just create a container without having the image 
and 
docker will automatically figure out that you dont have the image and it will download it for you, 
so now we need to take a look at how to use this image.........
normally on the docker official images have the reference or documentation.....
so we scroll down to the section that says "how to use this image", so here we have an example 
start a mysql server instance 

$ docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag

the important point starts from the flag -e......it passes an enviromental variable with the name MYSQL_ROOT_PASSWORD and 
its value will be applied to the mysql server that will be created, 
so basically what they do is that they create a script as the CMD and the script just looks for some enviromental variables 
it does some basic logic saying if the enviromental variable is defined then go ahead,
otherwise just kill the container and say, I cannot proceed until you provide a password 


so lets try to create a Mysql server or a Mysql container without providing any enviroment variable  and lets see what happens 
so lets type "docker run -d --name test mysql:5.7"

i dont have this image locally which means that docker will pull it from docker hub automatically  


mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images$  docker run -d --name test mysql:5.7

so now if i type docker images | grep mysql.....i will see that

mysql     5.7.    118667108c2     39 jours ago     450MB


now if you type docker ps you see that your  mysql is not there ......why......lets make a docker ps -a 
and you see that you container is exited 4 minutes ago 

so if you take the container's id or name of that container from the output of the docker ps -a 
and you type "docker logs fe91722bfefe" in order to see what happened to the container,
do you remember that everythhing that we see in docker logs is published by the CMD instruction 
so if we give the line below then booooooooommmmmmmmm.......

mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images$  docker logs fe91722bfefe

we are gonna see that 

2022-03-10 10:26:35+00:00 [Note] [Entrypoint]: Entrypoint script for Mysql server 5.7.37-1debian10 started.
2022-03-10 10:26:35+00:00 [Note] [Entrypoint]: switching to dedicated user 'mysql'
2022-03-10 10:26:35+00:00 [Note] [Entrypoint]: Entrypoint script for Mysql server 5.7.37-1debian10 started.
2022-03-10 10:26:35+00:00 [Note] [Entrypoint]: database is uninitialized and password option is not specified you need to specify one of the following:
  -MYSQL_ROOT_PASSWORD
  -MYSQL_ALLOW_EMPTY_PASSWORD
  -MYSQL_RANDOM_ROOT_PASSWORD

mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images$

the system complains that it needs some enviromental variables and you must provide them in order to pass the basic validations, 
so now that we know that we must pass the enviromental variables lets go ahead and remove the mysql container together with everything else......

with 
mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images$ docker ps -a 
mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images$ docker rm -f $(docker ps -a -q)
mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images$ docker images 
mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images$ docker rmi -f $(docker images -q)


now we are going to follow the guide and we are going to provide some enviroment variables 
so lets first give the name mysql to the container 

mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images$  docker run -d --name mysql
then we pass the environmental variables 
-e MYSQL_ROOT_PASSWORD=12345678  mysql:5.7

mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images$  docker run -d --name mysql -e MYSQL_ROOT_PASSWORD=12345678  mysql:5.7

now if you make a docker ps 
you will see your container is up and running.........

and now if you do a docker logs -f 

mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images$ docker logs -f 410fc487e699
to follow the logs then you are going to see something that is coming up here, 
that the service is starting as you see here

Mysql init process done.ready for start up.

and then you finally at the end you see that mysqld: ready for connections

ok now this is super great, but the question here is okay you have your mysql server running your mysql container up and running 
but how do you test it so as you see in the output of docker ps we are not expose any ports only the 3306 is shows up and thats it

so to test it we can use a new command which is docker inspect which allows us to take a look at the configuration of a container  
so if you type docker inspect and the container's id 

mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images$ docker inspect 410fc487e699

then you are going to see a huge json file which will tell you all of the configurations for the current container 
no worris we talk about this later 
but for now what really matters for us is this thing--->networks where there there is something which is called 
"IPAddress" : "172.17.0.2" 
which is of course the ip address of this container because i dont if i already told you but containers also have their own internal network
so the container is created and they will be created in an internal network for containers that is managed by docker 
we will be talking about networking later........
but for now just keep in mind that you can graph the ip of a container 
and please remember that all the containers have an ip address 
so we are going to use this ip address so we are copy that 172.17.0.2
and typ docker ps in order to reveal the name of the container and now we are try to connect to the ip address of the container using the mysql command 
in our terminal 
well in this case we have an error 
(
  command 'mysql' not found, but can be installed with:
  sudo apt install mysql-client-core-5.7
  sudo apt install mariadb-client-core-10.1
) 

because i dont have the mysql client 
so no worries i dont know what i am using here 
so to install the mysql client to your docker host to test the service youcan type

sudo yum -y install mysql 

and that will install the mysql client in your docker host to test some things here 

mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images$ sudo yum -y install mysql 

mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images$ yum  install mysql 

command yum not found but can be installed with:
sudo apt install yum

mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images$ sudo apt install yum
mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images$ sudo yum -y install mysql 
there are no enabled repos.
run "yum repolist all" to see the repos you have.
you can enable repos with yum-config-manager --enable <repo>

so we install mysql with 
  sudo apt install mysql-client-core-5.7
  sudo apt install mariadb-client-core-10.1

  mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images$ mysql 
  ERROR 2002 (HY000): can't connect to local Mysql server through socket '/var/run/mysqld.sock' (2 "No such file or directory")


https://stackoverflow.com/questions/61891530/couldnt-connect-to-mysql-error-1045-28000-access-denied-for-user-root/61892558#61892558
Couldn't connect to MySQL: ERROR 1045 (28000): Access denied for user 'root'

I am working on UBUNTU and the container was created successfully with the following command:
docker run -d -p 3000:3306 --name mysql  -e MYSQL_ROOT_PASSWORD=123456789 -e MYSQL_DATABASE=docker_db -e MYSQL_USER=docker_user -e MYSQL_PASSWORD=0000 mysql:5.7 
but once trying to connect to the database using:
mysql -u root -h localhost -P 3000 -p 
I am getting this error:

ERROR 1045 (28000): Access denied for user 'root'@'localhost' (using password: YES)
..........
Answer

By default, when the client try to connect on localhost, it will use the socket and not TCP and will ignore the port parameter.

I think you have a MySQL up and running locally and it's why you have the access denied error instead of this one:

 mysql -u root -h localhost -P 3000 -p
Enter password: 
ERROR 2002 (HY000): Can't connect to local MySQL server through socket '/tmp/mysql.sock' (2)

y changing the command for:

 mysql -u root -h 127.0.0.1 -P 3000 -p

Enter password: 
Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 2
Server version: 5.7.26 MySQL Community Server (GPL)
[...]
Will use the TCP connection on the IP/port you give.


  first of all  the command to run is 
  docker run -d -p 3000:3306 --name mysql  -e MYSQL_ROOT_PASSWORD=123456789 -e MYSQL_DATABASE=docker_db -e MYSQL_USER=docker_user -e MYSQL_PASSWORD=0000 mysql:5.7 
 
  and then there is no need to install yum, mysql or such stuff

  simply type 
  mysql -u root -h 127.0.0.1 -P 3000 -p
  then put the passoworf that you put in the run and you are connect to your sql 


  ........
  ands as you see we are inside of the mysql container without using the internal ip address, it is helpful when you dont want to expose your database
  but when you want to expose your database you need to map your port for some people to be able to access your service 
  in this video you learn how to create a mysql container a pretty basic one 
  to pass an enviroment variable which will be set as the root passowrd for the the container (mysql:5.7) and then you know 
  how to inspect a container and how to find out the ip address of that container and how to test the service that is running in that container using the ip address 
  of that container.....
  so in the next lesson we are going to see how to expose the port of the mysql server and how to access that using the port  

54.Mapping ports in mysql 
-------------------------
here we are going to learn how to expose the mysql service that we just created previously and how to make our database accessible to our network.
so we are just going to remove the container that we created before and now we are going to expose the port with the -p flag 
and remember you can pass any port of your docker host which could be 9090 and then you need to pass the port in which the mysql is running 
and in this case the container is running on port 3306......-p 8080:3306
so if you do this then the service will be available in all of the interfaces of your docker host 
which means that you can now use your host ip address and hit the port 8080 or 3000 and you should be able to connect to the mysql service 

now we are going to take a look at something new....we are going to read the documentation and we can see that we can do more things with the 
enviromental variables 

we can define the MYSQL_ROOT_PASSWORD 
                  MYSQL_DATABASE..............and once we define these variables once the container is created then the script in tne cmd 
                                              will ask ok if these guys passing me these variables 
                                              i will just create a database using the value of that variable 
                                              so lets pass these variables in here.......


    docker run -d -p 3000:3306 --name mysql  -e MYSQL_ROOT_PASSWORD=123456789 -e MYSQL_DATABASE=docker_db -e MYSQL_USER=docker_user -e MYSQL_PASSWORD=0000 mysql:5.7       

    note here is that the   MYSQL_USER is that we create a new user with permissions to the database a new user which is not the root user 
    so we can just copy these and also we can provide a password for that user  MYSQL_PASSWORD=0000      


    so lets recap :
    1. we are exposing the service to the port 3000 
    2. where the name of it is "mysql"
    3. and provide the root passowrd via -e MYSQL_ROOT_PASSWORD=123456789          
    4. providing a database through MYSQL_DATABASE=docker_db
    5. then we add another user        

    so now that we have completed lets hit enter  and see that it works our container is created and it is up and running 

    so now  lets see the logs (docker logs -f) because we need to wait until the service is ready 
    and if we scroll down we see that mysqld : ready for connections. 
    so now if you do......docker ps you see something different in the status of the ports as you see that you are exposing all of your interfaces on 
    port 3000 in your docker host and you are forwarding that port to 3306 on our container 
    it means that if you use the ip of your docker host (3000) and you connect to this port (3000) then you are going to be able to connect to the service 
    without the need of asking  for the docker container ip  and anyone on your local network or if its public can connect to your database which is good 
    if you are working with people and you can also restrict this port (3000) using firewall rules or using aws security groups 
    the thing is that this port will be available on your ip address  on the ip addrerss of your docker host so now to test it we are use the mysql 
    comand that goes with the -u flag which stands for the user as above we create a user which is the docker user (MYSQL_USER=docker_user) 
    with password   MYSQL_PASSWORD=0000
    the root password is 123456789 and the database is docker_db

    so we can go and try with the root user -h flag stands for host and now we can use our localhost because now remember that we have expose 3000 to 3306 and our local
    port is available to all of our interfaces in our docker host then we can give the passowrd via -p123456789 which is the passowrd for the root user 
    now if you hit enter you can see that you can enter your mysql service without any problem
                                         
      mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images$ mysql -u root -h 127.0.0.1 -p123456789

      and before the passowrd we need to pass the -P 3000


      so now i exit the mysql service and give the command ip a in order to find my internal ip which is 10.0.2.15
      and if put in the position of 127.0.0.1 the system will allow me to enter the mysql service again......ok 

     
docker run -d -p 3000:3306 --name mysql  -e MYSQL_ROOT_PASSWORD=123456789 -e MYSQL_DATABASE=docker_db -e MYSQL_USER=docker_user -e MYSQL_PASSWORD=0000 mysql:5.7 

so now we are gonna test using the user that we created in the enviroment variable which is the docker user and rememebr that the password for that user is 0000

so lets try again 

mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images$ mysql -u docker_user -h 10.0.2.15 -P 3000 -p0000
yes

MySQL [(none)] show databases;

then you are able to see all the avaiilable databases and docker created these databases for you taking the value from the enviroment variable that you provided
and you can also use this database because this user has permissions on it by default 

in this lesson we learned how to use environment variables how to use an offivial image how to read the instyructions to create the container
and in this case we create a mysql container with a user and a password 
we actually connect it using the ip address of the container 
we expose the port and that means that we can now connect using our docker hosts ip address 

55.More databases? lets create a postgreSQL container
-----------------------------------------------------
in this lesson we are going to learn how to create a docker  postgress container to host the postgres database.
so the first thing that you should always do when you dnto know about something is that you need to go to google
and you need to find the documentation for it 
in this case that what we want to search is "docker postgress" and we find the docker postgres image (docker pull postgress)
we go down down and find the section 
How to use this image....
and there we just see that we need to run a container (docker run)
                                      assign a name (--name somepostgresssomewhere)
                                      provide a environment variable defined in the password which is 
                                      preety similar to the mysqlprocess (-e POSTGRES_PASSWORD=password) and 
                                      we must put it in the background through the use of -d flag.........
                                      and 
                                      finally just provide the image (postgres) that you want to launch 
                                  
docker run --name somename -e POSTGRES_PASSWORD=password -d postgres

but lets scroll down and take a look at the environment variables 
-POSTGRES_PASSWORD
-POSTGRES_USER
-POSTGRES_DB
so we are going to create a container with these 3 envirnmental variables and we will test them 
so lets try to write : docker run -d --name postgress -e POSTGRES_PASSWORD=password -d postgres
and lets add another enviroment variable because we want to create a postgress user and also another
enviroment variable which is for the database POSTGRES_DB 

docker run --name somename -e POSTGRES_PASSWORD=password -e POSTGRES_USER=docker_user -e POSTGRES_DB=docker_db -d postgres

so now we want to test that our service is working so we are going to expose the port for postgress 
but 
if we dont know the port that this image exposes then we need to take a look at the documentation 
so lets typr ctrl+f and in the search box ww give the -p flag that guides us to the port or type port
and 
in the case that you cannot find information that you are looking for in this case we dont know in which port 
postgres runs 
so you have two options.......
the first option is to take a look at the dockerfile of this image so you can just click on any of the tags that are mentioned on
the section of "supported tags and respective dockefile links" 
and then the tags will redirect you to its dockerfile and there you can look for an argument or an instruction in a dockerfile which is exposed 
so lets look for an argument with the name "expose" and yes we find it......EXPOSE 5432
but probably you dont know probably what expose mean in the dockerfile because we didn't talk about that, well this is the moment
and in the dockerfile you give the expose expression to inform the port in which your application is supposed to run,
you can basically put anything in here because the expose instruction doesn't do really to much but its only for information purposes 
by taking a look at this docker file and by taking a look at this argument (expose 5432)......i know that these container
should run on this port (5432) and that really helps a lot 
or 
the second thing that you can do is that basically you can create your container without defining any port and you can just provide an image in here like postgress

docker run --name somename -e POSTGRES_PASSWORD=password -e POSTGRES_USER=docker_user -e POSTGRES_DB=docker_db -d postgres

well i dont have the image locally so the docker will download it automatically 
but the thing is that once the container is created and you type "docker ps" you are going to see the port that your container is use, and now you are wondering 
ok where this information is taken from and well the answer is this 
when you define the expose instruction in your dockerfile and you put the port here and once you create your container without any port then it will show up here 
as an available port for the container 
i mean you can map the 5432 to your host's port in order to expose the service 
as i told before EXPOSE instruction is only for information purposes, so for instance if you create an apache image the =n in the expose instruction you probably 
want to put the port 80 to inform your user that your application should run on port 80
if you are creating a tomcat image then you should expose your port on 8080 to inform your user that your image runs on port 8080
or 
if you are creating a mysql image then in the expose instruction you put 3306 which is the default port where mysql runs 
so lets remove the every container and every image from before 
and lets create the container above but now lets expsoe exactly the same  port and we are goinf to map it to the same port in the conatiner

docker run -d --name somename -e POSTGRES_PASSWORD=password -e POSTGRES_USER=docker_user -e POSTGRES_DB=docker_db -p 5432:5432  postgres

hit enter and you see that your database container is up and running via the docker ps command

CONTAINER ID       IMAGE       COMMAND                     CREATED          STATUS          PORTS                    NAMES
7f69b9acfadb       postgres    "docker-entrypoint.s..."    7 seconds ago    up 4 seconds    0.0.0.0:5432->5432/tcp   somename


so now if you go inside your container with " docker exec -ti somename bash "  and lets try to login 
but before define the database you want with " psql -d " and the database name is docker_db (which was defined at the container through the 
environment variables) and the capital -U is for define the user and in this case we want to provide the docker_user whoch was created again with enviroment 
variables e.g. psql -d docker_db -U docker_user 
now if you hit enter super cool you see that you are inside your docker container (7f69b9acfadb) and then you see that you are in you are connected to the postgress
console using the database value (docker_db) you just created and the user value (docker_db) you created both with enviroment variables in the container above

 mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images$  docker exec -ti somename bash 
 root@7f69b9acfadb:/# psql -d docker_db -U docker_db
 psql (14.2 (Debian 14.2-1).pgdg110+1)
 type "help" for help.
 docker_db=#

56. DevOps Style ? Jenkins as a container!
------------------------------------------
in this section we are going to see about jenkins container......google : docker jenkins 
well we dont have much information here but it says that that you can run your image in this way : docker pull jenkins/jenkins image 

so lets try to do that......      expose the port 8080 as by default jenkins runs on  this port, so we will map 9090 to 8080 of the container
 mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images$  docker run -d --name jenkins -p 9090:8080 jenkins/jenkins  
special note is that if yopu dont have that image locally docker will automatically download it byitself
so now that we have this container up and running we can hit 9090 (on our host) on the browser and see the login of the jenkins, 
so we already know how to get the password in jenkins from the path

/var/jenkins_home/secrets/initialAdminPassword

so remember that a container is basically a tiny operating system which is  running things so we can go at any moment inside the jenkins container or inside 
of any container by using this line   and then from the time you gave localhost and port on the browser jenkins displayed the path that contains a a secret password
whic is inside a file so we can do this to display the password :
cat /var/jenkins_home/secrets/initialAdminPassword


 mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images$ docker exec -ti jenkins bash 
 jenkins@28a413025a5a:/$ cat /var/jenkins_home/secrets/initialAdminPassword
 f900ajdsajd7667uc5udstxcgjdk
 we copy and paste the secret password to the administrations textbox and we are going to select plugins to install  
 and do what you want to do

 57.For hungry containers only :D Learn how to apply limits
 ----------------------------------------------------------
 in this section we are going to learn how to limit the resources that a container can use, 
 so if you remember you can create as many containers as you want from one image 
 butf you just creating containers and you go crazy then probbaly your machine will be just be overloaded 
 because it doesn't have enough resources to serve all of your containers 
 so the first thing that you should always know is how many resources you have in your current machine and your docker host machine 
 so you can type free -h

 mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images$  free -h 


and this will show you how much ram you have available 

          total used  free  shared  buff/cache   available
mem:      3.9G  1.5G  745M     53M       1.6G         2.1G
swap      2.0G  780K  2.0G


and in this case you see that i have about 4 giga, and also take a look at how many processors you have on your machine by typing grep "model name" /proc/cpuinfo

           
 mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images$  grep "model name" /proc/cpuinfo

model      :  158
model name :  Intel(R) Core(TM) i7-7700 cpu @3.60GHz

and  to display the number of cpus (i have 2 bthw) that you have available then you can add  | wc -l.......grep "model name" /proc/cpuinfo  | wc -l
2



so now that you know the resources that your machine has its time to learn how to control the resources that your container can use 
so lets launch a simple nginx webserver  that we launch it with the alpine image......docker run -d --name nginx nginx:alpine
and with docker ps you see it up and running 
now there is a command in docker which is called "docker stats" and it allows you to see the resources that a container is using, so you can type 

 mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images$  docker stats container name or id

 now if you type enter you will see some information here like container id 
                                                               name
                                                               cpu %
                                                               mem usage /limit
                                                               mem % 
                                                               net i/O
                                                               block i/O
                                                               pids.......and some more things, but the most important thing here is that we want to learn how to 
                                                                          control the ram (mem usage / limit) and the cpu usage.

so you see that this container which is serving an nginx web site is actually taking only one megabyte in ram and then you say ok thats enaough i dont really care
but what happens when the process takes more than one megabytes in size 
and 
what if it takes more than your total capacity then probably your machine will be overloaded, so lets hit ctrl+c to get out  the lopp taht we get to when we give 
the command : docker stats container name or id
and lets create a mysql container  

 mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images$   docker run -d --name mysql mysql:5.7
 
 and now if we do the same thing i.e. docker stats mysql.....you will see that mysql is using 0 resources in everything because it exited as we didn't provide a 
 password for the root user 

 mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images$   docker run -d --name mysqli -e MYSQL_ROOT_PASSWORD=5678 mysql:5.7

mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images$ docker stats mysqli

now we will that mysql taks a litle bit more ram than nginx....about 200 mb in ram
and probably in the future you might find processor or containners that take more than one gigabyte in ram or take more than your total capacity 
so its alwasy good to restrict  the amount of cpu or memory that a container can use.....
so how do we do this ?

basically we are going to worl with the nginx:alpine container......well in docker we can type docker run --help and find many interesting things 
and if you want to filter something you can type pipe (|) grep and then the thing that you want to find......e.g.

 mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images$ docker run --help | grep memory

      --kernel memory bytes           kernel memory limit 
 -m,  --memoery bytes                 memery limit
      --memory-reservation bytes      memory soft limit 
      --memory-swap bytes             swap limit equal to memory plus swap: '-1' to enable unlimited swap
      --memory-swapiness int          tune container memory swapiness (0 to 100) (default -1)

mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images$

then you can see tha you have an option to limit the memory that we want to assign to our container 
so it still in you that if you pass the flag --memory....the amouunt that you provide will be assigned to the container so lets try that 
with 200MB for the memopry of this specific container

mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images$  docker run - d --name nginx2 --memory "200mb"  nginx:alpine
in other words
i want to crteate a docker container that uses nginx:alpine image and hears the name nginx2 and it uses up to 200 mb in memory

mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images$  docker run - d --name nginx2 --memory "200mb"  nginx:alpine
warning : your kernel does not support swap limit capabilities or the cgroup is not mounted. Memory limited without swap.
but the memory limit applied as with the docker ps we see bot nginx images 

container id      image           command                     created          status            ports              names
cf19e31f4508      nginx:alpine    "/docker-entrypoint....."   15 minutes ago   up 15 minutes     80/tcp             nginx2
13cf7b148fdc      nginx:alpine    "/docker-entrypoint....."   1 hour ago       up 1 hour         80/tcp             nginx


now if we type docker stats and provide both the nginx id or names we see that nginx with id 13cf7b148fdc makes use all of the hardware memory limit
(take up your entire memory)
and the nginx2 is limited up to 200mb at most and that ensures that yur container will never gets the maximum limit which is provided by your hardware resources 
so its always good to limit your containers to a certain amount of resources because probably you dont want to give all your resources to one container 
its always a good idea to limit or restrict your containers so that you can see what they are doing 
                                                                                how much ram they are occupy and 
                                                                                how they are behaving 
if they are behaving as you expect or if they are eating more resources than expected,thats how you restrict memory in a container 
so basically when you run the container to just pass --memory and you just provide the amount of memory that you want to assign to that container 

container id     name      cpu %   mem usage / limit       mem %    net i/O       block i/O         pids
13cf7b148fdc     nginx     0.00%   2.141MiB /  3.852GiB    0.05%    4.38kB /0B    0B    / 8.19KB      2
cf19e31f4508     nginx2    0.00%   2.16MiB /   200Mib      1.08%    4.01kB /0B    4.1kB/  8.19KB      2


so now what about cpu, well you can type docker run --help | grep cpu

mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images$ docker run --help | grep cpu

and from all of the output we choose is the --cpuset-cpus string.......cpus in which to allow execution (0-3, 0,1)
basically with this line you assign some cpus to your container 
so as you saw i only have 2 cpus in my virtual machine so of course i can assign 2 cpus to my container 
but if you execute the following command :

mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images$  grep "model name" /proc/cpuinfo wc -l

and it returns more that one line then it means that you have more than one cpu and you can assign 1 or 2 pr 3 cpus depending on how many cpus youo have available 
in this case i have 2 cpus so it will  not make much sense to assign only one cpu to a container since i only have 2 vcpus

but if you have more than one cpu then you can just assign 2 cpus instead of four and we are going to see how to do that 
so basically we run another container  which will be the nginx3 with the memory to be 300Mb and we will also provide the option of --cpuset-cpus
and the example from the command : docker run --help | grep cpu
says to us how to use this option....so say that you have four vcpus available in your machine then you are start counting from 0 up to 3 
and you can assign the cpus that you want to your container 
so for example if you want to assign only one cpu then you can do something like this "--cpuset-cpus 0" 
telling docker okay i want to assign to this container my cpu number 0 
or if you want to assign your cpu zero and your cpu 1 you can do something like "--cpuset-cpus 0-1"
or if you want to assign all of your four cpus you can can do something like "--cpuset-cpus 0-3" 
or if you want to assign all of your cpu number 0 and your cpu number 3 then you can do something like "--cpuset-cpus 0,3"
using the comma will only assigned cpu zero and cpu 3 so it means that your container has two cpus but if do this 0-3 you mean that you want to assign 
a range.......so the range from 0 to 3 the range is four, so this is how you limit resources in your containers 
remember that the cpu thing (--cpuset-cpus) relies on how many cpus you have available, e.g.
in the case that i have one cpu i can do this 

mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images$ docker run - d --name nginx3 --memory "300mb" --cpuset-cpus 0 nginx:alpine

but if i have more than one cpu i can do this 

mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images$ docker run - d --name nginx3 --memory "300mb" --cpuset-cpus 0-2 nginx:alpine


58.copy files from your host to your container - Docker cp....
--------------------------------------------------------------
hello  and good morning, in this lesson we are going to copy files to a running container.
so say that you have a runing container which is an apache server or an nginx server or any kind of container that you want.
in this case i will run an apache web server via the httpd image in docker and expose the port 8080 on 80 since the httpd 
runs by default on port 80

 mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images$ docker run --name apache -p 8080:80 -d httpd 
 
 now we make a docker ps and go to our browser as we saw that our container is running and hit localhost:8080 to see our devops development
 and see that it works 
 so now if you go inside of this container through its id or name and take a look at the structure (via pwd first and ls secondly) of this container 
 you will see the "htdocs" folder and if we make a cd to that folder we see the index.html file


 mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images$ docker exec -ti apache bash
 root@ebe835cb5722:/usr/local/apache2# pwd
 /usr/local/apache2
 root@ebe835cb5722:/usr/local/apache2# ls
 bin buiold cgi-bin conf error htdocs icons include logs modules
 root@ebe835cb5722:/usr/local/apache2# cd htdocs/
 root@ebe835cb5722:/usr/local/apache2/htdocs# ls
 index.html
root@ebe835cb5722:/usr/local/apache2/htdocs# cat index.html
 <html><body><h1>it works</h1></body></html>
root@ebe835cb5722:/usr/local/apache2/htdocs#
so basicaly it measn that in this path  "/usr/local/apache2/htdocs/index.html"
is the file that is being served in the browser, and this is reassured if you hit the cat command in this file
root@ebe835cb5722:/usr/local/apache2/htdocs# 

but now what happens if for some weird reason you want to copy one file from your docker host to your container or vice versa?
please remember that if you copy any files from your docker host to your container once the contgainer is deleted then all gone 
so please remember that the layer in the container is a temporary layer and if you want to persist something it should be at the level of the dockerfile.
but in here we are going to learn how to copy files from a container to docker host and the opposite, so ok now that we know this path
 "/usr/local/apache2/htdocs/index.html"
 we are going to exit out of our container and go to our docker-images folder.....and i am going to create a file there that i name it test.html
 that we pass it the text "COPIED FILE FROM OUTSIDE"
 and now if i make cat test.html on the terminal i will see the text

 mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images$ cat test.html

 special note in order to make a newline so the terminal path displayed on the new line we must hit enter on the text editor
 so now we only want to do is to copy the test.html file to our container and replace the index.html there with the test.html here
 so if you take a look at the path :  "/usr/local/apache2/htdocs/index.html" ,this is the destination path
 so to copy this file test.html which is in our docker host : /Desktop/realstuff/realstuff1/multistage/docker-images

 we are going to do......docker cp and we copy our source which is our local file and then we provide the destination, and the destination is composed
 by the name of the container and in this case the name of the container is "apache"......"docker cp test.html apache:/usr/local/apache2/htdocs/index.html"
so that its we copied from our pc (docker host to our container) and we mention also what file to replace
you can also copy to a different location e.g. if you want to copy the test.html to the /tmp in the container you just do it like this : 
docker cp test.html apache:/tmp
then we can go inside the container with docker exec -ti apache bash 

root@ebe835cb5722:/usr/local/apache2/htdocs# cd /tmp/
root@ebe835cb5722:/tmp# ls
test.html
root@ebe835cb5722:/tmp# cat test.html
COPIED FILE from outside
root@ebe835cb5722:/tmp#

so the question is how do we copy a file from the container to our dockerhost-localhost?
so this is easy as well
so we can go to any folder.....lets go to the opt folder and lets create a file there ....echo "from the container"..... and redirect it (>) 
to the test.txt file  
root@ebe835cb5722:/opt# echo "from container" > test.txt

so that means that in /opt/test.txt we have a file that displays "from the container" so if you do cat /opt/test.txt you will see 
from the container.....
now we want to copy this file....../opt/test.txt to our docker host........
so we are going to exit our container 
and we are going to provide the source which is going to be the container and the path of that container  
that contains that file....apache:/opt/test.txt
and thgen define the where we must copy that file i.e. its destination
if we need to copy th e current directory we put . at the end to specify current, now make an ll and youy will see the file from opt folder of the container 
inside the folder "docker-images" of your docker host.

 mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images$ docker cp apache:/opt/test.txt .
 mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images$ll
 .....
 .....
 -rw-r--r-- 1 mike mike 15 Mar 14 06:21 test.txt
 mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images$

 so this is how you copy filed from container to docker host and vice versa 
 please keep ij mind that you can use this twchnique for debugging purposes or things like that becasuse if you copy a file from your docker host 
 to your container remember that the file that you copy with this direction is temporary as if you delete your container anatinazeis tautoxrona kai to tetragwno
 sto opoio meneis......me liga logia ta kaneis lampogiala ola......
 in ordrer for your file to persist in your container you must copy them to a docker file instead of copying them to your container 
 since the layer in the container is temporary but the layers in docker images are read only and they are persistent.


 59.turn a container into an image with one command
 ---------------------------------------------------
 in this video we are going to learn how to turn a container into an image, so basically we are just taking the current state 
 for running container and we will convert that into a new image that we can reuse in the future.
 there is something important here and its that you need to rememer that a container is nothing else but a read and write layer a temporary layer 
 and if you create some files in that layer and you delete that container then you re done you get another job.

 all of the information that you persist is the information or the configuration that is defined in the docker file or in the image itself.
 so lets just try this and see how it works.

 we are going to create a new container using apache, so you know we are going to say normal things........

 mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images$ docker run -d -p 8080:80 --name test httpd
now say that you want to go inside of this container  and modify the index.html that is inside the htdocs folder 

 mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images$  docker exec -ti test bash
root@f83dcad0d180:/usr/local/apache2#

if you want to modify this and want to change the content you can do it like this 

root@f83dcad0d180:/usr/local/apache2# echo eisai megalh paixtoura > htdocs/index.html
root@f83dcad0d180:/usr/local/apache2# cat htdocs/index.html 
echo eisai megalh paixtoura
root@f83dcad0d180:/usr/local/apache2#

so now if we refresh the browser we will the "eisai megalh paixtoura" message since the web server is serving the index.html file
so if you see we made a modification inside the containers and outside of our dockerfile i mean this modification is not in the dockerfile 
swo if we remove this container then this modification will be gone
so lets create a file inside the opt folder of the container via "touch /opt/test1"

root@f83dcad0d180:/usr/local/apache2# touch /opt/test1
root@f83dcad0d180:/usr/local/apache2# ls /opt/
test1
root@f83dcad0d180:/usr/local/apache2#

so now we have two changes the first one is the hello change and the second one is the test1 file that we have created so if you exit the container and remove it 
and you recreate it the same container with the same name and generally all the same and you are going to search about your two changes above 
then you are not gonna find them and
if you hit refresh on the browser then you will see that the configuration that is defined in the image is reapplied 
because when you craeted a container you are basically creating a container based on the image 
so the state of the container will be taken from the image.

now that we know this.....how can we turn a container into an image so that we can reuse it in the future ?  
well.....lets take a look at that......lets remove everyrthing 
and lets create a new container that uses centos and remember centos hasn't  a bash CMD so we need to pass thd -ti (to ask for an interactive terminal) 
flag with the view to keep it alive  and then we just say --name cento and the pass the centos image

 mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images$ docker run -dti -p 8080:80 --name centos centos

now if you hit docker ps you see that your container is up and running and if you just go inside of that container you can do anything you want to do
but in this case we want o create two files 

 mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images$ docker exex -ti centos bash
 [root@972ff88f90c3 /]#

 so we want to go inside the opt folder and we want to create one file 
  [root@972ff88f90c3 /]# cd /opt/
                           create content..file of this folder
  [root@972ff88f90c3 opt]# echo FILE1 > file1.txt

  now if you see in this location---opt we have one new file which is file1 and its content if FILE1

  so in the same foder we want to create a directory called test directory and inside of this directory we want to create a file 2 

  [root@972ff88f90c3 opt]# mkdir test_dir
  [root@972ff88f90c3 opt]# ls
  file1.txt test_dir 
  [root@972ff88f90c3 opt]# echo FILE2 > test_dir/file2.txt
  [root@972ff88f90c3 opt]# cd test_dir/
  [root@972ff88f90c3 test_dir]# ls
  file2.txt
  [root@972ff88f90c3 test_dir]#

  to rename a file use the mv command and see below 
  [root@972ff88f90c3 test_dir]# mv file2.tx file2.txt

so if you see all of the things that i did are under the opt directory and these modifications are not in any docker file that means if i delete the container
the go for you know.....

[root@972ff88f90c3 test_dir]# pwd
/opt/test_dir
[root@972ff88f90c3 test_dir]#

so now lets say that you want to capture the curent status of you container anhd turn it into an image with the view to have all the information of above into an image 
and this tecnique will keep your infos into a persistent state so as you can reuse it in the future as many times as you want to create new containers.....
so how do we do this?
well we exit of this container and make sure that our container is running 

 mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images$  docker ps.......yes it is running xaxaxaxxa
 so now you must make sure which container you want to backup 
 so we need to use the "docker commit" command and with docker commit you provide the container's id or name and then you pass the name of the final image 
 i.e. for your resultant image and even you can give it a tag 
 for example :
  
  mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images$ docker commit centos finalcentosimage:v1

so if you hit enter what happens is that docker creates a snapshot of of the current state of your container and turns it into a new image 
so now if you type "docker images | grep finalcentosimage:v1 " you understand that you are  a liitle piece of kolokithia toumpana as the name is "finalcentosimage"
and not  "finalcentosimage:v1", so now you get your final image that contains all the changes that we manually apply (231MB) 

.......finalcentosimage   v1 27abc9dadd4a 2 minutes ago 231MB............

so now what we are going to do is to delete our running container 

mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images$  docker rm -f centos 

and now in order to retrieve or to launch a new container which contains all of the information that we save previously we need to use the image  "finalcentosimage"
from the container that we delete.....
so "finalcentosimage" will have all the configuration i.e. will contain the current state of this container so lets just copy this name and try to create a new container

so we are going to say docker run -dti --name test (provide our image) finalcentosimage:v1 
 
 mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images$   docker run -dti --name test finalcentosimage:v1

and if you hit enter you will see your container up and running, and if you go inside of that container you will see all of your files and all of your configurations
that you did on the previous container 

 mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images$ docker exec -ti test bash
 [root@174a7b79512f /]#pwd
 /
 [root@174a7b79512f /]#ls
 bin  dev  etc  home  lib  lib64  lost+found  media mnt  opt  proc  root  run  sbin srv sys tmp  usr var
  [root@174a7b79512f /]# cd /opt/
  file1.txt test_dir
   [root@174a7b79512f opt]# cat file1.txt 
   FILE1
 [root@174a7b79512f opt]# cd test_dir
 [root@174a7b79512f test_dir]# ls
 file2.txt  
[root@174a7b79512f test_dir]# cat file2.txt
FILE1


and if you exit of this container you then can create as many containers as yiu want on this image finalcentosimage...test1 test3 and so on 
and all of these containres will have the same information that we retrieved from the previous container once ypou created the image 

so here you learn how to create images from a running container 

60.tip: override the cmd when running a container
-------------------------------------------------
in this video we are going to see how to override the cmd in a container without using dockerfile
ok 
for example you create a docker container using the centos image, you know that the centos image by default doesn't have any valid 
cmd and for that we add the -ti flag otherwise your container is going to exit immediately 

 mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images$ docker run -dti --name centos centos:7 

 ifn you do this you will have a container running  centos and the bin/bash command, now say that you want to override the 
 command when you are running your container, but remember that the cmd that you are going to apply should be able to live in foreground mode 
so lets get inside of this container, 

and in centos:7 we have python and in python we have a kill model which is called "simpleHttpServer" and then we can 
provide a port for example 8080, now if we hit enter we basically create a super tiny web server which is serving the files in the current directory 
Serving HTTP on 0.0.0.0 port 8080

 mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images$ docker exec -ti centos bash 
 [root@7eb76a498d65 /]# python -m SimpleHTTPServer 8080
 Serving HTTP on 0.0.0.0 port 8080 ...
 [root@7eb76a498d65 /]#

 but if you see this line : python -m SimpleHTTPServer 8080, keeps the service in foreground mode...if you want to kill type ctrl+c
 now say that you want to put this : python -m SimpleHTTPServer 8080 as your cmd but you dont want to put it in your dockerfile for some weird reason
 then how do you do it using docker run  ?
 well we are going to create another container but we are going to use a different name.......and you know normally the last argument when you create a 
 docker container is the image but its not that true because we can pass another argument and all the arguments that we can pass after the image will override the cmd 
 so for example if wew do the following :

now we dont the -ti flag as python -m SimpleHTTPServer 8080 plays ball now....
 mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images$ docker run -d --name centos centos:7 python -m SimpleHTTPServer 8080

 we dont need to use the -ti flag because this command python -m SimpleHTTPServer 8080 will keep the container alive 
 so if we hit enter and if we type docker ps you are going tom see that your new image is using the centos image  but now the cmd instruction is overidden by 
 this command python -m SimpleHTTPServer 8080  that you provided after the image so if you type "docker ps --no-trunk" in order to see the whole command you 
 see the exact command 

 so lets create a new container but now we will expose the port 9090 and we are going to point it on port 8080 because remember that we are running this service 
 python -m SimpleHTTPServer 8080 on port 8080 so we will map the port 9090 of our machine to the port 8080 o the container  

 mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images$ docker run -d --name ccentos -p 9090:8080 centos:7 python -m SimpleHTTPServer 8080

 now if we hit enter we are going to see that our container will be executing the command  "python -m SimpleHTTPServer 8080"
 and it will be listening on port 9090 and that is going to be mapped on port 8080 and remember that this command 
 "python -m SimpleHTTPServer 8080" will create a service on port 8080 and this can be reassured but giving the command : docker ps --no-trunc

 so now if we go to our ip address or localhost and we look for the port 9090 on the browser you see that you have a tiny web server which is serving 
some folders that are taken from the container 
so if you go to your terminal and you type docker ps then you see that you didn't modify any docker file but you where able to  change the command 
so probably you will find it useful in the future 
for now just keep your dockerfile as usual 
but if you need to do this you know now 


61.More tips: Destroy containers automatically
----------------------------------------------
helloo good morning hi......in this lesson we are going to learn how to destroy a container automatically 
after we exit out of the container, so say that you are viewed in a docker image or say that you want to create a temporary container to 
check some things.....
so for example say that you are creating a new image and you are downloading some files or doing some stuff and you need to to go inside image to validate some things 
but to go inside of the image you need to create a temporary container, so say that you want to go inside of centos image......you can do this with any image 
you want to go take a look at what is in this /opt folder and then you want to destroy the container, 
so how can you do that ?
well you can do.......docker run --rm (and rm means that your container will be destrouyed after you exit out of that container), 
so docker run --rm -ti to give you an interactive terminal then you say centos and you hit bash 
docker run --rm -ti centos bash and when you hit enter you are inside of temporary container and you can check all the things that you need to check....
for example, 
you need to take a look at the tmp folder (ls /tmp/)
and then by typing exit the container will be destroyed and this can be reassured if you type docker ps or even docker ps -a 
(which means that you dont have that container even in the stop ones)
so basically they just created a new container, a temporary container you can go inside of it and once you exit that container is automatically removed.
so what is this useful for ?
lets say that we are going to fill a new image so lets go to our docker images folder and create a dockerfile inside the docker commit folder 
and spread the known words 

please centos     : from centos:7
create a new file : run fallocate -l 10m /opt/test1
called test1 of 
10 mb to opt 
folder 

say that you want to buidl this image : docker build -t test1 . 


 mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images/dockercommit$ docker build -t test1 . 

succesfuly build.....
so now that you make thhis new image and you want to take a look if this file (/opt/test1) is created
so you can do something like this below :

mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images/dockercommit$ docker run --rm -ti test1 bash
[root@0572717d93cd /]#

and then you can just go to the opt and check the files there with "ls" to find out that there is......and then chec its details with "du -shc *"
and see that everything goes as expected 

[root@0572717d93cd /]# cd /opt/
[root@0572717d93cd /]# ls 
test1[root@0572717d93cd /]# du -shc *
10M  test1
10M  total
test1[root@0572717d93cd /]#

now i exit of my container and then this container is automatically removed
so this might be useful if you downloading some files from the internet and you want to check the path or to check how the files are being downloaded 
or you want to check what happens after you extract or after you unzip some files in your file that is super useful to debug when you are building images or when you use 
one to run something temporary.

this is it for this video.......
you already know how to create a container and how to destroy it automatically after you exit it out of it 


62.just one more tip: change the docker root directory
-------------------------------------------------------

hello and welcome back in this lesson we are going to learn where the images 
                                                            where the containers
                                                        and where all the docker stuff saved
and we are going to learn how to change the location so that docker can save the files in some other location well let me explain what i mean  
if you type " docker info "  which is a command that gives you informations about  your installation and then you grep for root 

mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images/dockercommit$ docker info | grep -i root 

you will see that you are going to find something that is called " Docker Root Dir:    /var/lib/docker " 
and by default the path when you are using linux will be  /var/lib/docker

but say that for example you have a lot of docker containers....you are having a lot of docker images 
and you create a new disk and you mount your new disk 
for exammple at opt folder or ls /opt/ 
for example at mnt  ls /mnt/
you mount your new disk which has i don't know about 100 gigabytes and you want to dedicate that for docker images and for docker containers 
well you have to know that in this folder /var/lib/docker you have all of the docker stuff 
so if you take a loom at the size of the /var/lib/docker ( sudo du -sh /var/lib/docker) well it might take a while as it is huge and inside of 
/var/lib/docker we have all of the docker stuff 

mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images/dockercommit$  sudo du -sh /var/lib/docker
2.2.G /var/lib/docker


so if we go inside of this folder with.......cd /var/lib/docker


mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images/dockercommit$ cd  /var/lib/docker
bash: cd: /var/lib/docker: permission denied......yes because we are not super user which is achieved with sudo su, then with ll we are 
able to see the entire structure of docker and you realize that docker saves all the :
builders, buildkit, containers, image, network and so on even and swarms........in the home folder " /var/lib/docker "
so here is where docker saves all of the things that he needs, 
so now remember that you wanted to mount a new disk dedicated for docker and you mopunted that disc in this /mnt/ (ls /mnt/ ) 
because you have a lot of space in this mnt folder and at the same time you are running out of space in /var/lib/docker 
and you want to move all of your configurations from this folder (/var/lib/docker ) to this mount folder...../mnt/

well first lets make sure that you have all your containers stopped or removed 
secondly we are goping to stop the docker service by typing "sudo systemctl stop docker" 
and the third thing that we are going to do is to modify one file at /lib/systemd/system/docker.service


mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images/dockercommit$ sudo vi /lib/systemcd/system/docker.service

and in this file we have all of the configurations, all of the default configurations and in the line below 

ExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock

we are going to add a new argument which is going to be the "--data-root" and here you can provide the new path
for data in docker 
so you can say : /mnt/docker.........."--data-root /mnt/docker"
e.g. 
ExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock --data-root /mnt/docker

ok lets save this by typing..........




-------------------------------------------------------------------------------------------------------------------------------------------------
i install docker again..........
Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?
which means that docker service is not running.....


mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images/dockercommit$ clear

mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images/dockercommit$ service docker status
 docker.service
   Loaded: error (Reason: Invalid argument)
   Active: inactive (dead)..............................................active: inactive

Mar 15 08:01:38 mike-VirtualBox systemd[1]: docker.service: Service lacks both ExecStart= and ExecStop= setting. Refusing.
Mar 15 08:02:34 mike-VirtualBox systemd[1]: docker.service: Service lacks both ExecStart= and ExecStop= setting. Refusing.
Mar 15 08:02:44 mike-VirtualBox systemd[1]: docker.service: Service lacks both ExecStart= and ExecStop= setting. Refusing.
Mar 15 08:02:51 mike-VirtualBox systemd[1]: docker.service: Service lacks both ExecStart= and ExecStop= setting. Refusing.
mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images/dockercommit$



Failed to start docker.service: Unit docker.service is not loaded properly: Invalid argument.
See system logs and 'systemctl status docker.service' for details.

-------------------------------------------------------------------------------------------------------------------------------------------------







mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images/dockercommit$ sudo su 
root@mike-virtualBox:/home/mike/Desktop/realstuff/realstuff1/multistage/docker-images/dockercommit# cd  /var/lib/docker
root@mike-virtualBox: /var/lib/docker# ll
total 60
drwx--x--- 13  root root  4096 Mar 15 03:48 ./
drwxr-xr-x 70  root root  4096 Mar 10 07:39 ../
drwx--x--x  4 root root  4096 Mar  1 05:47 buildkit/
drwx--x---  6 root root  4096 Mar 15 05:04 containers/
drwx------  3 root root  4096 Mar  1 05:47 image/
drwxr-x---  3 root root  4096 Mar  1 05:47 network/
drwx--x--- 15 root root 12288 Mar 15 05:04 overlay2/
drwx------  4 root root  4096 Mar  1 05:47 plugins/
drwx------  2 root root  4096 Mar 15 03:48 runtimes/
drwx------  2 root root  4096 Mar  1 05:47 swarm/
drwx------  2 root root  4096 Mar 15 04:51 tmp/
drwx------  2 root root  4096 Mar  1 05:47 trust/
drwx-----x 17 root root  4096 Mar 15 03:48 volumes/
root@mike-VirtualBox:/var/lib/docker#





****after a lot of mistakes we perform sudo su in order to enter to the root directory  

mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images/dockercommit$ sudo su
root@mike-virtualBox:/home/mike/Desktop/realstuff/realstuff1/multistage/docker-images/dockercommit#

root@mike-virtualBox:/home/mike/Desktop/realstuff/realstuff1/multistage/docker-images/dockercommit# cd  /var/lib/docker
root@mike-virtualBox: /var/lib/docker# ll
total 60
drwx--x--- 13  root root  4096 Mar 15 03:48 ./
drwxr-xr-x 70  root root  4096 Mar 10 07:39 ../
drwx--x--x  4 root root  4096 Mar  1 05:47 buildkit/
drwx--x---  6 root root  4096 Mar 15 05:04 containers/
drwx------  3 root root  4096 Mar  1 05:47 image/
drwxr-x---  3 root root  4096 Mar  1 05:47 network/
drwx--x--- 15 root root 12288 Mar 15 05:04 overlay2/
drwx------  4 root root  4096 Mar  1 05:47 plugins/
drwx------  2 root root  4096 Mar 15 03:48 runtimes/
drwx------  2 root root  4096 Mar  1 05:47 swarm/
drwx------  2 root root  4096 Mar 15 04:51 tmp/
drwx------  2 root root  4096 Mar  1 05:47 trust/
drwx-----x 17 root root  4096 Mar 15 03:48 volumes/
root@mike-VirtualBox:/var/lib/docker#
root@mike-VirtualBox:/var/lib/docker# ls /mnt/



well first lets make sure that you have all your containers stopped or removed 
secondly we are goping to stop the docker service by typing "sudo systemctl stop docker" 
and the third thing that we are going to do is to modify one file at /lib/systemd/system/docker.service


mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images/dockercommit$ sudo vi /lib/systemcd/system/docker.service

and in this file we have all of the configurations, all of the default configurations and in the line below 

ExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock

we are going to add a new argument which is going to be the "--data-root" and here you can provide the new path
for data in docker 
so you can say : /mnt/docker.........."--data-root /mnt/docker"
e.g. 
ExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock --data-root /mnt/docker

ok lets save this by typing 


root@mike-VirtualBox:/var/lib/docker# sudo systemctl stop docker
warning stopping docker.service, but it can still be activated by: docker.socket
root@mike-VirtualBox:/var/lib/docker#

root@mike-VirtualBox:/var/lib/docker# sudo vi /lib/systemd/system/docker.service

E325: ATTENTION
Found a swap file by the name "/lib/systemd/system/.docker.service.swp"
          owned by: root   dated: Tue Mar 15 06:44:04 2022
         file name: /lib/systemd/system/docker.service
          modified: YES
         user name: root   host name: mike-VirtualBox
        process ID: 6649
While opening file "/lib/systemd/system/docker.service"
             dated: Thu Mar 10 09:05:41 2022

(1) Another program may be editing the same file.  If this is the case,
    be careful not to end up with two different instances of the same
    file when making changes.  Quit, or continue with caution.
(2) An edit session for this file crashed.
    If this is the case, use ":recover" or "vim -r /lib/systemd/system/docker.service"
    to recover the changes (see ":help recovery").
    If you did this already, delete the swap file "/lib/systemd/system/.docker.service.swp"
    to avoid this message.
"/lib/systemd/system/docker.service" 47 lines, 1709 characters
Press ENTER or type command to continue


from the text below what we modify is the line below: 
ExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock
in which we add a new argument which is called  --data-root and in here we can provide the path for the data in docker e.g.
ExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock --data-root /mnt/docker

i was not able to write in it so play with copy and paste then :wq to save it, so we move on



-------------------------------------------------

[Unit]
Description=Docker Application Container Engine
Documentation=https://docs.docker.com
After=network-online.target docker.socket firewalld.service containerd.service
Wants=network-online.target
Requires=docker.socket containerd.service

[Service]
Type=notify
# the default is not to use systemd for cgroups because the delegate issues still
# exists and systemd currently does not support the cgroup feature set required
# for containers run by docker
ExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock
ExecReload=/bin/kill -s HUP $MAINPID
TimeoutSec=0
RestartSec=2
Restart=always

# Note that StartLimit* options were moved from "Service" to "Unit" in systemd 229.
# Both the old, and new location are accepted by systemd 229 and up, so using the old location
# to make them work for either version of systemd.
StartLimitBurst=3

# Note that StartLimitInterval was renamed to StartLimitIntervalSec in systemd 230.
# Both the old, and new name are accepted by systemd 230 and up, so using the old name to make
# this option work for either version of systemd.
StartLimitInterval=60s

# Having non-zero Limit*s causes performance problems due to accounting overhead
# in the kernel. We recommend using cgroups to do container-local accounting.
LimitNOFILE=infinity
LimitNPROC=infinity
LimitCORE=infinity

# Comment TasksMax if your systemd version does not support it.
# Only systemd 226 and above support this option.
TasksMax=infinity

# set delegate yes so that systemd does not reset the cgroups of docker containers
Delegate=yes

# kill only the docker process, not all processes in the cgroup
KillMode=process
OOMScoreAdjust=-500

[Install]
WantedBy=multi-user.target

-------------------------------------------------



root@mike-VirtualBox:/var/lib/docker# sudo vi /lib/systemd/system/docker.service

now we can restart the docker service but first you need to do sudo mapes as we are in the root and we don't need sudo 
we can type systemctl daemon.reload(= and this is basically to inform the systemd that we modify before)
and then we are going to restart the service 

root@mike-VirtualBox:/var/lib/docker#  systemctl daemon-reload
root@mike-VirtualBox:/var/lib/docker#  systemctl restart docker

and now if you type docker info | grep -i root you will get your new directory is at mount docker (alla epeidh eisai gkantemhs tha to deis sth thrakh)
no all good.......
root@mike-VirtualBox:/var/lib/docker#  docker info | grep -i root
warning no swap limit support
Docker Root Dir: /mnt/docker
root@mike-VirtualBox:/var/lib/docker# 

now if you type docker ps well....you dont have your container and the same goes for images 

root@mike-VirtualBox:/var/lib/docker# docker ps
CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES
root@mike-VirtualBox:/var/lib/docker# docker images
REPOSITORY   TAG       IMAGE ID   CREATED   SIZE
root@mike-VirtualBox:/var/lib/docker#

but wait i have a lot of images and i have a lot of containers where are those containers ? 
well what happened here is that you created a new folder for docker  but you didn't move the previous contents to the new folder 
so if you see the size of your current folder via ......du -sh /mnt/docker/..... you will see that is supersmall and this is because 
all of the configurations is still living in the /var/lib/docker

root@mike-VirtualBox:/var/lib/docker# ls /mnt/docker/
buildkit  containers image network overlay2 plugins  runtimes swarm tmp trust volumes


root@mike-VirtualBox:/var/lib/docker# du -sh 244K /mnt/docker/
root@mike-VirtualBox:/var/lib/docker# du -sh /var/lib/docker
2.2 G  /var/lib/docker

so basically you need to move this directory (/var/lib/docker) to this directory (/mnt/docker/)
in order to keep all of your images and your containers so lets do that.....so lets stop the docker service again 
and remember we will go to the /var/libdocker and basically we want to move the docker folder 
so lets remove the folder that we have in ...mnt... folder.....the docker folder

root@mike-VirtualBox:/var/lib/docker# systemctl stop docker 
root@mike-VirtualBox:/var/lib/docker#  cd /var/lib/docker
root@mike-VirtualBox:/var/lib/docker#  ll
total 60
drwx--x--- 13  root root  4096 Mar 15 03:48 ./
drwxr-xr-x 70  root root  4096 Mar 10 07:39 ../
drwx--x--x  4 root root  4096 Mar  1 05:47 buildkit/
drwx--x---  6 root root  4096 Mar 15 05:04 containers/
drwx------  3 root root  4096 Mar  1 05:47 image/
drwxr-x---  3 root root  4096 Mar  1 05:47 network/
drwx--x--- 15 root root 12288 Mar 15 05:04 overlay2/
drwx------  4 root root  4096 Mar  1 05:47 plugins/
drwx------  2 root root  4096 Mar 15 03:48 runtimes/
drwx------  2 root root  4096 Mar  1 05:47 swarm/
drwx------  2 root root  4096 Mar 15 04:51 tmp/
drwx------  2 root root  4096 Mar  1 05:47 trust/
drwx-----x 17 root root  4096 Mar 15 03:48 volumes/
root@mike-VirtualBox:/var/lib/docker#


and basically we want to move the docker folder which is one level back 
root@mike-VirtualBox:/var/lib/docker# cd ..
root@mike-VirtualBox:/var/lib# ll
total 280
drwxr-xr-x 70 root          root          4096 Mar 10 07:39 ./
drwxr-xr-x 14 root          root          4096 Apr 26  2018 ../
drwxr-xr-x  4 root          root          4096 Apr 26  2018 AccountsService/
drwxr-xr-x  2 root          root          4096 Apr 30  2013 acpi-support/
drwxr-xr-x  2 root          root          4096 Feb 15  2017 alsa/
drwxr-xr-x  4 root          root          4096 Mar 15 08:24 app-info/
drwxr-xr-x  3 root          root          4096 Mar  1 05:03 apport/
drwxr-xr-x  5 root          root          4096 Mar 15 08:26 apt/
drwxr-xr-x  2 root          root          4096 Apr 26  2018 aspell/
drwxr-xr-x  2 avahi-autoipd avahi-autoipd 4096 Apr 26  2018 avahi-autoipd/
drwxr-xr-x  2 root          root          4096 Feb 21  2018 bluetooth/
drwxr-xr-x  2 root          root          4096 Mar 27  2018 boltd/
drwxr-xr-x  4 colord        colord        4096 Mar  1 04:37 colord/
drwxr-xr-x  2 root          root          4096 Apr 23  2018 command-not-found/
drwx--x--x 11 root          root          4096 Mar  1 05:47 containerd/
drwxr-xr-x  2 root          root          4096 Mar  1 04:36 dbus/
drwxr-xr-x  2 root          root          4096 Apr 16  2018 dhcp/
drwxr-xr-x  4 root          root          4096 Apr 26  2018 dictionaries-common/
drwxr-xr-x  3 root          root          4096 Mar  1 05:11 dkms/

drwx--x--- 13 root          root          4096 Mar 15 08:26 docker/

drwxr-xr-x  7 root          root          4096 Mar 15 08:26 dpkg/
drwxr-xr-x  3 root          root          4096 Apr 26  2018 emacsen-common/
drwxr-xr-x  5 root          root          4096 Mar  1 05:00 fwupd/
drwxr-xr-x  6 gdm           gdm           4096 Mar 15 07:45 gdm3/
drwxr-xr-x  3 geoclue       geoclue       4096 Mar  1 04:37 geoclue/
drwxr-xr-x  4 root          root          4096 Apr 26  2018 ghostscript/
drwxr-xr-x  2 root          root          4096 Sep  9  2021 git/
drwxr-xr-x  3 root          root          4096 Mar  1 04:56 grub/
drwxr-xr-x  2 root          root          4096 Mar  7  2018 hp/
drwxr-xr-x  2 root          root          4096 Mar 10 06:47 initramfs-tools/
drwxr-xr-x  2 root          root          4096 Apr 26  2018 ispell/
drwxr-xr-x  3 root          root          4096 Apr 26  2018 libreoffice/
drwxr-xr-x  3 root          root          4096 Apr 26  2018 libxml-sax-perl/
drwxr-xr-x  3 root          root          4096 Apr 26  2018 locales/
drwxr-xr-x  2 root          root          4096 Mar 15 03:53 logrotate/
drwxr-xr-x  2 root          root          4096 Apr 26  2018 man-db/
drwxr-xr-x  2 root          root          4096 Apr 24  2018 misc/
drwxr-xr-x  2 root          root          4096 Mar 15 03:53 mlocate/
drwxr-xr-x  2 root          root          4096 Mar 15 07:51 NetworkManager/
drwxr-xr-x  2 root          root          4096 Mar  6  2017 os-prober/
drwxr-xr-x  2 root          root          4096 Mar 15 08:24 PackageKit/
drwxr-xr-x  2 root          root          4096 Mar  1 05:03 pam/
drwxr-xr-x  2 root          root          4096 Apr 12  2018 plymouth/
drwx------  3 root          root          4096 Apr 26  2018 polkit-1/
drwx------  3 root          root          4096 Mar  1 04:36 private/
drwxr-xr-x  2 root          root          4096 Mar 10 07:39 python/
drwxr-xr-x  2 root          root          4096 Mar 14  2018 rpm/
drwxr-xr-x 23 root          root          4096 Mar 15 07:44 snapd/
drwxr-xr-x  2 root          root          4096 Feb 20  2018 snmp/
drwxr-xr-x  3 root          root          4096 Apr 26  2018 sudo/
drwxr-xr-x  6 root          root          4096 Mar  1 04:36 systemd/
drwxrwxr-x  2 root          root          4096 Mar  1 04:20 ubiquity/
drwxr-xr-x  4 root          root          4096 Mar 15 04:08 ubuntu-advantage/
drwxr-xr-x  2 root          root          4096 Mar  1 04:36 ubuntu-drivers-common/
drwxr-xr-x  2 root          root          4096 Mar  1 05:04 ubuntu-release-upgrader/
drwxr-xr-x  3 root          root          4096 Mar  1 05:03 ucf/
drwx------  2 root          root          4096 Mar 15 07:45 udisks2/
drwxr-xr-x  2 root          root          4096 Feb 17  2020 unattended-upgrades/
drwxr-xr-x  2 root          root          4096 Mar  1 04:46 update-manager/
drwxr-xr-x  4 root          root          4096 Mar 15 08:26 update-notifier/
drwxr-xr-x  2 root          root          4096 Jan 30  2018 upower/
drwxr-xr-x  3 root          root          4096 Apr 26  2018 ureadahead/
drwxr-xr-x  2 root          root          4096 Mar  6  2018 usb_modeswitch/
drwxr-xr-x  2 root          root          4096 Apr 26  2018 usbutils/
drwxr-xr-x  2 root          root          4096 Mar 15 07:44 VBoxGuestAdditions/
drwxr-xr-x  3 root          root          4096 Apr 26  2018 vim/
drwxr-xr-x  2 root          root          4096 Mar 15 07:44 whoopsie/
drwxr-xr-x  2 root          root          4096 Apr 26  2018 xfonts/
drwxr-xr-x  2 root          root          4096 Mar  1 04:56 xkb/
drwxr-xr-x  2 root          root          4096 Mar 10 07:40 yum/
root@mike-VirtualBox:/var/lib#
 

and basically lets remove the folder that we have in mount 
root@mike-VirtualBox:/var/lib# rm -rf /mnt/docker/
and now in mnt we have nothing.......ls /mnt/

now we want to move the docker folder that exists in lib folder to mnt folder
root@mike-VirtualBox:/var/lib# mv docker /mnt/
now you move it, which means that in /var/lib you have no longer the docker directory, but if you go to mnt (ls /mnt/) you will see your docker directory 
and if you list the files inside that directory  (ls /mnt/docker) you will see all of your previous configurations  which is super nice
root@mike-VirtualBox:/var/lib# ls 
root@mike-VirtualBox:/var/lib# pwd 
/var/lib
root@mike-VirtualBox:/var/lib# ls /mnt/
docker
root@mike-VirtualBox:/var/lib# ls /mnt/docker/
buildkit  containers  image  network  overlay2  plugins  runtimes  swarm  tmp  trust  volumes
root@mike-VirtualBox:/var/lib#

now we want to restart the docker service for these changes to take effect so lets type systemctl restart docker 
and now docker should take these new configuration because we define the root as mnt/docker   
and now if you type docker images you are going to see all the images that you created 

root@mike-VirtualBox:/var/lib#  systemctl restart docker 
root@mike-VirtualBox:/var/lib#  docker images 
root@mike-VirtualBox:/var/lib# docker images

REPOSITORY         TAG       IMAGE ID       CREATED        SIZE
test1              latest    5a0c19cd10c8   6 hours ago    214MB
finalcentosimage   v1        27abc9dadd4a   26 hours ago   231MB
centos             7         eeb6ee3f44bd   6 months ago   204MB
centos             latest    5d0da3dc9764   6 months ago   231MB
root@mike-VirtualBox:/var/lib# cd mnt
bash: cd: mnt: No such file or directory
root@mike-VirtualBox:/var/lib# cd /mnt/
root@mike-VirtualBox:/mnt# docker images
REPOSITORY         TAG       IMAGE ID       CREATED        SIZE
test1              latest    5a0c19cd10c8   6 hours ago    214MB
finalcentosimage   v1        27abc9dadd4a   26 hours ago   231MB
centos             7         eeb6ee3f44bd   6 months ago   204MB
centos             latest    5d0da3dc9764   6 months ago   231MB
root@mike-VirtualBox:/mnt#


and now if you type docker info | grep -i root you will see your new home for docker is at mnt/docker and you saved all your configurations 
all your images from the previous directory you moved it and you  configured it into a new directory 

root@mike-VirtualBox:/mnt# docker info | grep -i root
Docker Root Dir: /mnt/docker
root@mike-VirtualBox:/mnt#


root@mike-VirtualBox:/mnt# cd ..
root@mike-VirtualBox:/# ls
bin  boot  cdrom  dev  etc  home  initrd.img  initrd.img.old  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  snap  srv  swapfile  sys  tmp  usr  var  vmlinuz  vmlinuz.old
root@mike-VirtualBox:/# ll
total 2097264
drwxr-xr-x  24 root root       4096 Mar  9 06:35 ./
drwxr-xr-x  24 root root       4096 Mar  9 06:35 ../
drwxr-xr-x   2 root root       4096 Mar  1 05:01 bin/
drwxr-xr-x   3 root root       4096 Mar 10 06:47 boot/
drwxrwxr-x   2 root root       4096 Mar  1 04:11 cdrom/
drwxr-xr-x  18 root root       4160 Mar 15 07:44 dev/
drwxr-xr-x 130 root root      12288 Mar 15 07:45 etc/
drwxr-xr-x   3 root root       4096 Mar  1 04:14 home/
lrwxrwxrwx   1 root root         34 Mar  9 06:35 initrd.img -> boot/initrd.img-4.15.0-171-generic
lrwxrwxrwx   1 root root         34 Mar  9 06:35 initrd.img.old -> boot/initrd.img-4.15.0-169-generic
drwxr-xr-x  21 root root       4096 Mar  1 04:21 lib/
drwxr-xr-x   2 root root       4096 Mar  2 06:20 lib64/
drwx------   2 root root      16384 Mar  1 04:09 lost+found/
drwxr-xr-x   3 root root       4096 Mar  1 04:42 media/
drwxr-xr-x   3 root root       4096 Mar 15 10:24 mnt/
drwxr-xr-x   4 root root       4096 Mar  1 05:47 opt/
dr-xr-xr-x 253 root root          0 Mar 15 07:44 proc/
drwx------   5 root root       4096 Mar 15 06:04 root/
drwxr-xr-x  29 root root        900 Mar 15 10:49 run/
drwxr-xr-x   2 root root      12288 Mar 15 07:45 sbin/
drwxr-xr-x  17 root root       4096 Mar 10 07:56 snap/
drwxr-xr-x   2 root root       4096 Apr 26  2018 srv/
-rw-------   1 root root 2147483648 Mar  1 04:09 swapfile
dr-xr-xr-x  13 root root          0 Mar 15 07:44 sys/
drwxrwxrwt  14 root root       4096 Mar 15 10:27 tmp/
drwxr-xr-x  11 root root       4096 Mar  1 05:01 usr/
drwxr-xr-x  14 root root       4096 Apr 26  2018 var/
lrwxrwxrwx   1 root root         31 Mar  9 06:35 vmlinuz -> boot/vmlinuz-4.15.0-171-generic
lrwxrwxrwx   1 root root         31 Mar  9 06:35 vmlinuz.old -> boot/vmlinuz-4.15.0-169-generic
root@mike-VirtualBox:/#



63.check your knowledge
-----------------------
hello
the idea of this article is that you solve the following problem using what you have learned.
At work you have request to create a couple of containers.find the details below :

i.a container with apache and php image created in the previous exercise 
    50mb ram limits
    you can only access the cpu  0
    it must have two envirnmental variables: 
    ENV=env
    virtualization=docker
    the webserver must be accessible via port 5555 in the browser 
ii.a container with apache and php image created in the previous exercise 
    100mb ram limits
    you can  access  cpu  0 and 1
    you must have three envirnmental variables: 
    ENV=stg
    virtualization=docker
    the webserver must be accessible via port 8081 in the browser 

you should check its operation by entering your localhost 5555 and localhost 8081

have fun


quiz 3: feel comfortable with containers lets check it
------------------------------------------------------
Question 1:
Given the next line:

docker run -d -p 8080:80 --name haproxy haproxy

What's the container port?
80
Question 2:
What does the command docker ps -l return?
the last created container ........the first created container, containers with envirnmental variables

Question 3:
How would you limit a container to 100M in RAM?

docker run -d --set-memory-ram "10mb" -e "MYSQL_ROOT_PASSWORD=12345678" MYSQL
docker run -d --set-mem-ram "10mb" -e "MYSQL_ROOT_PASSWORD=12345678" MYSQL
docker run -d -m "10mb" -e "MYSQL_ROOT_PASSWORD=12345678" MYSQL-----------------------> this one
docker run -d --max-ram-allowed "10mb" -e "MYSQL_ROOT_PASSWORD=12345678" MYSQL

Question 4:
You have to create a mongo container. Its internal port is 27017, 
however, that port is already in use by other service in your host; so, 
you have to use the port 27018. What can you do?

-p 27017
not possible 
-p 27017:27018
-p 27018:27017-------->this one

Question 5:
You want to go inside a running container to check the /etc/shadow file, 
but you are having permission denied because the user in the container is not root. 
How would you login as root?
docker exec -ti -u root container-name bash-------->this one
docker exec -ti -u user_name container-name bash
docker exec -ti -u sudo container-name bash

Question 6:
There's a container named postgres. You want to copy a file at /var/log/postgres/postgres.log in 
the container to /opt/postgres.log in your Docker host. How can you do it?

docker cp /var/log/postgres/postgres.log postgres:/opt/postgres.log
docker cp postgres:/opt /var/log/postgres/postgres.log
docker cp postgres:/var/log/postgres/postgres.log /opt/postgres.log------->this one



What you should review


-What does the command docker ps -l return?
-You have to create a mongo container. Its internal port is 27017, however, 
that port is already in use by other service in your host; so, you have to use the port 27018. What can you do?
-You want to go inside a running container to check the /etc/shadow file, 
but you are having permission denied because the user in the container is not root. How would you login as root?
-There's a container named postgres. You want to copy a file at /var/log/postgres/postgres.log in the container 
to /opt/postgres.log in your Docker host. How can you do it?

7.Docker containers - learn how containers work in depth...........review

---------------------------------7.Docker containers - learn how containers work in depth-------------end


-----------------------------------------          -----------------------------------------
-----------------------------------------  review  -----------------------------------------
-----------------------------------------          -----------------------------------------

start----------------------------8.Docker Volumes - persist data in containers----------------
64.what is a docker volume ?
---------------------------
hello and welcome back, in this lesson we are going to learn about docker volumes, well 
indeed we are going to talk about volumes and you are going to learn what is a docker volume 
how to use a docker volume and why these volumes are important.
so now lets think about a container 
say that you want to create a mysql container as you want to store a database
so ok you create the container everything goes good, ut now you create some data 
i mean you create a database and then you can create some tables and then you can insert some data in those tables
but say then your container dies.......your container for some reason is terminated, 
then all you data that you created in the temporary layer of the container its going to be destroyed, 
so we need to find a way to persist that information after the container dies, 
so basically with a volume what you do is to save your information after your container dies, 
so say that in this example you want to persist the database that you created all of the information 
                                                                              all of the files that where inside of the container 
but once the container died all of those information were terminated, so you want to do that,
basically you want that if the container dies yo want some persistent data, so its like if your container dies it will not remove the information
so here it is where we create docker volumes 
so this is the introduction of this section i.e. you see what a docker volume is what it works for 
so remember the easiest way a docker volume is not else that a way to persist data in your host after a container dies 

65.why are volumes are so important ? lets check it using MYSQL
---------------------------------------------------------------
hello, in this lesson we are going to learn why docker volumes are so important and why you should use volumes for most of you containers
so now lets ay that you have a database but first we are going to create a docker container using mysql
its name the required environmental variable and the image 
if we hit enter and type docker ps we see our container up and runing so now lets go inside this container 
via docker exec and then we try to login with the technique below:
mysql -u root -p12345678 and yes we are in our service 




mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images/dockercommit$ 
 docker run -d --name mysql -e MYSQL_ROOT_PASSWORD=12345678 mysql:5.7

 mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images/dockercommit$ docker exec -ti 7d66a482d746 bash 
 root@7d66a482d746:/# mysql -u root -p12345678


mysql: [Warning] Using a password on the command line interface can be insecure.
Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 2
Server version: 5.7.37 MySQL Community Server (GPL)

Copyright (c) 2000, 2022, Oracle and/or its affiliates.

Oracle is a registered trademark of Oracle Corporation and/or its
affiliates. Other names may be trademarks of their respective
owners.

Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.

mysql>



now if we type show databases then you are going to see the default databases that are created in mysqg 
(that are created in my school..what school..)
so now lets go and create a new one 

mysql> create database testdb; 

and if you type "show databases;" you will see your new database 


now there is somthing important and say that you want to add some tables to this database and then you want to add some data to this tables 
and say that you have some important data after one day or two days and now imagine that your container dies 
what do you thing its gonna happen ?
thats it you get it all gone even if you recreate the same container with the same name and so on.....and you understand it 
by typing show databases 
remember that the container is a temporary layer that allows you to read and write 
but once you remove a container all of the information that you create inside of it its going to going 
so thats why we use volumes because with voloumes we can do some tricks to persist that data and we can save the information after 
the container dies 
and if we do that we wont lose any kind of data or information that is associated in a docker volume 
so in the next lesson we are going to see how to create a basic docker volume 
                                          how to map it to our host and 
                                          how to map that vloume to the container 
so that when the container dies our voloume will be untouched.


66.Bind volumes: Map folder to your container 
---------------------------------------------
hello and welcome back in this lesson we are going to learn about "bind volumes" and we learn how to map a volume to a container 
to avoid losing the information once the container dies, 
so in this case we will use the mysql container and we will try to save all of the information inside of that container so that we 
can make sure that the information is safe even if the container dies 

now we exited from our service and go to our container....and if you know a little bit about mysql then you know that mysql 
by default stores all of the information at "var/lib/mysql"
so this is the first important point about volumes, you need to understand which folder from the container you want to save
in this case all of the information in this container or at least the mysql information is saved in this folder 
"var/lib/mysql".......so if we go and remove this folder then all of the mysql and databases and information will be gone 
but you can tell me ok i didn't know the mysql is towaards the information at "var/lib/mysql"   
so remember that you can always go to the google.com and you can look for it 
and type docker mysql and in the image documentation you will find a section for volumes, so most of images will have a section 
for a volume...so you can just take a look at that and you will find out that 
what are the folders inside of that container that you need to save.......
so if we just scroll down and look for volumes or volume you are going to see that these guys show you some examples but 
search for /var/lib/mysql
and then boom it basically tells you that the directory inside of the container is the directory where mysql by default will write 
its data files 
so if you read a little bit you will find out that this directory inside of the container holds all of the information that you want to save 
so that good to know 
so now that you know that this directory "var/lib/mysql" contains all of the information that you need inside of the container lets go and remove 
this container as we wanted it for testing purposes but first lets get out from our container 

 root@7d66a482d746:/# exit
 mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images/dockercommit$ docker rm -f mysql 

 and now is where a new concept about volumes comes for you, 
 in this case we are going to craete a bind volume and that means that we are going to create a folder in our docker host 
 it means that your virtual machine or your host and we will create a folder somewhere (the location doesn't really matter)
 and then you will map that folder to the folder inside of the container,
 so lets do cd /mnt/  and we can create a new directory here that hears the name mysql 

 mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images/dockercommit$ cd /mnt/
 mike@mike-VirtualBox:/mnt$ ls
 docker
 mike@mike-VirtualBox:/mnt$ mkdir mysql
 mkdir: cannot create directory 'mysql': permission denied.....well thats because we didn't put sudo as we don't have permissions here 
 mike@mike-VirtualBox:/mnt$ sudo mkdir mysql.......and now if you type "ls -l" then you will see that you have a new directory here called mysql
  mike@mike-VirtualBox:/mnt$ ls -l
  total 8
  drwx--x--- 13 root root 4096 Mar 15 10:49 docker
  drwxr-xr-x  2 root root 4096 Mar 16 10:09 Mysql
   mike@mike-VirtualBox:/mnt$

   but tghe mysql directory is empty because of course it doesn't contain anything , 
   now what we want to do is that we want to create a new container, but in the creation of that container we will define a volume 
   and we will say ok docker please go to the corner and store all of the information for /var/lib/mysql in  the folder that we create above 
   i.e. the mysql folder 
   so the container will store all of the information here --> mysql and once this container dies all of the information that they contain 
   a road will be here (mysql)

   now lets go to create our container but firts we check if we have any running container.......not at all
   but before we create the container we need to go in that folder 
   because now we are in /mnt.......so cd mysql/ by typing pwd the terminal gives us the whole path
    mike@mike-VirtualBox:/mnt$ cd mysql/
    mike@mike-VirtualBox:/mnt/mysql$ pwd
    /mnt/mysql
    mike@mike-VirtualBox:/mnt/mysql$.....so here if we make "ls /mnt/mysql" the output will be nothing as there is nothing in there 

    so now we can look for the run instruction and now we will say -v which stands for volumes so we are telling docker that we want 
    create a new volume and first we provide the host path (ls /mnt/mysql) same thing as the port....you always provide first the host path and you 
    put a colon and then you put the location inside of the container that you want to save 
    in this case we want to say /var/lib/mysql 

    -v /mnt/mysql:/var/lib/mysql : so here we say hey docker please create a new volume on this location (/mnt/mysql)  
                                   and please map it to this folder "/var/lib/mysql" inside of the container 
                                   so basically everything that is created inside of the container in this folder will be reflected in 
                                   this folder in the host
                                   so once the container dies this folder "/var/lib/mysql" will be gone but you will have all of the information right 
                                   here "/mnt/mysql"....in your docker host folder 

 mike@mike-VirtualBox:/mnt/mysql$ docker run -d -v /mnt/mysql:/var/lib/mysql --name mysql -e "MYSQL_ROOT_PASSWORD=12345678" mysql:5.7

okay now lets hit enter and see what happens, so now if you type docker ps you will see your container running normally, it doesn't 
really affect anything 

mike@mike-VirtualBox:/mnt/mysql$ docker ps
CONTAINER ID   IMAGE       COMMAND                  CREATED          STATUS          PORTS                 NAMES
474ee64da171   mysql:5.7   "docker-entrypoint.s"   46 seconds ago   Up 45 seconds   3306/tcp, 33060/tcp   mysql
mike@mike-VirtualBox:/mnt/mysql$

and now lets go inside of the docker container by typing docker exec -ti mysql bash 
and then from there we are going to the mysql service using mysql -u root -p12345678
and we will create a new database just to test it 

mike@mike-VirtualBox:/mnt/mysql$   docker exec -ti mysql bash 
root@474ee64da171:/# mysql -u root -p12345678

mysql: [Warning] Using a password on the command line interface can be insecure.
Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 2
Server version: 5.7.37 MySQL Community Server (GPL)

Copyright (c) 2000, 2022, Oracle and/or its affiliates.

Oracle is a registered trademark of Oracle Corporation and/or its
affiliates. Other names may be trademarks of their respective
owners.

Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.

mysql> ^C
mysql>



so if we type "show databases;" we will see the default information and now we just create a new database 
mysql> create database testdb;
QUERY   OK, 1 row affected (0.00 sec)

and you hit enter then you are able to see your new database in the list with the default ones......
so now if we exit out of here and go out of the container and we just kill the container 

mysql> exit 
bye
root@474ee64da171:/# exit 
exit
mike@mike-VirtualBox:/mnt/mysql$ docker rm -f mysql........(name of our container from the previous docker ps)
mysql 
and now if you do docker ps you will see that the container is gone....but what happened to the folder?
remember that we mapped this folder "/mnt/mysql" to the docker container 
sooooooo, now if we go to this folder and we type ls /mnt/mysql
you are going to see that in this folder we have all of the configuration of the mysql and even we have our database 
the "testdb"

mike@mike-VirtualBox:/mnt/mysql$ pwd
/mnt/mysql
mike@mike-VirtualBox:/mnt/mysql$  ls
auto.cnf    ca.pem           client-key.pem  ibdata1      ib_logfile1  mysql               private_key.pem  server-cert.pem  sys
ca-key.pem  client-cert.pem  ib_buffer_pool  ib_logfile0  ibtmp1       performance_schema  public_key.pem   server-key.pem   testdb

i.e. here we have everything the container needs or at least everything that mysql needs to serve the mysql databases 
so thats yoy save information after the container dies 



so how do you restore this information in a brand new container, well thats a good question and basically youtype the same line 

mike@mike-VirtualBox:/mnt/mysql$ docker run -d -v /mnt/mysql:/var/lib/mysql --name mysql -e "MYSQL_ROOT_PASSWORD=12345678" mysql:5.7

or in other words 
please docker use this folder "/mnt/mysql" in my local machine and map that folder to /var/lib/mysql
so basically all of this information from above :

auto.cnf    ca.pem           client-key.pem  ibdata1      ib_logfile1  mysql               private_key.pem  server-cert.pem  sys
ca-key.pem  client-cert.pem  ib_buffer_pool  ib_logfile0  ibtmp1       performance_schema  public_key.pem   server-key.pem   testdb


will be mapped to this folder "/var/lib/mysql" inside of the container, 
so once the container start the information will already there because you are mapping the folder and this folder contains all of the information 
from the previous container, now if you hit enter and go inside of that container 


mike@mike-VirtualBox:/mnt/mysql$ docker exec -ti mysql  bash.....and the enter into the mysql service 
root@58a391e07394:/# mysql -u root -p12345678......and perform the usual...."show databases;"

then you will see your databases there that you made on the previous container 



mysql: [Warning] Using a password on the command line interface can be insecure.
Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 2
Server version: 5.7.37 MySQL Community Server (GPL)

Copyright (c) 2000, 2022, Oracle and/or its affiliates.

Oracle is a registered trademark of Oracle Corporation and/or its
affiliates. Other names may be trademarks of their respective
owners.

Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.

mysql> show databases;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| mysql              |
| performance_schema |
| sys                |
| testdb             |
+--------------------+
5 rows in set (0.00 sec)

mysql>


but using volumes you save these information in your local machine and then you created a new container and you mapped the information 
that was in your local machine 
and the result is that you can see your databases here using  mysql....and if you go to the directory in the container which is 
/var/lib/mysql
you will see that all of the information is here 


mysql> exit
Bye
root@58a391e07394:/# cd /var/lib/mysql
root@58a391e07394:/var/lib/mysql# ls
auto.cnf    ca.pem     client-key.pem  ib_logfile0  ibdata1  mysql       private_key.pem server-cert.pem  sys
ca-key.pem  client-cert.pem  ib_buffer_pool  ib_logfile1  ibtmp1   performance_schema  public_key.pem server-key.pem testdb
root@58a391e07394:/var/lib/mysql#



and one important thing to keep in mind is that if you create any file inside of the container or outside of the container 
it will reflected inside of the container and in the folder in the docker host 


so now if we create a file inside of the container with the name "testfile" inside "/var/lib/mysql" folder of course 
as this is the directory that we are mapping 

root@58a391e07394:/var/lib/mysql# touch testfile.....and now if we are go outside of the container and you type "ls"
                                                     in your docker host folder then you will see the file that you created 
                                                     inside of the containers abouut a minute ago 
root@58a391e07394:/var/lib/mysql# exit
exit 
mike@mike-VirtualBox:/mnt/mysql$ 


and any changes that you do here will impact the folder inside of the container and vice versa 
any changes that you do inside of this folder-container "/var/lib/mysql" will affect the external folder in your docker host 


root@58a391e07394:/var/lib/mysql# touch testfile
root@58a391e07394:/var/lib/mysql# ^C
root@58a391e07394:/var/lib/mysql# exit
exit
mike@mike-VirtualBox:/mnt/mysql$ ls
auto.cnf    ca.pem           client-key.pem  ibdata1      ib_logfile1  mysql               private_key.pem  server-cert.pem  sys     testfile
ca-key.pem  client-cert.pem  ib_buffer_pool  ib_logfile0  ibtmp1       performance_schema  public_key.pem   server-key.pem   testdb
mike@mike-VirtualBox:/mnt/mysql$




well this it for this video i hope that you gain a cleared understanding about what is a docker volume 
why its important and how it works 

67.normal volumes Manage your volumes with docker CLI
-----------------------------------------------------
hello and welcome back in this lesson we are going to learn about normal volumes from docker or just volumes
we have two big types of volumes 

i.bind volumes 
ii.normal volumes (or just volumes)

so basically a bind volume is basically what we saw in the previous lesson, its basically that you create a folder in your local machine 
and then you map that folder to your container 
and the second type is the one that we are going to see in this lesson...and that is a normall volume and basically a normal volume or volume  is 
managed by docker and you create one volume by typing "docker volume create (and then you provide a name for the volume) mysql and if you hit enter 
you see that the volume is created, 
now where is this volume located ?
now if you remember about the docker root ( docker info | grep -i root ) we will come here : "/mnt/docker" 
and then what we do is "sudo su" to be root users thus to have more abilities  


mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images/dockercommit$ docker volume create mysqlvolume
mysqlvolume
mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images/dockercommit$ docker info | grep -i root
WARNING: No swap limit support
 Docker Root Dir: /mnt/docker
mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images/dockercommit$ sudo su
[sudo] password for mike:
root@mike-VirtualBox:/home/mike/Desktop/realstuff/realstuff1/multistage/docker-images/dockercommit#

and then what we are going to do is to headed in that folder through cd /mnt/docker and perform an "ls" to see what is in there
and as i told you in previous lessons in this root directory docker stores all of it information for volumes,images,containers and all the things that we use


root@mike-VirtualBox:/mnt/docker# ls
buildkit  containers image network overlay2 plugins  runtimes swarm tmp trust volumes
root@mike-VirtualBox:/mnt/docker#

root@mike-VirtualBox:/mnt/docker# ll
total 60
drwx--x--- 13 root root  4096 Mar 15 10:49 ./
drwxr-xr-x  4 root root  4096 Mar 16 10:09 ../
drwx--x--x  4 root root  4096 Mar  1 05:47 buildkit/
drwx--x---  3 root root  4096 Mar 16 11:51 containers/
drwx------  3 root root  4096 Mar  1 05:47 image/
drwxr-x---  3 root root  4096 Mar  1 05:47 network/
drwx--x--- 20 root root 12288 Mar 16 11:51 overlay2/
drwx------  4 root root  4096 Mar  1 05:47 plugins/
drwx------  2 root root  4096 Mar 15 10:49 runtimes/
drwx------  2 root root  4096 Mar  1 05:47 swarm/
drwx------  2 root root  4096 Mar 16 08:10 tmp/
drwx------  2 root root  4096 Mar  1 05:47 trust/
drwx-----x 19 root root  4096 Mar 17 06:50 volumes/
root@mike-VirtualBox:/mnt/docker# ^C
root@mike-VirtualBox:/mnt/docker#


so as it is shown above the volumes are stored in the obvious folder above, so there is nothing left to do but to go in the volumes folder 
and in there we are going to see via the ll command except the volumes that we have create we also going to see also anonymous volumes 
but we will take a look at this in the future


root@mike-VirtualBox:/mnt/docker# cd volumes
root@mike-VirtualBox:/mnt/docker/volumes# ls
373599e0ecc27fc4436eb868a0e9a72c1330ec4aae3e0447d7824bb1ac9159b6  86e5653c9c266d482a3e3e9ff4d1028f0bcfd1a8230578c678ea9695f20b73ed  da001e7ec562b0f9427a98ccabfe821be44dda174b47b0000345091e9e65a995
42aabbb36c2ffefeec8385004e5a83c594edcb26ca5cb95322ebc4045e46f39f  8e0a978b1544cd102ed2bf97f9f0a8038aeae1bf05eb82cea104c3a341edc787  e8daa84764964e25f424bafa2cf06403cf378be458c035e27eadf67b3fdf2da9
63dca3e7164cd0f3196467d78fdd780bc852ac990da27a25e4d7328884b590ca  8e89f71d6bce419df0db2980708f3d918edfd1d8ff4a867feb3866efc18e312f  faf88f3fbb5fdd95c43bb000975ec589704c700b44e6d85f427e75f7cae2fd9d
7222577ca7b3516dcf294d61336e62c39e0c9978d3bb7f340f28861d65ee9e46  aa2612a3a46b575b6ea47f92bf8cb0a2d044cc6fb481dc94c762a494498b4d98  metadata.db
85804faad8f7299f503bbd5b3c5c7e4e2a292196d4d495900ad207f40118ba90  backingFsBlockDev                                                 mysqlvolume
85ec945d87e2cf25ae37f9d5794368c9ceb2ffea77dcf397298eb2f1272347ab  bc7b1554f3ba18edc684e1c783e47e35b364771c0c56975045716118f49029c5
85f6973945c7ea14896f08ae04dbbd9571e94b746c3cc2bf12aa1fcf3ad85019  c0413f1783e44e8ae18d9f67c2353a08432dbd5a0b50a190f50f8029543776f3
root@mike-VirtualBox:/mnt/docker/volumes# ll
total 108
drwx-----x 19 root root  4096 Mar 17 06:50 ./
drwx--x--- 13 root root  4096 Mar 15 10:49 ../
drwx-----x  3 root root  4096 Mar  9 08:48 373599e0ecc27fc4436eb868a0e9a72c1330ec4aae3e0447d7824bb1ac9159b6/
drwx-----x  3 root root  4096 Mar 11 05:01 42aabbb36c2ffefeec8385004e5a83c594edcb26ca5cb95322ebc4045e46f39f/
drwx-----x  3 root root  4096 Mar 10 06:54 63dca3e7164cd0f3196467d78fdd780bc852ac990da27a25e4d7328884b590ca/
drwx-----x  3 root root  4096 Mar  9 05:38 7222577ca7b3516dcf294d61336e62c39e0c9978d3bb7f340f28861d65ee9e46/
drwx-----x  3 root root  4096 Mar  9 05:22 85804faad8f7299f503bbd5b3c5c7e4e2a292196d4d495900ad207f40118ba90/
drwx-----x  3 root root  4096 Mar 11 08:00 85ec945d87e2cf25ae37f9d5794368c9ceb2ffea77dcf397298eb2f1272347ab/
drwx-----x  3 root root  4096 Mar 10 08:39 85f6973945c7ea14896f08ae04dbbd9571e94b746c3cc2bf12aa1fcf3ad85019/
drwx-----x  3 root root  4096 Mar 16 08:10 86e5653c9c266d482a3e3e9ff4d1028f0bcfd1a8230578c678ea9695f20b73ed/
drwx-----x  3 root root  4096 Mar  9 07:29 8e0a978b1544cd102ed2bf97f9f0a8038aeae1bf05eb82cea104c3a341edc787/
drwx-----x  3 root root  4096 Mar 11 06:45 8e89f71d6bce419df0db2980708f3d918edfd1d8ff4a867feb3866efc18e312f/
drwx-----x  3 root root  4096 Mar 10 08:39 aa2612a3a46b575b6ea47f92bf8cb0a2d044cc6fb481dc94c762a494498b4d98/
brw-------  1 root root  8, 1 Mar 15 10:49 backingFsBlockDev
drwx-----x  3 root root  4096 Mar 11 08:05 bc7b1554f3ba18edc684e1c783e47e35b364771c0c56975045716118f49029c5/
drwx-----x  3 root root  4096 Mar 10 05:26 c0413f1783e44e8ae18d9f67c2353a08432dbd5a0b50a190f50f8029543776f3/
drwx-----x  3 root root  4096 Mar 10 08:24 da001e7ec562b0f9427a98ccabfe821be44dda174b47b0000345091e9e65a995/
drwx-----x  3 root root  4096 Mar 10 08:33 e8daa84764964e25f424bafa2cf06403cf378be458c035e27eadf67b3fdf2da9/
drwx-----x  3 root root  4096 Mar 10 08:54 faf88f3fbb5fdd95c43bb000975ec589704c700b44e6d85f427e75f7cae2fd9d/
-rw-------  1 root root 65536 Mar 17 06:50 metadata.db
drwx-----x  3 root root  4096 Mar 17 06:50 mysqlvolume/
root@mike-VirtualBox:/mnt/docker/volumes#

as you see above we have the mysql volume that we have created before from the "docker volume create mysqlvolume"
command, so cool 
now what i want to show you is what happens when you type docker volume create....it basically just creates a folder under the docker root directory 
with the name of the volume name that we provide and the all of the information that you save will be saved in this location 
drwx-----x  3 root root  4096 Mar 17 06:50 mysqlvolume/

now you can also list the volumes that you create,remember the volumes that are not bind volumes as you can not list the bind volumes you can only list 
the normal volumes, so if we type "docker volume ls" we then see our normal volumes 
root@mike-VirtualBox:/mnt/docker/volumes#
root@mike-VirtualBox:/mnt/docker/volumes# docker volume ls
DRIVER    VOLUME NAME
local     8e0a978b1544cd102ed2bf97f9f0a8038aeae1bf05eb82cea104c3a341edc787
local     8e89f71d6bce419df0db2980708f3d918edfd1d8ff4a867feb3866efc18e312f
local     42aabbb36c2ffefeec8385004e5a83c594edcb26ca5cb95322ebc4045e46f39f
local     63dca3e7164cd0f3196467d78fdd780bc852ac990da27a25e4d7328884b590ca
local     85ec945d87e2cf25ae37f9d5794368c9ceb2ffea77dcf397298eb2f1272347ab
local     85f6973945c7ea14896f08ae04dbbd9571e94b746c3cc2bf12aa1fcf3ad85019
local     86e5653c9c266d482a3e3e9ff4d1028f0bcfd1a8230578c678ea9695f20b73ed
local     85804faad8f7299f503bbd5b3c5c7e4e2a292196d4d495900ad207f40118ba90
local     373599e0ecc27fc4436eb868a0e9a72c1330ec4aae3e0447d7824bb1ac9159b6
local     7222577ca7b3516dcf294d61336e62c39e0c9978d3bb7f340f28861d65ee9e46
local     aa2612a3a46b575b6ea47f92bf8cb0a2d044cc6fb481dc94c762a494498b4d98
local     bc7b1554f3ba18edc684e1c783e47e35b364771c0c56975045716118f49029c5
local     c0413f1783e44e8ae18d9f67c2353a08432dbd5a0b50a190f50f8029543776f3
local     da001e7ec562b0f9427a98ccabfe821be44dda174b47b0000345091e9e65a995
local     e8daa84764964e25f424bafa2cf06403cf378be458c035e27eadf67b3fdf2da9
local     faf88f3fbb5fdd95c43bb000975ec589704c700b44e6d85f427e75f7cae2fd9d
local     mysqlvolume
root@mike-VirtualBox:/mnt/docker/volumes#

so we brought some anonymous volumes (we will take a look at them later) here, and we also bring the volume that we have created,
for now just keep in mind that this the volume that you created previously with the docker volume create command 

so now the question is....how do we use this volume and how do we map these volume to the container, well the idea is exactly the same.....
first we need to map the volume name (mysqlvolume) and then we put a colon (:) and then you provide the folder inside of the container 
so lets try to create a new mysql container and now lets use the volume name 



root@mike-VirtualBox:/mnt/docker/volumes#.....so lets exit out of here and then in our docker host we will create our container
via the run command of mysql
docker run -d -v /mnt/mysql:/var/lib/mysql --name mysql -e "MYSQL_ROOT_PASSWORD=12345678" mysql:5.7
but now instead of providing the folder that we crteated locally (/mnt/mysql) 
we put our volume name  that we created above as a source  


mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images/dockercommit$ 
docker run -d -v mysqlvolume:/var/lib/mysql --name mysqli -e "MYSQL_ROOT_PASSWORD=12345678" mysql:5.7

so in other words we say please docker map this volume mysqlvolume that we just created to the "/var/lib/mysql" inside of the container 
now if we hit enter the output is the same and as i told you in the background this volume (mysqlvolume) is nothing else but a folder 
under the docker root directory 
so now if you type docker ps you will see your container  and if you type docker volume ls you will also see your volume
 

mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images/dockercommit$ 
docker run -d -v mysqlvolume:/var/lib/mysql --name mysqli -e "MYSQL_ROOT_PASSWORD=12345678" mysql:5.7

c382b9084c92a2e57d3ac1fc7295ebc298e4f99a97472d2760f8e04846be00ef
mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images/dockercommit$ docker ps
CONTAINER ID   IMAGE       COMMAND                  CREATED          STATUS          PORTS                 NAMES
c382b9084c92   mysql:5.7   "docker-entrypoint.s"   12 minutes ago   Up 12 minutes   3306/tcp, 33060/tcp   mysqli
58a391e07394   mysql:5.7   "docker-entrypoint.s"   20 hours ago     Up 20 hours     3306/tcp, 33060/tcp   mysql
mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images/dockercommit$ docker volume ls
DRIVER    VOLUME NAME
local     8e0a978b1544cd102ed2bf97f9f0a8038aeae1bf05eb82cea104c3a341edc787
local     8e89f71d6bce419df0db2980708f3d918edfd1d8ff4a867feb3866efc18e312f
local     42aabbb36c2ffefeec8385004e5a83c594edcb26ca5cb95322ebc4045e46f39f
local     63dca3e7164cd0f3196467d78fdd780bc852ac990da27a25e4d7328884b590ca
local     85ec945d87e2cf25ae37f9d5794368c9ceb2ffea77dcf397298eb2f1272347ab
local     85f6973945c7ea14896f08ae04dbbd9571e94b746c3cc2bf12aa1fcf3ad85019
local     86e5653c9c266d482a3e3e9ff4d1028f0bcfd1a8230578c678ea9695f20b73ed
local     85804faad8f7299f503bbd5b3c5c7e4e2a292196d4d495900ad207f40118ba90
local     373599e0ecc27fc4436eb868a0e9a72c1330ec4aae3e0447d7824bb1ac9159b6
local     7222577ca7b3516dcf294d61336e62c39e0c9978d3bb7f340f28861d65ee9e46
local     aa2612a3a46b575b6ea47f92bf8cb0a2d044cc6fb481dc94c762a494498b4d98
local     bc7b1554f3ba18edc684e1c783e47e35b364771c0c56975045716118f49029c5
local     c0413f1783e44e8ae18d9f67c2353a08432dbd5a0b50a190f50f8029543776f3
local     da001e7ec562b0f9427a98ccabfe821be44dda174b47b0000345091e9e65a995
local     e8daa84764964e25f424bafa2cf06403cf378be458c035e27eadf67b3fdf2da9
local     faf88f3fbb5fdd95c43bb000975ec589704c700b44e6d85f427e75f7cae2fd9d
local     mysqlvolume


but now in order to see the information that is being saved in the volume that we created above 
you must type "sudo su" to be the root user and from there go to "/mnt/docker/volumes"

via cd /mnt/docker/volumes and if you type ls you will see all of the volumes including the one that you used in your container 
so we go ahead on tha volume and if you list the file you will see a data folder (_data)
so we are going inside that folder with cd of course 
and there we are going to see all the information that mysql creates and basically this information is being saved in your localhost...docker host 

--------------------------------------------------------------------------------------------------------------------------------------------------------
mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images/dockercommit$ sudo su
[sudo] password for mike:
root@mike-VirtualBox:/home/mike/Desktop/realstuff/realstuff1/multistage/docker-images/dockercommit#

root@mike-VirtualBox:/home/mike/Desktop/realstuff/realstuff1/multistage/docker-images/dockercommit# cd /mnt/docker/volumes/
root@mike-VirtualBox:/mnt/docker/volumes# ls
373599e0ecc27fc4436eb868a0e9a72c1330ec4aae3e0447d7824bb1ac9159b6  86e5653c9c266d482a3e3e9ff4d1028f0bcfd1a8230578c678ea9695f20b73ed  da001e7ec562b0f9427a98ccabfe821be44dda174b47b0000345091e9e65a995
42aabbb36c2ffefeec8385004e5a83c594edcb26ca5cb95322ebc4045e46f39f  8e0a978b1544cd102ed2bf97f9f0a8038aeae1bf05eb82cea104c3a341edc787  e8daa84764964e25f424bafa2cf06403cf378be458c035e27eadf67b3fdf2da9
63dca3e7164cd0f3196467d78fdd780bc852ac990da27a25e4d7328884b590ca  8e89f71d6bce419df0db2980708f3d918edfd1d8ff4a867feb3866efc18e312f  faf88f3fbb5fdd95c43bb000975ec589704c700b44e6d85f427e75f7cae2fd9d
7222577ca7b3516dcf294d61336e62c39e0c9978d3bb7f340f28861d65ee9e46  aa2612a3a46b575b6ea47f92bf8cb0a2d044cc6fb481dc94c762a494498b4d98  metadata.db
85804faad8f7299f503bbd5b3c5c7e4e2a292196d4d495900ad207f40118ba90  backingFsBlockDev                                                 mysqlvolume
85ec945d87e2cf25ae37f9d5794368c9ceb2ffea77dcf397298eb2f1272347ab  bc7b1554f3ba18edc684e1c783e47e35b364771c0c56975045716118f49029c5
85f6973945c7ea14896f08ae04dbbd9571e94b746c3cc2bf12aa1fcf3ad85019  c0413f1783e44e8ae18d9f67c2353a08432dbd5a0b50a190f50f8029543776f3
root@mike-VirtualBox:/mnt/docker/volumes# cd mysqlvolume/
root@mike-VirtualBox:/mnt/docker/volumes/mysqlvolume# ll
total 12
drwx-----x  3 root    root   4096 Mar 17 06:50 ./
drwx-----x 19 root    root   4096 Mar 17 06:50 ../
drwxrwxrwt  5 vboxadd vboxsf 4096 Mar 17 07:47                        _data/


root@mike-VirtualBox:/mnt/docker/volumes/mysqlvolume# cd _data/
root@mike-VirtualBox:/mnt/docker/volumes/mysqlvolume/_data# ll
total 188488
drwxrwxrwt 5 vboxadd vboxsf     4096 Mar 17 07:47 ./
drwx-----x 3 root    root       4096 Mar 17 06:50 ../
-rw-r----- 1 vboxadd vboxsf       56 Mar 17 07:47 auto.cnf
-rw------- 1 vboxadd vboxsf     1676 Mar 17 07:47 ca-key.pem
-rw-r--r-- 1 vboxadd vboxsf     1112 Mar 17 07:47 ca.pem
-rw-r--r-- 1 vboxadd vboxsf     1112 Mar 17 07:47 client-cert.pem
-rw------- 1 vboxadd vboxsf     1676 Mar 17 07:47 client-key.pem
-rw-r----- 1 vboxadd vboxsf     1352 Mar 17 07:47 ib_buffer_pool
-rw-r----- 1 vboxadd vboxsf 79691776 Mar 17 07:47 ibdata1
-rw-r----- 1 vboxadd vboxsf 50331648 Mar 17 07:47 ib_logfile0
-rw-r----- 1 vboxadd vboxsf 50331648 Mar 17 07:47 ib_logfile1
-rw-r----- 1 vboxadd vboxsf 12582912 Mar 17 07:47 ibtmp1
drwxr-x--- 2 vboxadd vboxsf     4096 Mar 17 07:47 mysql/
drwxr-x--- 2 vboxadd vboxsf     4096 Mar 17 07:47 performance_schema/
-rw------- 1 vboxadd vboxsf     1676 Mar 17 07:47 private_key.pem
-rw-r--r-- 1 vboxadd vboxsf      452 Mar 17 07:47 public_key.pem
-rw-r--r-- 1 vboxadd vboxsf     1112 Mar 17 07:47 server-cert.pem
-rw------- 1 vboxadd vboxsf     1676 Mar 17 07:47 server-key.pem
drwxr-x--- 2 vboxadd vboxsf    12288 Mar 17 07:47 sys/
root@mike-VirtualBox:/mnt/docker/volumes/mysqlvolume/_data#

--------------------------------------------------------------------------------------------------------------------------------------------------------

so now if i exited from here and go to my docker host and remove that container....
there is no need to exit as the container exists here also from the time we map our volume to the container's path (/var/lib/mysql)

root@mike-VirtualBox:/mnt/docker/volumes/mysqlvolume/_data# docker rm -f c382b9084c92

and then if we perform ll we are going to see he volumes folder in there 
root@mike-VirtualBox:/mnt/docker/volumes/mysqlvolume/_data# ll 





root@mike-VirtualBox:/mnt/docker/volumes/mysqlvolume/_data# ll
total 188488
drwxrwxrwt 5 vboxadd vboxsf     4096 Mar 17 07:47 ./
drwx-----x 3 root    root       4096 Mar 17 06:50 ../
-rw-r----- 1 vboxadd vboxsf       56 Mar 17 07:47 auto.cnf
-rw------- 1 vboxadd vboxsf     1676 Mar 17 07:47 ca-key.pem
-rw-r--r-- 1 vboxadd vboxsf     1112 Mar 17 07:47 ca.pem
-rw-r--r-- 1 vboxadd vboxsf     1112 Mar 17 07:47 client-cert.pem
-rw------- 1 vboxadd vboxsf     1676 Mar 17 07:47 client-key.pem
-rw-r----- 1 vboxadd vboxsf     1352 Mar 17 07:47 ib_buffer_pool
-rw-r----- 1 vboxadd vboxsf 79691776 Mar 17 07:47 ibdata1
-rw-r----- 1 vboxadd vboxsf 50331648 Mar 17 07:47 ib_logfile0
-rw-r----- 1 vboxadd vboxsf 50331648 Mar 17 07:47 ib_logfile1
-rw-r----- 1 vboxadd vboxsf 12582912 Mar 17 07:47 ibtmp1
drwxr-x--- 2 vboxadd vboxsf     4096 Mar 17 07:47 mysql/
drwxr-x--- 2 vboxadd vboxsf     4096 Mar 17 07:47 performance_schema/
-rw------- 1 vboxadd vboxsf     1676 Mar 17 07:47 private_key.pem
-rw-r--r-- 1 vboxadd vboxsf      452 Mar 17 07:47 public_key.pem
-rw-r--r-- 1 vboxadd vboxsf     1112 Mar 17 07:47 server-cert.pem
-rw------- 1 vboxadd vboxsf     1676 Mar 17 07:47 server-key.pem
drwxr-x--- 2 vboxadd vboxsf    12288 Mar 17 07:47 sys/
root@mike-VirtualBox:/mnt/docker/volumes/mysqlvolume/_data# cd ..


well if we go one level back to our volume (mysqlvolume) and perform docker volume ls we are going to see or volume there 

root@mike-VirtualBox:/mnt/docker/volumes/mysqlvolume# docker volume ls
DRIVER    VOLUME NAME
local     8e0a978b1544cd102ed2bf97f9f0a8038aeae1bf05eb82cea104c3a341edc787
local     8e89f71d6bce419df0db2980708f3d918edfd1d8ff4a867feb3866efc18e312f
local     42aabbb36c2ffefeec8385004e5a83c594edcb26ca5cb95322ebc4045e46f39f
local     63dca3e7164cd0f3196467d78fdd780bc852ac990da27a25e4d7328884b590ca
local     85ec945d87e2cf25ae37f9d5794368c9ceb2ffea77dcf397298eb2f1272347ab
local     85f6973945c7ea14896f08ae04dbbd9571e94b746c3cc2bf12aa1fcf3ad85019
local     86e5653c9c266d482a3e3e9ff4d1028f0bcfd1a8230578c678ea9695f20b73ed
local     85804faad8f7299f503bbd5b3c5c7e4e2a292196d4d495900ad207f40118ba90
local     373599e0ecc27fc4436eb868a0e9a72c1330ec4aae3e0447d7824bb1ac9159b6
local     7222577ca7b3516dcf294d61336e62c39e0c9978d3bb7f340f28861d65ee9e46
local     aa2612a3a46b575b6ea47f92bf8cb0a2d044cc6fb481dc94c762a494498b4d98
local     bc7b1554f3ba18edc684e1c783e47e35b364771c0c56975045716118f49029c5
local     c0413f1783e44e8ae18d9f67c2353a08432dbd5a0b50a190f50f8029543776f3
local     da001e7ec562b0f9427a98ccabfe821be44dda174b47b0000345091e9e65a995
local     e8daa84764964e25f424bafa2cf06403cf378be458c035e27eadf67b3fdf2da9
local     faf88f3fbb5fdd95c43bb000975ec589704c700b44e6d85f427e75f7cae2fd9d
local     mysqlvolume
root@mike-VirtualBox:/mnt/docker/volumes/mysqlvolume# ^C
root@mike-VirtualBox:/mnt/docker/volumes/mysqlvolume#

root@mike-VirtualBox:/mnt/docker/volumes/mysqlvolume# docker volume ls  


so if you want to remmaped that volume to your container you need to run the same line that you run before 
which with words says 
please docker map all of the file inside of mysqlvolume in the path /var/lib/mysql in the container 


mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images/dockercommit$ 
docker run -d -v mysqlvolume:/var/lib/mysql --name mysqli -e "MYSQL_ROOT_PASSWORD=12345678" mysql:5.7

and remember that in this mysqlvolume are all the files :

drwxrwxrwt 5 vboxadd vboxsf     4096 Mar 17 07:47 ./
drwx-----x 3 root    root       4096 Mar 17 06:50 ../
-rw-r----- 1 vboxadd vboxsf       56 Mar 17 07:47 auto.cnf
-rw------- 1 vboxadd vboxsf     1676 Mar 17 07:47 ca-key.pem
-rw-r--r-- 1 vboxadd vboxsf     1112 Mar 17 07:47 ca.pem
-rw-r--r-- 1 vboxadd vboxsf     1112 Mar 17 07:47 client-cert.pem
-rw------- 1 vboxadd vboxsf     1676 Mar 17 07:47 client-key.pem
-rw-r----- 1 vboxadd vboxsf     1352 Mar 17 07:47 ib_buffer_pool
-rw-r----- 1 vboxadd vboxsf 79691776 Mar 17 07:47 ibdata1
-rw-r----- 1 vboxadd vboxsf 50331648 Mar 17 07:47 ib_logfile0
-rw-r----- 1 vboxadd vboxsf 50331648 Mar 17 07:47 ib_logfile1
-rw-r----- 1 vboxadd vboxsf 12582912 Mar 17 07:47 ibtmp1
drwxr-x--- 2 vboxadd vboxsf     4096 Mar 17 07:47 mysql/
drwxr-x--- 2 vboxadd vboxsf     4096 Mar 17 07:47 performance_schema/
-rw------- 1 vboxadd vboxsf     1676 Mar 17 07:47 private_key.pem
-rw-r--r-- 1 vboxadd vboxsf      452 Mar 17 07:47 public_key.pem
-rw-r--r-- 1 vboxadd vboxsf     1112 Mar 17 07:47 server-cert.pem
-rw------- 1 vboxadd vboxsf     1676 Mar 17 07:47 server-key.pem
drwxr-x--- 2 vboxadd vboxsf    12288 Mar 17 07:47 sys/



that the previous container stored in this directory becasue we previously set a mapping 
between a volume and a container folder, so now that the container stored of the information here (mysqlvolume) in the volume 
we can reuseed that volume (mysqlvolume) and we can map again that volume to the container so if we hit enter 
an the creation of the container above and run docker ps we will see that the container has the same information with the previous one 


if youi want you can do exactly the same test 
you can create a container create a test databse remove the container and then you can associate the same volume to the new container 
and yoy will have all of the information in here 
so if you see using volumes and bind volumes is the same thing the only one difference  that in bind volumes you create a folder somewhere in your docker host 
and you map that directory to your container and when you are using normal volumes you just do a docker volume create and that commands creates a folder under 
the root directory (/var/lib/docker ) and then you map the name of the volume that you create to the container and the cvontainer will store all of the information 
under the root directory of docker in a folder with the name that we provided 
so i hope how to use normal volumes and bind volumes to persist data in docker 


68.Anonymous volumes : be careful if you want to use them
---------------------------------------------------------
hello and welcome back in this lesson we are going to learn what anonymous volumes are 
                                                            how they are created 
                                                            how do we manage these volumes 
                                                            and all of the things that we can learn about it 
so the first thing that we want to learn about anonymous volumes is that they dont provide a specific folder or a specific location where you can find your data 
e.g. they provide a random folder where you can find your information but that folder is kind of temporary 
so you can end up deleting your data without knowing it .
so lets take a look at the volumes that we have create until now 

root@mike-VirtualBox:/mnt/docker/volumes/mysqlvolume# docker volume ls
DRIVER    VOLUME NAME
local     8e0a978b1544cd102ed2bf97f9f0a8038aeae1bf05eb82cea104c3a341edc787
local     8e89f71d6bce419df0db2980708f3d918edfd1d8ff4a867feb3866efc18e312f
local     42aabbb36c2ffefeec8385004e5a83c594edcb26ca5cb95322ebc4045e46f39f
local     63dca3e7164cd0f3196467d78fdd780bc852ac990da27a25e4d7328884b590ca
local     85ec945d87e2cf25ae37f9d5794368c9ceb2ffea77dcf397298eb2f1272347ab
local     85f6973945c7ea14896f08ae04dbbd9571e94b746c3cc2bf12aa1fcf3ad85019
local     86e5653c9c266d482a3e3e9ff4d1028f0bcfd1a8230578c678ea9695f20b73ed
local     85804faad8f7299f503bbd5b3c5c7e4e2a292196d4d495900ad207f40118ba90
local     373599e0ecc27fc4436eb868a0e9a72c1330ec4aae3e0447d7824bb1ac9159b6
local     7222577ca7b3516dcf294d61336e62c39e0c9978d3bb7f340f28861d65ee9e46
local     aa2612a3a46b575b6ea47f92bf8cb0a2d044cc6fb481dc94c762a494498b4d98
local     bc7b1554f3ba18edc684e1c783e47e35b364771c0c56975045716118f49029c5
local     c0413f1783e44e8ae18d9f67c2353a08432dbd5a0b50a190f50f8029543776f3
local     da001e7ec562b0f9427a98ccabfe821be44dda174b47b0000345091e9e65a995
local     e8daa84764964e25f424bafa2cf06403cf378be458c035e27eadf67b3fdf2da9
local     faf88f3fbb5fdd95c43bb000975ec589704c700b44e6d85f427e75f7cae2fd9d
local     mysqlvolume
root@mike-VirtualBox:/mnt/docker/volumes/mysqlvolume# 


so lets go and remove these volumes with "docker volume $(docker volume ls)"



and now lets go and create a mysql container 

mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images/dockercommit$ 
docker run -d -v mysqlvolume:/var/lib/mysql --name mysqli -e "MYSQL_ROOT_PASSWORD=12345678" mysql:5.7


and here in order to create an anonymous volume we need to provide the path inside of the container without mapping it to any location in our host 
so say that we want to create an anonymous volumes that points to "/var/lib/mysql" inside of the container
remember that the path above relates to the path inside of the container and when you create an anonymous volume you dont specify any host path you dont specify any volume 
or you dont folder you only specify the path inside of the container and finally we specify the image that we want to use   


mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images/dockercommit$ 
docker run -d -e "MYSQL_ROOT_PASSWORD=12345678"  --name mysqli -v /var/lib/mysql mysql:5.7


now if we hiot enter and we type docker ps you see that yor container is up and running 

Unable to find image 'mysql:5.7' locally
5.7: Pulling from library/mysql
15115158dd02: Pull complete
d733f6778b18: Pull complete
1cc7a6c74a04: Pull complete
c4364028a805: Pull complete
82887163f0f6: Pull complete
28abcb7f57e0: Pull complete
46d27a431703: Pull complete
146a7517cdca: Pull complete
ac645a526e45: Pull complete
a292dcc315cc: Pull complete
ff70b7ef8a8b: Pull complete
Digest: sha256:66d52e6baa8093820c09fec56992a5ee734f17e9fad8ef5ffc31597b231bd048
Status: Downloaded newer image for mysql:5.7
689a8fb8a0a3e101b34905668fa02096c272ac605e9d8705fdb3ed5525c9e6ff
mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images/dockercommit$

mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images/dockercommit$ docker ps
CONTAINER ID   IMAGE       COMMAND                  CREATED          STATUS          PORTS                 NAMES
689a8fb8a0a3   mysql:5.7   "docker-entrypoint.s"   50 seconds ago   Up 48 seconds   3306/tcp, 33060/tcp   mysqli
mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images/dockercommit$


but now if you type " docker volume ls " you will see a new volume here that has a name that is a little bit random and its a little bit 
complicated to understand whta is this volume.....so what is this thing ?


mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images/dockercommit$ docker volume ls
DRIVER    VOLUME NAME
local     0aa1d945dadaf6fda8e71e611ded73cf29fc24c71da253719d53d73d7bd7766b
mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images/dockercommit$



so to find the volume that was created via the " mysqli " container above we can type 
docker inspect and we provide the name of the container i.e. mysqli

mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images/dockercommit$ docker inspect mysqli

[
    {
        "Id": "689a8fb8a0a3e101b34905668fa02096c272ac605e9d8705fdb3ed5525c9e6ff",
        "Created": "2022-03-17T13:59:35.806090484Z",
        "Path": "docker-entrypoint.sh",
        "Args": [
            "mysqld"
        ],
        "State": {
            "Status": "running",
            "Running": true,
            "Paused": false,
            "Restarting": false,
            "OOMKilled": false,
            "Dead": false,
            "Pid": 32264,
            "ExitCode": 0,
            "Error": "",
            "StartedAt": "2022-03-17T13:59:37.386890469Z",
            "FinishedAt": "0001-01-01T00:00:00Z"
        },
        "Image": "sha256:11d8667108c29e3b7a0984860b9c262d6867b20084921c0108ee077a60ad4102",
        "ResolvConfPath": "/mnt/docker/containers/689a8fb8a0a3e101b34905668fa02096c272ac605e9d8705fdb3ed5525c9e6ff/resolv.conf",
        "HostnamePath": "/mnt/docker/containers/689a8fb8a0a3e101b34905668fa02096c272ac605e9d8705fdb3ed5525c9e6ff/hostname",
        "HostsPath": "/mnt/docker/containers/689a8fb8a0a3e101b34905668fa02096c272ac605e9d8705fdb3ed5525c9e6ff/hosts",
        "LogPath": "/mnt/docker/containers/689a8fb8a0a3e101b34905668fa02096c272ac605e9d8705fdb3ed5525c9e6ff/689a8fb8a0a3e101b34905668fa02096c272ac605e9d8705fdb3ed5525c9e6ff-json.log",
        "Name": "/mysqli",
        "RestartCount": 0,
        "Driver": "overlay2",
        "Platform": "linux",
        "MountLabel": "",
        "ProcessLabel": "",
        "AppArmorProfile": "docker-default",
        "ExecIDs": null,
        "HostConfig": {
            "Binds": null,
            "ContainerIDFile": "",
            "LogConfig": {
                "Type": "json-file",
                "Config": {}
            },
            "NetworkMode": "default",
            "PortBindings": {},
            "RestartPolicy": {
                "Name": "no",
                "MaximumRetryCount": 0
            },
            "AutoRemove": false,
            "VolumeDriver": "",
            "VolumesFrom": null,
            "CapAdd": null,
            "CapDrop": null,
            "CgroupnsMode": "host",
            "Dns": [],
            "DnsOptions": [],
            "DnsSearch": [],
            "ExtraHosts": null,
            "GroupAdd": null,
            "IpcMode": "private",
            "Cgroup": "",
            "Links": null,
            "OomScoreAdj": 0,
            "PidMode": "",
            "Privileged": false,
            "PublishAllPorts": false,
            "ReadonlyRootfs": false,
            "SecurityOpt": null,
            "UTSMode": "",
            "UsernsMode": "",
            "ShmSize": 67108864,
            "Runtime": "runc",
            "ConsoleSize": [
                0,
                0
            ],
            "Isolation": "",
            "CpuShares": 0,
            "Memory": 0,
            "NanoCpus": 0,
            "CgroupParent": "",
            "BlkioWeight": 0,
            "BlkioWeightDevice": [],
            "BlkioDeviceReadBps": null,
            "BlkioDeviceWriteBps": null,
            "BlkioDeviceReadIOps": null,
            "BlkioDeviceWriteIOps": null,
            "CpuPeriod": 0,
            "CpuQuota": 0,
            "CpuRealtimePeriod": 0,
            "CpuRealtimeRuntime": 0,
            "CpusetCpus": "",
            "CpusetMems": "",
            "Devices": [],
            "DeviceCgroupRules": null,
            "DeviceRequests": null,
            "KernelMemory": 0,
            "KernelMemoryTCP": 0,
            "MemoryReservation": 0,
            "MemorySwap": 0,
            "MemorySwappiness": null,
            "OomKillDisable": false,
            "PidsLimit": null,
            "Ulimits": null,
            "CpuCount": 0,
            "CpuPercent": 0,
            "IOMaximumIOps": 0,
            "IOMaximumBandwidth": 0,
            "MaskedPaths": [
                "/proc/asound",
                "/proc/acpi",
                "/proc/kcore",
                "/proc/keys",
                "/proc/latency_stats",
                "/proc/timer_list",
                "/proc/timer_stats",
                "/proc/sched_debug",
                "/proc/scsi",
                "/sys/firmware"
            ],
            "ReadonlyPaths": [
                "/proc/bus",
                "/proc/fs",
                "/proc/irq",
                "/proc/sys",
                "/proc/sysrq-trigger"
            ]
        },
        "GraphDriver": {
            "Data": {
                "LowerDir": "/mnt/docker/overlay2/dd0780fdb9b45553667abdaab63a33fca7eee7d4b913cbde7d1edcff113717c9-init/diff:/mnt/docker/overlay2/ae09e635b414a5867a219e510901d5a499abeda499a1ee4e1da2df8ba08e831a/diff:/mnt/docker/overlay2/01f944cbd946bbb71eec7ccdc24fa50a36695788ff25a1eeb789756414f90b73/diff:/mnt/docker/overlay2/4171a7b47892bdb03c2a806d9809a3e5a63940309b77d500b56b5db648af492a/diff:/mnt/docker/overlay2/58a1c8d2773aef3f2757bc6c16c1583fd22ed0ff5ac8713764590a77ac982deb/diff:/mnt/docker/overlay2/fe00a95a32c41105fb208f5b0ddfe2b804d790af6b33715ddaf4084d80c6454d/diff:/mnt/docker/overlay2/1a48bae27249d74bbfa67c80d2dcfd1b1c7e023939bc444151689a7bbf1b99eb/diff:/mnt/docker/overlay2/3995457ea378d4e9af4a218c9ff40d38a63401521b4b054210c71bb2403c5bfa/diff:/mnt/docker/overlay2/277c8b6ebe3d7067163d2c75e5186ef353f654aec5a4c49fc4858e00bf2b5f7f/diff:/mnt/docker/overlay2/fe0a05147aed53909a5b963dd8bffff00c949668524f2065c55115eea6cca78d/diff:/mnt/docker/overlay2/80ce6d022b2b00da95d6ddc21266f3306861554ff45b951d050c228147645bd6/diff:/mnt/docker/overlay2/47814a7b26e34991233702cd2e2ac6697252b4147cc63e9bede4c53d76bd90ab/diff",
                "MergedDir": "/mnt/docker/overlay2/dd0780fdb9b45553667abdaab63a33fca7eee7d4b913cbde7d1edcff113717c9/merged",
                "UpperDir": "/mnt/docker/overlay2/dd0780fdb9b45553667abdaab63a33fca7eee7d4b913cbde7d1edcff113717c9/diff",
                "WorkDir": "/mnt/docker/overlay2/dd0780fdb9b45553667abdaab63a33fca7eee7d4b913cbde7d1edcff113717c9/work"
            },
            "Name": "overlay2"
        },
        "Mounts": [
            {
                "Type": "volume",
                "Name": "0aa1d945dadaf6fda8e71e611ded73cf29fc24c71da253719d53d73d7bd7766b",
                "Source": "/mnt/docker/volumes/0aa1d945dadaf6fda8e71e611ded73cf29fc24c71da253719d53d73d7bd7766b/_data",
                "Destination": "/var/lib/mysql",
                "Driver": "local",
                "Mode": "",
                "RW": true,
                "Propagation": ""
            }
        ],
        "Config": {
            "Hostname": "689a8fb8a0a3",
            "Domainname": "",
            "User": "",
            "AttachStdin": false,
            "AttachStdout": false,
            "AttachStderr": false,
            "ExposedPorts": {
                "3306/tcp": {},
                "33060/tcp": {}
            },
            "Tty": false,
            "OpenStdin": false,
            "StdinOnce": false,
            "Env": [
                "MYSQL_ROOT_PASSWORD=12345678",
                "PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin",
                "GOSU_VERSION=1.14",
                "MYSQL_MAJOR=5.7",
                "MYSQL_VERSION=5.7.37-1debian10"
            ],
            "Cmd": [
                "mysqld"
            ],
            "Image": "mysql:5.7",
            "Volumes": {
                "/var/lib/mysql": {}
            },
            "WorkingDir": "",
            "Entrypoint": [
                "docker-entrypoint.sh"
            ],
            "OnBuild": null,
            "Labels": {}
        },
        "NetworkSettings": {
            "Bridge": "",
            "SandboxID": "608ae2a78a35f7330b18da1ff45d4a75136f4fdf82c678788416a68188760d14",
            "HairpinMode": false,
            "LinkLocalIPv6Address": "",
            "LinkLocalIPv6PrefixLen": 0,
            "Ports": {
                "3306/tcp": null,
                "33060/tcp": null
            },
            "SandboxKey": "/var/run/docker/netns/608ae2a78a35",
            "SecondaryIPAddresses": null,
            "SecondaryIPv6Addresses": null,
            "EndpointID": "1a6d84fe0436d2082c769b0b3680df466f6a8f4098c1459f76feb12b6e7fa5a5",
            "Gateway": "172.17.0.1",
            "GlobalIPv6Address": "",
            "GlobalIPv6PrefixLen": 0,
            "IPAddress": "172.17.0.2",
            "IPPrefixLen": 16,
            "IPv6Gateway": "",
            "MacAddress": "02:42:ac:11:00:02",
            "Networks": {
                "bridge": {
                    "IPAMConfig": null,
                    "Links": null,
                    "Aliases": null,
                    "NetworkID": "d6b7e5b7a0db304e6491192daf724ee8c6345fed9df04b04cd4587fd7bcc7660",
                    "EndpointID": "1a6d84fe0436d2082c769b0b3680df466f6a8f4098c1459f76feb12b6e7fa5a5",
                    "Gateway": "172.17.0.1",
                    "IPAddress": "172.17.0.2",
                    "IPPrefixLen": 16,
                    "IPv6Gateway": "",
                    "GlobalIPv6Address": "",
                    "GlobalIPv6PrefixLen": 0,
                    "MacAddress": "02:42:ac:11:00:02",
                    "DriverOpts": null
                }
            }
        }
    }
]
mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images/dockercommit$


so from the above json we scroll up until we find something that bears the name "Mounts" and in this section we can find the 
attribute name which contains the name of our anonymous volume that was created when you provided -v and then the path  on the container's creation above
so this is tha name of the volume when you type docker volume ls
and this  volume is created under the root directory   " /mnt/docker/volumes/ " in a folder with the same name 
0aa1d945dadaf6fda8e71e611ded73cf29fc24c71da253719d53d73d7bd7766b
and its destination points to "/var/lib/mysql"




        "Mounts": [
            {
                "Type": "volume",
                "Name": "0aa1d945dadaf6fda8e71e611ded73cf29fc24c71da253719d53d73d7bd7766b",
                "Source": "/mnt/docker/volumes/0aa1d945dadaf6fda8e71e611ded73cf29fc24c71da253719d53d73d7bd7766b/_data",
                "Destination": "/var/lib/mysql",
                "Driver": "local",
                "Mode": "",
                "RW": true,
                "Propagation": ""
            }
        ],



so lets go to the root directory....and if you don't know it you can look for it 
docker info | grep -i root
Docker Root  Dir: /mnt/docker.......and here the root directory is, so lets become sudo su and change directory to the docker root directory
via cd /mnt/docker  
and from ther we can go to the volumes folder....cd volumes/
and inside the volumes folder we shoukld have this folder : 0aa1d945dadaf6fda8e71e611ded73cf29fc24c71da253719d53d73d7bd7766b
which is an anonymous volume that was created by our container so if we change the directory to 
this one : 0aa1d945dadaf6fda8e71e611ded73cf29fc24c71da253719d53d73d7bd7766b
via "cd 0aa1d945dadaf6fda8e71e611ded73cf29fc24c71da253719d53d73d7bd7766b"
and do we list the file then we see the _data folder in it lets get in it and there we can see all of our files that mysql is creating there 
so its basically a normal volume with a random name but all of your information  is safely stored here

root@mike-VirtualBox:/mnt/docker/volumes/0aa1d945dadaf6fda8e71e611ded73cf29fc24c71da253719d53d73d7bd7766b/_data








mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images/dockercommit$ sudo su 
root@mike-virtualBox:/home/mike/Desktop/realstuff/realstuff1/multistage/docker-images/dockercommit# cd /mnt/docker
root@mike-virtualBox:/mnt/docker# ls 
buildkit  containers image network overlay2 plugins  runtimes swarm tmp trust volumes
root@mike-virtualBox:/mnt/docker# cd volumes/
root@mike-virtualBox:/mnt/docker/volumes# ls 
0aa1d945dadaf6fda8e71e611ded73cf29fc24c71da253719d53d73d7bd7766b  backingFsBlockDev metadata.db
root@mike-virtualBox:/mnt/docker/volumes# cd 0aa1d945dadaf6fda8e71e611ded73cf29fc24c71da253719d53d73d7bd7766b
root@mike-virtualBox:/mnt/docker/volumes/0aa1d945dadaf6fda8e71e611ded73cf29fc24c71da253719d53d73d7bd7766b# ls 
_data
root@mike-virtualBox:/mnt/docker/volumes/0aa1d945dadaf6fda8e71e611ded73cf29fc24c71da253719d53d73d7bd7766b#

root@mike-VirtualBox:/mnt/docker/volumes/0aa1d945dadaf6fda8e71e611ded73cf29fc24c71da253719d53d73d7bd7766b# ll
total 12
drwx-----x 3 root    root   4096 Mar 17 09:59 ./
drwx-----x 3 root    root   4096 Mar 17 09:59 ../
drwxrwxrwt 5 vboxadd vboxsf 4096 Mar 17 09:59 _data/
root@mike-VirtualBox:/mnt/docker/volumes/0aa1d945dadaf6fda8e71e611ded73cf29fc24c71da253719d53d73d7bd7766b# cd _data/



root@mike-VirtualBox:/mnt/docker/volumes/0aa1d945dadaf6fda8e71e611ded73cf29fc24c71da253719d53d73d7bd7766b/_data# ll
total 188484
drwxrwxrwt 5 vboxadd vboxsf     4096 Mar 17 09:59 ./
drwx-----x 3 root    root       4096 Mar 17 09:59 ../
-rw-r----- 1 vboxadd vboxsf       56 Mar 17 09:59 auto.cnf
-rw------- 1 vboxadd vboxsf     1676 Mar 17 09:59 ca-key.pem
-rw-r--r-- 1 vboxadd vboxsf     1112 Mar 17 09:59 ca.pem
-rw-r--r-- 1 vboxadd vboxsf     1112 Mar 17 09:59 client-cert.pem
-rw------- 1 vboxadd vboxsf     1680 Mar 17 09:59 client-key.pem
-rw-r----- 1 vboxadd vboxsf     1352 Mar 17 09:59 ib_buffer_pool
-rw-r----- 1 vboxadd vboxsf 79691776 Mar 17 09:59 ibdata1
-rw-r----- 1 vboxadd vboxsf 50331648 Mar 17 09:59 ib_logfile0
-rw-r----- 1 vboxadd vboxsf 50331648 Mar 17 09:59 ib_logfile1
-rw-r----- 1 vboxadd vboxsf 12582912 Mar 17 09:59 ibtmp1
drwxr-x--- 2 vboxadd vboxsf     4096 Mar 17 09:59 mysql/
drwxr-x--- 2 vboxadd vboxsf     4096 Mar 17 09:59 performance_schema/
-rw------- 1 vboxadd vboxsf     1680 Mar 17 09:59 private_key.pem
-rw-r--r-- 1 vboxadd vboxsf      452 Mar 17 09:59 public_key.pem
-rw-r--r-- 1 vboxadd vboxsf     1112 Mar 17 09:59 server-cert.pem
-rw------- 1 vboxadd vboxsf     1680 Mar 17 09:59 server-key.pem
drwxr-x--- 2 vboxadd vboxsf    12288 Mar 17 09:59 sys/
root@mike-VirtualBox:/mnt/docker/volumes/0aa1d945dadaf6fda8e71e611ded73cf29fc24c71da253719d53d73d7bd7766b/_data#


now there is an important point and i thing this is the most important point when using anonymous volumes and its about the lifecycle 
of the volume itself, so the thing here with the anonymous volumes is that if you remove the container using a special flag the volume 
will be deleted with the container  but if yoy don't specify that flag then the volume will still be in the docker host even if the container is deleted 
but then you will have a hard time figuring out the content or the name of that volume because as you see the name is a liitle bit confusing so you dont really know 
what it is 

so we exit from the root dierectory and we are goona talk about what we are going to be talking about  

root@mike-VirtualBox:/mnt/docker/volumes/0aa1d945dadaf6fda8e71e611ded73cf29fc24c71da253719d53d73d7bd7766b/_data# exit
exit
mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images/dockercommit$

my bad back to the root again and do "cd /mnt/docker/volumes" and if we list the files here you see that volume there.....right? riiiiighght
then the volume was created via the container " mysqli " so if i remove this container then probably the its volume will be removed as well 
but this happen if you use a specific flag and that flag is "-v" so for example if you hit "docker rm -fv" then you remove both the container and the 
volume as well which is a little bit dangerous as if you have important files in the volume 

so through "docker rm -fv" you delete both the container and the volume or the volumes that are depended on it 
so you are in the root directory of the volumes you type "docker volume ls" and nothing same goes for docker ps 

mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images/dockercommit$ sudo su
root@mike-VirtualBox:/Desktop/realstuff/realstuff1/multistage/docker-images/dockercommit$ cd /mnt/docker/volumes
root@mike-VirtualBox: /mnt/docker/volumes$ ll

total 44
drwx-----x  3 root root  4096 Mar 17 09:59 ./
drwx--x--- 13 root root  4096 Mar 15 10:49 ../
drwx-----x  3 root root  4096 Mar 17 09:59 0aa1d945dadaf6fda8e71e611ded73cf29fc24c71da253719d53d73d7bd7766b/
brw-------  1 root root  8, 1 Mar 15 10:49 backingFsBlockDev
-rw-------  1 root root 65536 Mar 17 09:59 metadata.db
root@mike-VirtualBox:/mnt/docker/volumes#
root@mike-VirtualBox:/mnt/docker/volumes# docker ps 

CONTAINER ID   IMAGE       COMMAND                  CREATED             STATUS             PORTS                 NAMES
689a8fb8a0a3   mysql:5.7   "docker-entrypoint.s"   About an hour ago   Up About an hour   3306/tcp, 33060/tcp   mysqli

root@mike-VirtualBox:/mnt/docker/volumes# docker rm -fv mysqli
mysqli
root@mike-VirtualBox:/mnt/docker/volumes#


anonymous volumes are not recommended to companies unless they know what they are doing 
now there is another option is that you remove a container that created an anoymous volume without providing the letter "-v" then thge volume will not be deleted 
so let me go out of here and lets create another container with an anonymoous volume inside the docker host 

root@mike-VirtualBox:/mnt/docker/volumes# exit
exit
mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images/dockercommit$
docker run -d -e "MYSQL_ROOT_PASSWORD=12345678"  --name mysqli -v /var/lib/mysql mysql:5.7

so if you give enter and then you give docker volume ls you will see a new volume there and now if you remove that container without use the -v instruction 
then you only remove the container please check below 

mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images/dockercommit$ 
docker run -d -e "MYSQL_ROOT_PASSWORD=12345678" --name mysqli -v /var/lib/mysql  mysql:5.7
50c74067c937d614c72351cdda34ca75e8567891dc768ffa1505d8efd99c0fea
mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images/dockercommit$ docker volume ls
DRIVER    VOLUME NAME
local     8ba20793ff6fb3abe696067d32014028c2020e23b90eb464ff7d27dbaeb5fc58
mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images/dockercommit$ docker rm -f mysqli
mysqli
mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images/dockercommit$ docker volume ls
DRIVER    VOLUME NAME
local     8ba20793ff6fb3abe696067d32014028c2020e23b90eb464ff7d27dbaeb5fc58
mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images/dockercommit$ docker ps
CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES
mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images/dockercommit$


now the thing is what will you do if you have 20 30 or 50 volumes like this its going to be hard for you to understand what is this volume or 
what is the content of this volume  
so its actually becomes a dangling volume as its no longer associate to a container, so in future videos we ar going to understand what is a dangling volume 
how can we create them 
how can we remove them 
but 
for now what needs to be made understood is that a dangling volume is created when you provide this option  -v   and you pass any valid path
 e.g. " /var/lib/mysql  " inside of the container.......that will create a folder under the root directory with a random name 
 and if you remove the container without the -v flag the volume will be there but you will have problems trying to identified it  
 otherwise if you provide the -v instruction you will make everything like a little piece of awesomeness as you remove everything 
 e.g. you remove the container that create the volume the volume itself will be deleted with the container and that as it is said above it can be dangerous 
 if the volume has sensitive data 

 so now you understand what is an anonuymous volume.....cu around



 69.understand some differences when using volumes 
-----------------------------------------------------
hello and welcome back in this video we are going to learn whats the difference between an anonymous volume 
and a volume that you create is in docker volume create
ok so lets create two containers 


mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images/dockercommit$ 
docker run -d -e "MYSQL_ROOT_PASSWORD=12345678" --name mysqli -v /var/lib/mysql  mysql:5.7

the first container uses an anonymous volume via the "-v  /var/lib/mysql"
now if you type docker volume ls you are going to see that now i have an anonymous volume 
"3b8a62f30bbbb11e7f72e7a104fe11bf03a9044f152ee0224ce81e0028b95a4d"
that was created by the docker run command above because its not mapped to any volume 

 mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images/dockercommit$ docker run -d -e "MYSQL_ROOT_PASSWORD=12345" --name mysqli -v /var/lib/mysql mysql:5.7
Unable to find image 'mysql:5.7' locally
5.7: Pulling from library/mysql
a4b007099961: Pull complete
e2b610d88fd9: Pull complete
38567843b438: Pull complete
5fc423bf9558: Pull complete
aa8241dfe828: Pull complete
cc662311610e: Pull complete
9832d1192cf2: Pull complete
3f242378e320: Pull complete
cc65503c0186: Pull complete
ce8944d50437: Pull complete
597d59a9a424: Pull complete
Digest: sha256:c8f68301981a7224cc9c063fc7a97b6ef13cfc4142b4871d1a35c95777ce96f4
Status: Downloaded newer image for mysql:5.7
e399877b43b118534ad62579631832310816099767b2f154aa3b758cf2ebfc8d


mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images/dockercommit$ docker volume ls
DRIVER    VOLUME NAME
local     3b8a62f30bbbb11e7f72e7a104fe11bf03a9044f152ee0224ce81e0028b95a4d
mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images/dockercommit$




now we want to create a normal volume using " docker volume create  " and i give it a name " mysqlii  "

mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images/dockercommit$  docker volume create mysqlii
mysqlii
mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images/dockercommit$ \

and now if you list your volumes you are going to see two volumes on the line

mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images/dockercommit$ docker volume ls

DRIVER    VOLUME NAME
local     mysqlii
mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images/dockercommit$


mysqlii is not associated with any container...so now let me create a new Container that maps in the container the mysqlii volume
and this is achieved through a specific technique
 mysqlii:path inside the container......mysqlii:/var/lib/mysql

mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images/dockercommit$ 
docker run -d -v mysqlii:/var/lib/mysql  --name mysqlio -e "MYSQL_ROOT_PASSWORD=12345" mysql:5.7

now if we hit enter with a different --name mysqlio...from the previous container 
you see that the container gets created through the docker ps command......thats cool 



mike@mike-VirtualBox:~$ docker volume ls
DRIVER    VOLUME NAME
local     3b8a62f30bbbb11e7f72e7a104fe11bf03a9044f152ee0224ce81e0028b95a4d
local     mysqlii
mike@mike-VirtualBox:~$ cd Desktop/\
> ^C
mike@mike-VirtualBox:~$ cd Desktop/
mike@mike-VirtualBox:~/Desktop$ cd realstuff/
mike@mike-VirtualBox:~/Desktop/realstuff$ cd realstuff1/
mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1$ cd multistage/
mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage$ cd docker-images/
mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images$ cd dockercommit/
mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images/dockercommit$ docker ps

CONTAINER ID   IMAGE       COMMAND                  CREATED          STATUS          PORTS                 NAMES
e399877b43b1   mysql:5.7   "docker-entrypoint.s"   24 minutes ago   Up 24 minutes   3306/tcp, 33060/tcp   mysqli
mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images/dockercommit$


docker run -d -v mysqlii:/var/lib/mysql --name mysqlio -e "MYSQL_ROOT_PASSWORD=12345" mysql:5.7
1ecf1f55ad805167d63f10fc881a3a7705dc98da80f90399dc67e548b3b82e40
mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images/dockercommit$ docker ps
CONTAINER ID   IMAGE       COMMAND                  CREATED          STATUS          PORTS                 NAMES
1ecf1f55ad80   mysql:5.7   "docker-entrypoint.s"   11 seconds ago   Up 10 seconds   3306/tcp, 33060/tcp   mysqlio
e399877b43b1   mysql:5.7   "docker-entrypoint.s"   26 minutes ago   Up 26 minutes   3306/tcp, 33060/tcp   mysqli
mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images/dockercommit$


so now if you list your volume you still have two volumes so lets just go there i.e. to the mysqlii
but before we must be sudo.........then we get the docker info via " docker info | grep -i root "
and then if you take the path from the output and go there 
then you go to volumes you make an ls and you see all the volumes again 
the anony,mmous one and the one that you created and other data 

so if we go inside the anonymoys folder and the inside the _data and perform an ll
then you will see all the mysql files 
the same goes for the other volume that also has the _data folder has other mysql data


mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images/dockercommit$ sudo su

root@mike-virtualBox:/home/mike/Desktop/realstuff/realstuff1/multistage/docker-images/dockercommit#  docker info | grep -i root
Docker Root Dir: /mnt/docker
root@mike-virtualBox:/home/mike/Desktop/realstuff/realstuff1/multistage/docker-images/dockercommit#


so remember that the anonymous volume is associated to the container msqli and the one that we ve created is associated to the mysqlio container 
and so whats the difference ?
so the difference is when you create the volume which has a name....you know the name and you know that this name contains some data 
but if you take a look at the name of the anonuymous volume then the things get a little bit complicated
as you dnont really know what this contains...so thats one big difference 
the other difference which at the same time is the most important one is the anonymous volume is kind of temporary remember that if you provide the letter v
when you provide the when we removing the container then this volume will be gone 

so lets try to remove the containers using the v instruction.....docker rm -fv mysqli 
and when we list the volumes after that .........................docker volume ls 

you will see that the anonymous volume is gone, so all of the data that was here :  3b8a62f30bbbb11e7f72e7a104fe11bf03a9044f152ee0224ce81e0028b95a4d
is bassically lost 
 
now if i run the same remove container but now with the mysqlio.......docker rm -fv mysqlio 
and when we list the volumes after that .........................docker volume ls 

you see that your volume is still there as it is not depended on the container....we created alone through the 
docker volume create mysqlii and with that create command we make the volume to persist  and the same thing applies for bind volumes 
but 
remember that you cannot see bind volumes using this command.......docker volume ls 
because bind volumes are only a folder that you create somewhere and then you mapped that folder to your container and for that case 
if you remove the container using this instruction -fv then the volume will not be deleted 

so lets me just show you ......lets just create a mysql data folder in the current folder 


mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images/dockercommit$ mkdir mysqldatafolder
mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images/dockercommit$ ls mysqldatafolder/......of course you have nothing 

and then we are going to create a new container but now we are going to map this new folder to the container's path 
you can do it like this.....$PWD which means the current path.....and of course we can provide the folder that we just created 

mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images/dockercommit$
docker run  -d -v $PWD/mysqldatafolder:/var/lib/mysql --name mysqlioo -e "MYSQL_ROOT_PASSWORD=123478" mysql:5.7
1e3a2b891e9b99be5ad12e9eacd64b66cf285e836cf7078b391ec33d190bab6a


okay thats super nice we get our hash and now if we go to take a look at this folder ls mysqldatafolder/
we are going to see a lot of data there 


mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images/dockercommit$ ls mysqldatafolder/
auto.cnf    ca.pem           client-key.pem  ibdata1      ib_logfile1  mysql               private_key.pem  server-cert.pem  sys
ca-key.pem  client-cert.pem  ib_buffer_pool  ib_logfile0  ibtmp1       performance_schema  public_key.pem   server-key.pem
mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images/dockercommit$


so now if you go and remove the container " mysqlioo "....docker rm -fv mysql.....we are going to see that our container is gone but our volume folder
is still here with all of the information that the container is stored 
but the thing is you cannot see this volume in the volume ls as it is a folder that contains data.....
so you need to know the location of this volume, but i thing that is not a problem 
and well these are the key differences between these volumes 
you see that if you use anonymous volumes you can loose your data easily if you provide the v flag and if you dont provide the v flag then you will problems 
in the future to know which volume was associated to which container because you know that an anonymous volume doesn't have a clear name 
its just a random hash 

so now when you create a normal volume using the create command you will be able to track that volume using docker volume ls 
and even if you remove the container using the v instruction the volume and its data  will not be removed 
but remember that the volume that we create with the  docker volume create command is created under the root directory in docker 
and lastly if you create a folder and you map that folder to your container it becomes a bind volume and then it doesn;t really matter if you remove your 
container because all the information is inside the volume (in the folder in your localhost)  



70.Back to the dockerfile understand the VOLUME instruction
-----------------------------------------------------------
hello and welcome back in this lesson we are going to talk about anonymous volumes and dockerfiles i am going to show you 
something and that is that now i dont have any volumes images containers so lets go and create 
so now if i wanted to create an anonymous volume you know tha we must provide the -v (-v /var/lib/mysql)
but now let me show you something pretty weird so lets remove from the cotainers the " -v /var/lib/mysql "
so what happens then...should it create any volumes ?
                       should it create any anonymous volumes ?
                       should it create any volumes ?
                       so lets hit enter and see 
                       


mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images/dockercommit$ 
docker run -d  -e "MYSQL_ROOT_PASSWORD=12345678" --name mysqli  mysql:5.7
mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images/dockercommit$ 
docker volume ls 
DRIVER   VOLUME NAME
local    b960ca7c01388d93b5450a863a728d0ec3dd13ba7776a4c5e6b02e3130582d60
mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images/dockercommit$ 


so the container creates a volume....well let me tell you....its basically because in the docker file of MYSQL they have a docker file instruction 
which is called " volume "
so lets run the command " mkdir vol_test " and then if we go to this directory (which is going to be my context) through " cd vol_test/ " 
and then run the " ll " to see whats in there we get the perfect number of 0 
now in voltest we arew going to create a new dockerfile that 
starts from centos:7 and makes use of the new instruction that is called volume 
so probably in the mysql image in the official image in the dockerfile of that image they have 
from whatever 
...install mysql and kolokthia toumpana
and then they have volume instruction which means two things 
i. is that the path that you define in the volume instruction is that that will create the anonymous volume
   once you launch a container using this image 
ii.if you do a docker commit to turn the container into an image the volume that you specify here wont be included in the final image
   so lets take a look at this,
   so lets say that we want to create a new image starting from centos:7 and we want to provide the volume instruction below that specifies a specific path

volume /opt..................so what we are saying here is that we want to create an image and we want to create an anonymous volume which will be mapped to " /opt "
once the container is created 
and if you co9mmit that container then this path wont be included in the final image 
so lets try to build this image 

mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images/dockercommit/voltest$
docker build -t testvolume .

ok the build was succesful remember that the name is testvolume
so now if we take a look at our docker volume ls we will see an anonymous volume created there that was created by the mysql container 


mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images/dockercommit/voltest$ docker ps
CONTAINER ID   IMAGE       COMMAND                  CREATED          STATUS          PORTS                 NAMES
697713f511f8   mysql:5.7   "docker-entrypoint.s"   44 minutes ago   Up 44 minutes   3306/tcp, 33060/tcp   mysqlioo
mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images/dockercommit/voltest$


so now if we go and remove that container providing the v instruction you know that the anonymous volume that this container created 
will be removed as we provide the v argument below 

mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images/dockercommit/voltest$ docker rm -fv 697713f511f8
697713f511f8
mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images/dockercommit/voltest$ docker volume ls 
DRIVER VOLUME NAME
mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images/dockercommit/voltest$ 


so now that we have our image build the " testvolume " image remeber that this image has a volume at /opt path 
so now if we try to create a new container....docker run -dti --name testvvolumee (and finally we provide the name of the image) testvolume
                                                          (as we dont specify a cmd in the dockerfile to keep the centos alive) 

mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images/dockercommit/voltest$ docker run -dti --name testvvolumee testvolume
okay we get the hash 
now you type docker ps......you see that your container is up and running 
but if you type docker volume ls you will see that the container made an anonymous volume which is mapped to the container at " /opt " 
so now lets become sudo and go to our root info 

mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images/dockercommit/voltest$ sudo su 
root@mike-virtualBox:/home/mike/Desktop/realstuff/realstuff1/multistage/docker-images/dockercommit/voltest# docker info | grep -i root
Docker Root Dir: /mnt/docker
root@mike-virtualBox:/home/mike/Desktop/realstuff/realstuff1/multistage/docker-images/dockercommit/voltest#

and then if we go to this folder " cd /mnt/docker/volumes/ " and make an ll you will see that there you have your anonymous volume that 
is created by our container 
and this can be reassured if you typ docker volume ls

root@mike-virtualBox:/home/mike/Desktop/realstuff/realstuff1/multistage/docker-images/dockercommit/voltest# cd /mnt/docker/volumes/
root@mike-virtualBox:/mnt/docker/volumes# ll
test 44
drwx-----x  3 root root  4096 Mar 18 11:33 ./
drwx--x--- 13 root root  4096 Mar 15 10:49 ../
drwx-----x  3 root root  4096 Mar 18 11:33 ae00562f9f9abf44f8ab796ed009191275bc704a6d73dccb0161ff5752b3a1d1/
brw-------  1 root root  8, 1 Mar 15 10:49 backingFsBlockDev
-rw-------  1 root root 65536 Mar 18 11:33 metadata.db
root@mike-VirtualBox:/mnt/docker/volumes#


so if yo go inside this folder ae00562f9f9abf44f8ab796ed009191275bc704a6d73dccb0161ff5752b3a1d1 then you will find your friend there which is 
noone else from the _data folder and at this time you will find absolutely nothing in there because we haven't sdaved anything 

root@mike-VirtualBox:/mnt/docker/volumes# cd ae00562f9f9abf44f8ab796ed009191275bc704a6d73dccb0161ff5752b3a1d1/

root@mike-VirtualBox:/mnt/docker/volumes/ae00562f9f9abf44f8ab796ed009191275bc704a6d73dccb0161ff5752b3a1d1# ll
total 12
drwx-----x 3 root root 4096 Mar 18 11:33 ./
drwx-----x 3 root root 4096 Mar 18 11:33 ../
drwxr-xr-x 2 root root 4096 Apr 11  2018 _data/
root@mike-VirtualBox:/mnt/docker/volumes/ae00562f9f9abf44f8ab796ed009191275bc704a6d73dccb0161ff5752b3a1d1# cd _data
root@mike-VirtualBox:/mnt/docker/volumes/ae00562f9f9abf44f8ab796ed009191275bc704a6d73dccb0161ff5752b3a1d1/_data# ll
total 8
drwxr-xr-x 2 root root 4096 Apr 11  2018 ./
drwx-----x 3 root root 4096 Mar 18 11:33 ../
root@mike-VirtualBox:/mnt/docker/volumes/ae00562f9f9abf44f8ab796ed009191275bc704a6d73dccb0161ff5752b3a1d1/_data# ls
root@mike-VirtualBox:/mnt/docker/volumes/ae00562f9f9abf44f8ab796ed009191275bc704a6d73dccb0161ff5752b3a1d1/_data#


but if we go inside of that container and remember that in the dockerfile we specify the /opt/ folder as an anonymous volume 
and if we create files here say foe example touch file1.txt  file2.txt



root@mike-VirtualBox:/mnt/docker/volumes/ae00562f9f9abf44f8ab796ed009191275bc704a6d73dccb0161ff5752b3a1d1/_data# docker exec -ti ttestvvolume bash
[root@1584dae1a178 /]# cd /opt/
[root@1584dae1a178 opt]# touch file1.txt  file2.txt
[root@1584dae1a178 opt]# ll
total 0 
-rw-r--r-- 1 root root 0 Mar 18 16:15 file1.txt
-rw-r--r-- 1 root root 0 Mar 18 16:15 file2.txt
[root@1584dae1a178 opt]# exit 
exit 


and if we list the files in here then we will see that the files that we were created in the container are now in the root directory because remember 
that these folder are replicated they are basically mounted 
so anything that happens in the root directory here will be reflected inside of the container and vice versa 

root@mike-VirtualBox:/mnt/docker/volumes/ae00562f9f9abf44f8ab796ed009191275bc704a6d73dccb0161ff5752b3a1d1/_data# pwd
/mnt/docker/volumes/ae00562f9f9abf44f8ab796ed009191275bc704a6d73dccb0161ff5752b3a1d1/_data
root@mike-VirtualBox:/mnt/docker/volumes/ae00562f9f9abf44f8ab796ed009191275bc704a6d73dccb0161ff5752b3a1d1/_data# 

root@mike-VirtualBox:/mnt/docker/volumes/ae00562f9f9abf44f8ab796ed009191275bc704a6d73dccb0161ff5752b3a1d1/_data# ll
total 8
drwxr-xr-x 2 root root 4096 Mar 18 12:15 ./
drwx-----x 3 root root 4096 Mar 18 11:33 ../
-rw-r--r-- 1 root root    0 Mar 18 12:15 file1.txt
-rw-r--r-- 1 root root    0 Mar 18 12:15 file2.txt
root@mike-VirtualBox:/mnt/docker/volumes/ae00562f9f9abf44f8ab796ed009191275bc704a6d73dccb0161ff5752b3a1d1/_data#



so lets go and remove that container and see what happens well you know that if we remove the container using the -v   instruction
it will remove the anonymous volume that it created so what happens 
so what do you use anonymous volumes for well its basically to store information safely if you havent created a binded volume or a normal volume 
because if you remove the container without the letter -v then all the things that you added to that specific folder in your container  wont be deleted 
they will be in an anonymous volume so normally in the mysql image you will always find  a volume at /var/lib/mysql 
because they want to make sure if they dint provide a bind volume or a normal volume they wanna make sure that your data is kind of safe 
so if you remove the container without the letter v then you will not loose your info because it is in an anonymous volume 

then it going to be a liitle bit complicated to find but you know that is there the same thing happens normally with the apache server the nginx  image 
what the do is that they normaly put as a volume the web root directory so for apache it would be /var/www/html 

so if you create your container without a binding volume or without a normal volume thenh an anonymous volume will be created once you create your container 
and that volume will store information and that will give you the chance to save the information if tou remove the container without using the letter v 

so i hope that you understand how anonymous volumes work 
and please try to use bind volumes or normal volumes 


71.Dangling volumes.Yes here we have more dangling stuff
----------------------------------------------------------
hello and welcome back in this lesson we arew going to learn about dangling volumes
we are gong to tak e a look at what a dangling volume is and we are going to see how they are created and basically how we can remove them 
so you know alreaady that we can create anonymous volumes if we have spcify the volume instruction  in docker file or if manually type 
(-v) and provide a path inside of the container once you try to create a container using the cocker container 
so now lets create an anonymous volume using the docker run contruction
so if you see i have no containers and the same goes for volumes 
so now i am going to create a container through 
docker run -dti -v (and specify a random path like) /mnt  --name (and of course provide the centos image) centos:7


mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images/dockercommit$  docker run -dti -v /mnt  --name test centos:7

now we hit enter and we see that our container is running and if we take a look at our volumes there is one anonymous volume 
so now if we remove the container with the name "test" without the letter -v then the volume that is created with it wont be removed 
but if we add the letter -v in the container's remove then we remove its volume 

so in the case where we destroy the container without the letter "v" the volume will be still there, so for future use the name of the volume 
is the one below :

 4532d8ce4b2173c6db08c7b307cf3fa1c9b1cc9c655d971cce2b1e1ebd20bdec



mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images/dockercommit$ docker run -dti -v /mnt --name test centos:7
9bab225e4afc08eb4665728938495754441212d5009fb68a5ba0a6f61988809b

mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images/dockercommit$ docker volume ls
DRIVER    VOLUME NAME
local     4532d8ce4b2173c6db08c7b307cf3fa1c9b1cc9c655d971cce2b1e1ebd20bdec

mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images/dockercommit$ docker ps
CONTAINER ID   IMAGE      COMMAND       CREATED          STATUS         PORTS     NAMES
9bab225e4afc   centos:7   "/bin/bash"   10 seconds ago   Up 9 seconds             test

mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images/dockercommit$


so now lets create two containers test2 and test3

mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images/dockercommit$ docker run -dti -v /mnt --name test2 centos:7
f6f6efcb64d7009f3a021fd061d6851b3f7e47e89def0f686c257bb6eddc88a6

mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images/dockercommit$ docker run -dti -v /mnt --name test3 centos:7
c829a3cda43d72e404d1760963800f6435fb3c0f378018cecc91565f437ed51c

mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images/dockercommit$ docker volume ls
DRIVER    VOLUME NAME
local     6f1246ff51734586c0bd2ee1850e989d7836fcc43c778d70e2687e90d1e92573
local     47c4a1a066c1065a9afa3155380f52cef414be02b97ec83578039898ca9e32dc
local     4532d8ce4b2173c6db08c7b307cf3fa1c9b1cc9c655d971cce2b1e1ebd20bdec

mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage/docker-images/dockercommit$

and again we are going to remove them without the letter v and the via the docker ps -a or ps you see that you have no containers 
but through the docker volume ls you see that you have 3 anonymous volumes and these volumes are not mapped to any container
so they may be useful to you if the have they have any information there or otherwise they  
just be eating space, in this case i dont have any relevant information that i want to save in these volumes 
so basically through the "docker volume rm -f $(docker volume ls -q)" command
i want to delete these volumes with one hit :

 6f1246ff51734586c0bd2ee1850e989d7836fcc43c778d70e2687e90d1e92573
 47c4a1a066c1065a9afa3155380f52cef414be02b97ec83578039898ca9e32dc
 4532d8ce4b2173c6db08c7b307cf3fa1c9b1cc9c655d971cce2b1e1ebd20bdec


mike@mike-VirtualBox:~$ docker ps
CONTAINER ID   IMAGE      COMMAND       CREATED         STATUS         PORTS     NAMES
c829a3cda43d   centos:7   "/bin/bash"   4 minutes ago   Up 4 minutes             test3
f6f6efcb64d7   centos:7   "/bin/bash"   4 minutes ago   Up 4 minutes             test2
9bab225e4afc   centos:7   "/bin/bash"   7 minutes ago   Up 7 minutes             test

mike@mike-VirtualBox:~$ docker volume ls
DRIVER    VOLUME NAME
local     6f1246ff51734586c0bd2ee1850e989d7836fcc43c778d70e2687e90d1e92573
local     47c4a1a066c1065a9afa3155380f52cef414be02b97ec83578039898ca9e32dc
local     4532d8ce4b2173c6db08c7b307cf3fa1c9b1cc9c655d971cce2b1e1ebd20bdec

mike@mike-VirtualBox:~$ docker rm -f c829a3cda43d f6f6efcb64d7 9bab225e4afc
c829a3cda43d
f6f6efcb64d7
9bab225e4afc

mike@mike-VirtualBox:~$ docker volume ls
DRIVER    VOLUME NAME
local     6f1246ff51734586c0bd2ee1850e989d7836fcc43c778d70e2687e90d1e92573
local     47c4a1a066c1065a9afa3155380f52cef414be02b97ec83578039898ca9e32dc
local     4532d8ce4b2173c6db08c7b307cf3fa1c9b1cc9c655d971cce2b1e1ebd20bdec

mike@mike-VirtualBox:~$ docker volume rm -f $(docker volume ls -q)

but the thing is that what if you want to create a new container and this new container is running
and of course you are going to have a new volume but lets say that you didn't delete the three volumes above 
then doing a docker volume ls will make you a rock n roll drammer of iron maiden
as you arer not able to figure out who belongs to whom e.g. you will not be able to understand if volume    
6f1246ff51734586c0bd2ee1850e989d7836fcc43c778d70e2687e90d1e92573 belongs to container with the name test1 or test4
and also most important what volumes are being used and what volumes are not being used 
by a running container 
so to find out the answer to the second one we will take a look at the dangling volumes 

mike@mike-VirtualBox:~$ docker run -dti -v /mnt --name test2 centos:7
3730f469f622f1863eb9e3b0fcb10a69ba97748cfd8560f9bf71a3ab015a39b2
mike@mike-VirtualBox:~$ docker run -dti -v /mnt --name test3 centos:7
2189c22fc03cadebc0a342eb54545eb357b3e9ea7d0e640bf50bb306f98b3fc9

mike@mike-VirtualBox:~$ docker volume ls
DRIVER    VOLUME NAME
local     7a9dfad82313e1f2dbb4e8e891f8d83db2283a0583ffb51e887cd28acfc9e65e
local     84ae2c8f449ba49fb48e85e329c7e6c3c274b5f37f10a7545cf3522e3d358ba6
mike@mike-VirtualBox:~$ docker run -dti -v /mnt --name test4 centos:7
e2bfb276af491650152522fc965d5c582707883db121941b413c674821645ff2

mike@mike-VirtualBox:~$ docker ps
CONTAINER ID   IMAGE      COMMAND       CREATED              STATUS              PORTS     NAMES
e2bfb276af49   centos:7   "/bin/bash"   47 seconds ago       Up 46 seconds                 test4
2189c22fc03c   centos:7   "/bin/bash"   About a minute ago   Up About a minute             test3
3730f469f622   centos:7   "/bin/bash"   About a minute ago   Up About a minute             test2

mike@mike-VirtualBox:~$ docker volume ls
DRIVER    VOLUME NAME
local     7a9dfad82313e1f2dbb4e8e891f8d83db2283a0583ffb51e887cd28acfc9e65e
local     32f5362ad668939c26dcf004510d11d3cdd2b024c20d65af3553ee814a54e636..........container:test4
local     84ae2c8f449ba49fb48e85e329c7e6c3c274b5f37f10a7545cf3522e3d358ba6
mike@mike-VirtualBox:~$

so we are going to take a look at the dangling volumes...do you remember the concept of dangling images ?
well its basically the same thing, a dangling volume is nothing else but a volume that is no longer associated to any container 
and probably its only eating space since you are not using it, 
so how do you find those volumes ?
well you can type docker volumes ls and at the end you can provide a filter  flag (-f) and provide the keyword dangling=true   to check them out


mike@mike-VirtualBox:~$ docker volumes ls -f=dangling=true


mike@mike-VirtualBox:~$ docker volume ls -f=dangling=true
DRIVER    VOLUME NAME
mike@mike-VirtualBox:~$

mike@mike-VirtualBox:~$ docker ps
CONTAINER ID   IMAGE      COMMAND       CREATED          STATUS          PORTS     NAMES
e2bfb276af49   centos:7   "/bin/bash"   17 minutes ago   Up 17 minutes             test4
2189c22fc03c   centos:7   "/bin/bash"   18 minutes ago   Up 18 minutes             test3
3730f469f622   centos:7   "/bin/bash"   18 minutes ago   Up 18 minutes             test2
mike@mike-VirtualBox:~$

mike@mike-VirtualBox:~$ docker rm -f test3 test2
test3
test2

mike@mike-VirtualBox:~$ docker volume ls -f=dangling=true
DRIVER    VOLUME NAME
local     7a9dfad82313e1f2dbb4e8e891f8d83db2283a0583ffb51e887cd28acfc9e65e
local     84ae2c8f449ba49fb48e85e329c7e6c3c274b5f37f10a7545cf3522e3d358ba6

mike@mike-VirtualBox:~$ docker volume ls
DRIVER    VOLUME NAME
local     7a9dfad82313e1f2dbb4e8e891f8d83db2283a0583ffb51e887cd28acfc9e65e
local     32f5362ad668939c26dcf004510d11d3cdd2b024c20d65af3553ee814a54e636
local     84ae2c8f449ba49fb48e85e329c7e6c3c274b5f37f10a7545cf3522e3d358ba6
mike@mike-VirtualBox:~$

and from the above we can display all the volumes that are not associated to any container so the are mapped to ufo point
or in other words they are dangling volumes 
then if you add the -g in the filter out search you will go in jail probably i am just kidding
with -q you provide only the the id of something 
in this case we output the id of the dangling volumes that probably we want to delete them massively


mike@mike-VirtualBox:~$ docker volume ls -f=dangling=true -q
7a9dfad82313e1f2dbb4e8e891f8d83db2283a0583ffb51e887cd28acfc9e65e
84ae2c8f449ba49fb48e85e329c7e6c3c274b5f37f10a7545cf3522e3d358ba6

and the deletion comes through this:

mike@mike-VirtualBox:~$ docker volume rm -f $(docker volume ls -f=dangling=true -q)
7a9dfad82313e1f2dbb4e8e891f8d83db2283a0583ffb51e887cd28acfc9e65e
84ae2c8f449ba49fb48e85e329c7e6c3c274b5f37f10a7545cf3522e3d358ba6

basically with the parentheses we tell linux that we want to execute what is inside

mike@mike-VirtualBox:~$ docker volume ls -f=dangling=true
DRIVER  VOLUME NAME
mike@mike-VirtualBox:~$ 

mike@mike-VirtualBox:~$ docker volume ls 
DRIVER    VOLUME NAME
local     32f5362ad668939c26dcf004510d11d3cdd2b024c20d65af3553ee814a54e636
mike@mike-VirtualBox:~$ 


the volume that we bring last is the ne that we cannot destroy as it is used by container test4

so this is how you find and remove dangling volumes and yes try to use bind or normal volumes



72.MongoDB -Persist data in a NoSQL container
---------------------------------------------
hello in this lesson we are going to talk about how to persist data in a mongodb docker container 
so it comes the question that always you must do to yourself when you create a container and you 
want to persist the data is what folder do i save?
and if you dont know the answer you can always go to google and try to find it 
so in here we can search for "docker mongo"
and normally in the documentation we can always find those things, so we can try to search for 
"volumes" and then it says somewhere the following :
"1. create a data directory on a suitable volume on your host system e.g. /my/own/datadir ."
"2. start your mongo container like this: "
 $ docker run --name some-mongo -v /my/own/datadir:/data/db -d mongo

 and the thing is  that this container is saving the information at "/data/db"
 now that we know that we need to use, we can make it sure....i.e. in the search box that is displayed through the ctrl+f
 we search for this folder : "/data/db" aaand we find it 
 it says -v your directory to the directory ("/data/db") of the container that will mount your directory from your docker host to "/data/db"
whic is a location inside of the container 
and in this folder mongo by default write all ofn its data, so we found a directory that we want to save 
so now we can go to our terminal and we try to run one container 
so we go to "mnt" via "cd /mnt/" and then in there we create a mongo folder with "sudo mkdir mongo" 
so now we create a directory here and the path for that directory is " ls /mnt/mongo/ "

and now we are going to ceate a new container there 
             via -v we map the /mnt/mongo/ to the container /dat/db and throu -p we expose the port   27017 as this is the port on our host
             and we can map it to exactly the same port inside of our container 
             so ok what else are we missing ok anything else but the name of the image which is mongo and you are all set 
mike@mike-VirtualBox:/mnt$ docker run -d --name mongo -v /mnt/mongo/:/dat/db -p 27017:27017 mongo
.......
status: downloaded newer image for mongo:latest
16c44dcea23fc77c6c57a01fc3e6be64c7127025ca20735809590497c9df5c83
mike@mike-VirtualBox:/mnt$ 

so now i type docker ps and see that your mongo container is up and running 


mike@mike-VirtualBox:/mnt$ docker ps
CONTAINER ID   IMAGE      COMMAND       CREATED       STATUS       PORTS     NAMES
e2bfb276af49   centos:7   "/bin/bash"   2 hours ago   Up 2 hours             test4

and now if you do ls to the mongo directory......ls /mnt/mongo/...... mike@mike-VirtualBox:/mnt$ ls /mnt/mongo/

you will see a lot of files that are being generated by thcontainer above....so its super cool  


now for some weird reason my mongo image is exited by the time of its creation
now the thing is that we use mongo:4.0 version and this container is up and down at the same time 
and the data are not generated to mongo db folder

mike@mike-VirtualBox:/mnt$ sudo docker run -t -i -v /mnt/mongo/:dat/db  --name mongo -p 27017:27017 -d mongo:4.0
[sudo] password for mike:
Unable to find image 'mongo:4.0' locally
4.0: Pulling from library/mongo
58690f9b18fc: Pull complete
b51569e7c507: Pull complete
da8ef40b9eca: Pull complete
fb15d46c38dc: Pull complete
8c5b4403b3cc: Pull complete
a336ecd37208: Pull complete
12c733cd45a4: Pull complete
0500d06255ed: Pull complete
94973a063374: Pull complete
6311dd69caf7: Pull complete
b40f828abab8: Pull complete
8379d13e9da6: Pull complete
12fa2eef4452: Pull complete
Digest: sha256:661ae58fb8cb3a1e13506e8c6490666293e4afec5df91e600860ddc077099c49
Status: Downloaded newer image for mongo:4.0
docker: Error response from daemon: invalid volume specification: '/mnt/mongo/:dat/db': invalid mount config for type "bind": invalid mount path: 'dat/db' mount path must be absolute.
See 'docker run --help'.
mike@mike-VirtualBox:/mnt$ sudo docker run -t -i -v /mnt/mongo/:/dat/db  --name mongoo -p 8080:27017 -d mongo:4.0
4fd41d9d67cedd05afced0d39d276d5cc332245c42ee76dedf66b0184ce0db9c

mike@mike-VirtualBox:/mnt$ docker ps
CONTAINER ID   IMAGE       COMMAND                  CREATED          STATUS         PORTS                                         NAMES
4fd41d9d67ce   mongo:4.0   "docker-entrypoint.s"   10 seconds ago   Up 9 seconds   0.0.0.0:8080->27017/tcp, :::8080->27017/tcp   mongoo
mike@mike-VirtualBox:/mnt$ ll /mnt/mongo/
total 8
drwxr-xr-x 2 root root 4096 Mar 21 06:42 ./
drwxr-xr-x 5 root root 4096 Mar 21 06:42 ../
mike@mike-VirtualBox:/mnt$

mike@mike-VirtualBox:/mnt$ docker ps -a
CONTAINER ID   IMAGE       COMMAND                  CREATED         STATUS         PORTS                                         NAMES
4fd41d9d67ce   mongo:4.0   "docker-entrypoint.s"   3 minutes ago   Up 3 minutes   0.0.0.0:8080->27017/tcp, :::8080->27017/tcp   mongoo

mike@mike-VirtualBox:/mnt$ cd mongo

------not generated........
mike@mike-VirtualBox:/mnt/mongo$ ll
total 8
drwxr-xr-x 2 root root 4096 Mar 21 06:42 ./
drwxr-xr-x 5 root root 4096 Mar 21 06:42 ../
mike@mike-VirtualBox:/mnt/mongo$

and the weird thing is even inside the container the files are not existed but when i put the port on the browser
it seems that is working but with specific tags..... e.g.

mike@mike-VirtualBox:/mnt$ docker run -d -p 27017:27017 --name testm -v /mnt/mongo/:/dat/db mongo:4-focal
Unable to find image 'mongo:4-focal' locally
4-focal: Pulling from library/mongo
4d32b49e2995: Pull complete
26a89ffa9c8e: Pull complete
c6a26a1adeb9: Pull complete
0f6c4ca429ae: Pull complete
87cd51bf7ebc: Pull complete
f15136b3b3dc: Pull complete
e5c41ea5e760: Pull complete
1243afbc143d: Pull complete
6a81d9de0fd7: Pull complete
d895b406e4e5: Pull complete
Digest: sha256:723a7724dbe9574c997fa1e221c2fa5e8b5d9e84757ba3f71f7378fd1462456d
Status: Downloaded newer image for mongo:4-focal
466da5ba639e3548e755351f034ebe12c4a7b3b3b5804a59ed70492c45c4eaaa


mike@mike-VirtualBox:/mnt$ docker ps
CONTAINER ID   IMAGE           COMMAND                  CREATED          STATUS          PORTS                                           NAMES
466da5ba639e   mongo:4-focal   "docker-entrypoint.s"   14 seconds ago   Up 12 seconds   0.0.0.0:27017->27017/tcp, :::27017->27017/tcp   testm

mike@mike-VirtualBox:/mnt$ docker ps -a
CONTAINER ID   IMAGE           COMMAND                  CREATED          STATUS          PORTS                                           NAMES
466da5ba639e   mongo:4-focal   "docker-entrypoint.s"   24 seconds ago   Up 22 seconds   0.0.0.0:27017->27017/tcp, :::27017->27017/tcp   testm


mike@mike-VirtualBox:/mnt$ cd mongo
mike@mike-VirtualBox:/mnt/mongo$ ll
total 8
drwxr-xr-x 2 root root 4096 Mar 21 06:42 ./
drwxr-xr-x 5 root root 4096 Mar 21 06:42 ../
mike@mike-VirtualBox:/mnt/mongo$


what is happening.......lets move on and see, we get inside the "testm" container now and remember that the data are living inside the data/db folder 
lets give that (remeber the tag mongo:4-focal ) and now we are see some stuff.....and the same stuff must be existed in our docker host in "mnt/mongo folder"


mike@mike-VirtualBox:/mnt$ docker exec -ti testm bash

root@466da5ba639e:/# cd /data/db
root@466da5ba639e:/data/db# ll
total 240
drwxr-xr-x 4 mongodb mongodb  4096 Mar 21 13:05 ./
drwxr-xr-x 4 root    root     4096 Mar 19 23:12 ../
-rw------- 1 mongodb mongodb    50 Mar 21 12:24 WiredTiger
-rw------- 1 mongodb mongodb    21 Mar 21 12:24 WiredTiger.lock
-rw------- 1 mongodb mongodb  1471 Mar 21 13:05 WiredTiger.turtle
-rw------- 1 mongodb mongodb 69632 Mar 21 13:05 WiredTiger.wt
-rw------- 1 mongodb mongodb  4096 Mar 21 12:24 WiredTigerHS.wt
-rw------- 1 mongodb mongodb 20480 Mar 21 12:25 _mdb_catalog.wt
-rw------- 1 mongodb mongodb 20480 Mar 21 12:25 collection-0-6776611829703951088.wt
-rw------- 1 mongodb mongodb 20480 Mar 21 12:25 collection-2-6776611829703951088.wt
-rw------- 1 mongodb mongodb  4096 Mar 21 12:24 collection-4-6776611829703951088.wt
drwx------ 2 mongodb mongodb  4096 Mar 21 13:06 diagnostic.data/
-rw------- 1 mongodb mongodb 20480 Mar 21 12:25 index-1-6776611829703951088.wt
-rw------- 1 mongodb mongodb 20480 Mar 21 12:25 index-3-6776611829703951088.wt
-rw------- 1 mongodb mongodb  4096 Mar 21 12:24 index-5-6776611829703951088.wt
-rw------- 1 mongodb mongodb  4096 Mar 21 12:24 index-6-6776611829703951088.wt
drwx------ 2 mongodb mongodb  4096 Mar 21 12:24 journal/
-rw------- 1 mongodb mongodb     2 Mar 21 12:24 mongod.lock
-rw------- 1 mongodb mongodb 20480 Mar 21 12:26 sizeStorer.wt
-rw------- 1 mongodb mongodb   114 Mar 21 12:24 storage.bson
root@466da5ba639e:/data/db#


so cool lets try to create some data here some persisted data 
so we can type "mongo" and hit enter and the we will see the real deal i.e. we will be redirected to the mongo console where there 
we go to create a database 

MongoDB shell version v4.4.13
connecting to: mongodb://127.0.0.1:27017/?compressors=disabled&gssapiServiceName=mongodb
Implicit session: session { "id" : UUID("a76af5b1-7aa5-4c3e-b022-8ed312df6f89") }
MongoDB server version: 4.4.13
Welcome to the MongoDB shell.
For interactive help, type "help".
For more comprehensive documentation, see
https://docs.mongodb.com/
Questions? Try the MongoDB Developer Community Forums
https://community.mongodb.com
---
The server generated these startup warnings when booting:
        2022-03-21T12:24:41.949+00:00: Using the XFS filesystem is strongly recommended with the WiredTiger storage engine. See http://dochub.mongodb.org/core/prodnotes-filesystem
        2022-03-21T12:24:42.534+00:00: Access control is not enabled for the database. Read and write access to data and configuration is unrestricted
---
---
        Enable MongoDB's free cloud-based monitoring service, which will then receive and display
        metrics about your deployment (disk utilization, CPU, operation statistics, etc).

        The monitoring data will be available on a MongoDB website with a unique URL accessible to you
        and anyone you share the URL with. MongoDB may use this information to make product
        improvements and to suggest MongoDB products and deployment options to you.

        To enable free monitoring, run the following command: db.enableFreeMonitoring()
        To permanently disable this reminder, run the following command: db.disableFreeMonitoring()
---
>


first lets display the default databases through the "show dbs" and then create a database through the command "use mydb" where mydb is the name
and then insertb some data in "mydb"...from the time that we use a specific db the data are inserted there 
>show dbs
admin  0.000GB
config 0.000GB
local  0.000GB

>use mydb
switched to db mydb
>db.movie.insert ({"name":"tutorials point"})
WriteResult({ "iInserted" " 1})
>

and now mydb contains which contains a simple document with a key (name) and a value (tutorials point) 

so here inside the container we have a database lets exit now 

and we basically we are going to delete the container and searvh for the volume but as a logic person 
from the time that the data are not mounted to /mnt/mongo folder in the docker host i am not going to delete anything
even though some guy on udemy told you that your data is safe and green horses.... 
"docker rm -fv container id"
if i dont find my data first in my volume so we simply exit from the container and lets go to find the volume

>exit
bye 

root@466da5ba639e:/data/db#exit
exit 
mike@mike-VirtualBox:/mnt$ 


now another thing here is that the container above create two volumes......

mike@mike-VirtualBox:/$ docker volume ls
DRIVER    VOLUME NAME
local     9e3c3fbaffbce76b3aab70034af0377a7973c2e9b2309d2f5b1664d91c3f80ae
local     dc0ddf7063bdf753809037567f91c0b9657fbd40dc6b4573a043ccf81d1226a4

mike@mike-VirtualBox:/$ docker images
REPOSITORY   TAG       IMAGE ID       CREATED        SIZE
mongo        4-focal   fd8d12514c6b   38 hours ago   438MB
mike@mike-VirtualBox:/$















--------------------------------------------------a------------------------------------------------

mike@mike-VirtualBox:/$ docker exec -ti testm bash
root@c85c1aed3b70:/# ll /data/db
total 300
drwxr-xr-x 4 mongodb mongodb  4096 Mar 21 13:38 ./
drwxr-xr-x 4 root    root     4096 Mar 19 23:12 ../
-rw------- 1 mongodb mongodb    50 Mar 21 13:36 WiredTiger
-rw------- 1 mongodb mongodb    21 Mar 21 13:36 WiredTiger.lock
-rw------- 1 mongodb mongodb  1466 Mar 21 13:38 WiredTiger.turtle
-rw------- 1 mongodb mongodb 73728 Mar 21 13:38 WiredTiger.wt
-rw------- 1 mongodb mongodb  4096 Mar 21 13:36 WiredTigerHS.wt
-rw------- 1 mongodb mongodb 36864 Mar 21 13:38 _mdb_catalog.wt
-rw------- 1 mongodb mongodb 20480 Mar 21 13:37 collection-0--7522652413938340838.wt
-rw------- 1 mongodb mongodb 20480 Mar 21 13:37 collection-2--7522652413938340838.wt
-rw------- 1 mongodb mongodb  4096 Mar 21 13:36 collection-4--7522652413938340838.wt
-rw------- 1 mongodb mongodb 20480 Mar 21 13:38 collection-7--7522652413938340838.wt
drwx------ 2 mongodb mongodb  4096 Mar 21 13:38 diagnostic.data/
-rw------- 1 mongodb mongodb 20480 Mar 21 13:37 index-1--7522652413938340838.wt
-rw------- 1 mongodb mongodb 20480 Mar 21 13:37 index-3--7522652413938340838.wt
-rw------- 1 mongodb mongodb  4096 Mar 21 13:36 index-5--7522652413938340838.wt
-rw------- 1 mongodb mongodb  4096 Mar 21 13:36 index-6--7522652413938340838.wt
-rw------- 1 mongodb mongodb 20480 Mar 21 13:38 index-8--7522652413938340838.wt
drwx------ 2 mongodb mongodb  4096 Mar 21 13:36 journal/
-rw------- 1 mongodb mongodb     2 Mar 21 13:36 mongod.lock
-rw------- 1 mongodb mongodb 20480 Mar 21 13:38 sizeStorer.wt
-rw------- 1 mongodb mongodb   114 Mar 21 13:36 storage.bson
root@c85c1aed3b70:/# exit
exit
--------------------------------------------------a------------------------------------------------


now what we are going to do is to find our root directory as the mongo folder has not a thing inside it 


mike@mike-VirtualBox:/$ docker info | grep -i root
warning : no swap limit support
Docker root Dir: /mnt/docker

mike@mike-VirtualBox:/$ ll mnt/docker/
ls cannot open direcctory 'mnt/docker' : permission denied
mike@mike-VirtualBox:/mnt$ sudo su

now we are going to find the folder volumes which contains all the volumes that we have created 

root@mike-virtualBox:/mnt/docker#ll 
total 20
root@mike-VirtualBox:/mnt# ll
total 20
drwxr-xr-x  5 root    root 4096 Mar 21 06:42 ./
drwxr-xr-x 25 root    root 4096 Mar 21 07:30 ../
drwx--x--- 13 root    root 4096 Mar 15 10:49 docker/
drwxr-xr-x  2 root    root 4096 Mar 21 06:42 mongo/
drwxr-xr-x  6 vboxadd root 4096 Mar 16 12:06 mysql/
root@mike-VirtualBox:/mnt# cd docker
root@mike-VirtualBox:/mnt/docker# ll
total 60
drwx--x--- 13 root root  4096 Mar 15 10:49 ./
drwxr-xr-x  5 root root  4096 Mar 21 06:42 ../
drwx--x--x  4 root root  4096 Mar  1 05:47 buildkit/
drwx--x---  3 root root  4096 Mar 21 09:36 containers/
drwx------  3 root root  4096 Mar  1 05:47 image/
drwxr-x---  3 root root  4096 Mar  1 05:47 network/
drwx--x--- 15 root root 12288 Mar 21 09:36 overlay2/
drwx------  4 root root  4096 Mar  1 05:47 plugins/
drwx------  2 root root  4096 Mar 15 10:49 runtimes/
drwx------  2 root root  4096 Mar  1 05:47 swarm/
drwx------  3 root root  4096 Mar 21 09:36 tmp/
drwx------  2 root root  4096 Mar  1 05:47 trust/
drwx-----x  4 root root  4096 Mar 21 09:36 volumes/


root@mike-VirtualBox:/mnt/docker# cd volumes
root@mike-VirtualBox:/mnt/docker/volumes# ll
total 48
drwx-----x  4 root root  4096 Mar 21 09:36 ./
drwx--x--- 13 root root  4096 Mar 15 10:49 ../
drwx-----x  3 root root  4096 Mar 21 09:36 9e3c3fbaffbce76b3aab70034af0377a7973c2e9b2309d2f5b1664d91c3f80ae/
brw-------  1 root root  8, 1 Mar 15 10:49 backingFsBlockDev
drwx-----x  3 root root  4096 Mar 21 09:36 dc0ddf7063bdf753809037567f91c0b9657fbd40dc6b4573a043ccf81d1226a4/
-rw-------  1 root root 65536 Mar 21 09:36 metadata.db

as it is depicted above we have two volumes created by one container lets search inside these two to find something 




root@mike-VirtualBox:/mnt/docker/volumes# cd 9e3c3fbaffbce76b3aab70034af0377a7973c2e9b2309d2f5b1664d91c3f80ae/
root@mike-VirtualBox:/mnt/docker/volumes/9e3c3fbaffbce76b3aab70034af0377a7973c2e9b2309d2f5b1664d91c3f80ae# ll
total 12
drwx-----x 3 root    root   4096 Mar 21 09:36 ./
drwx-----x 4 root    root   4096 Mar 21 09:36 ../
drwxr-xr-x 2 vboxadd vboxsf 4096 Mar 19 19:12 _data/
root@mike-VirtualBox:/mnt/docker/volumes/9e3c3fbaffbce76b3aab70034af0377a7973c2e9b2309d2f5b1664d91c3f80ae# cd _data
root@mike-VirtualBox:/mnt/docker/volumes/9e3c3fbaffbce76b3aab70034af0377a7973c2e9b2309d2f5b1664d91c3f80ae/_data# ll
total 8
drwxr-xr-x 2 vboxadd vboxsf 4096 Mar 19 19:12 ./
drwx-----x 3 root    root   4096 Mar 21 09:36 ../
root@mike-VirtualBox:/mnt/docker/volumes/9e3c3fbaffbce76b3aab70034af0377a7973c2e9b2309d2f5b1664d91c3f80ae/_data# cd ..
root@mike-VirtualBox:/mnt/docker/volumes/9e3c3fbaffbce76b3aab70034af0377a7973c2e9b2309d2f5b1664d91c3f80ae# cd ..



root@mike-VirtualBox:/mnt/docker/volumes# cd dc0ddf7063bdf753809037567f91c0b9657fbd40dc6b4573a043ccf81d1226a4/
root@mike-VirtualBox:/mnt/docker/volumes/dc0ddf7063bdf753809037567f91c0b9657fbd40dc6b4573a043ccf81d1226a4# ll
total 12
drwx-----x 3 root    root   4096 Mar 21 09:36 ./
drwx-----x 4 root    root   4096 Mar 21 09:36 ../
drwxr-xr-x 4 vboxadd vboxsf 4096 Mar 21 09:48 _data/
root@mike-VirtualBox:/mnt/docker/volumes/dc0ddf7063bdf753809037567f91c0b9657fbd40dc6b4573a043ccf81d1226a4# cd _data/
root@mike-VirtualBox:/mnt/docker/volumes/dc0ddf7063bdf753809037567f91c0b9657fbd40dc6b4573a043ccf81d1226a4/_data# ll
total 320
--------------------------------------------------a------------------------------------------------
drwxr-xr-x 4 vboxadd vboxsf  4096 Mar 21 09:49 ./
drwx-----x 3 root    root    4096 Mar 21 09:36 ../
-rw------- 1 vboxadd vboxsf 20480 Mar 21 09:37 collection-0--7522652413938340838.wt
-rw------- 1 vboxadd vboxsf 20480 Mar 21 09:37 collection-2--7522652413938340838.wt
-rw------- 1 vboxadd vboxsf  4096 Mar 21 09:36 collection-4--7522652413938340838.wt
-rw------- 1 vboxadd vboxsf 20480 Mar 21 09:38 collection-7--7522652413938340838.wt
drwx------ 2 vboxadd vboxsf  4096 Mar 21 09:49 diagnostic.data/
-rw------- 1 vboxadd vboxsf 20480 Mar 21 09:37 index-1--7522652413938340838.wt
-rw------- 1 vboxadd vboxsf 20480 Mar 21 09:37 index-3--7522652413938340838.wt
-rw------- 1 vboxadd vboxsf  4096 Mar 21 09:36 index-5--7522652413938340838.wt
-rw------- 1 vboxadd vboxsf  4096 Mar 21 09:36 index-6--7522652413938340838.wt
-rw------- 1 vboxadd vboxsf 20480 Mar 21 09:38 index-8--7522652413938340838.wt
drwx------ 2 vboxadd vboxsf  4096 Mar 21 09:36 journal/
-rw------- 1 vboxadd vboxsf 36864 Mar 21 09:38 _mdb_catalog.wt
-rw------- 1 vboxadd vboxsf     2 Mar 21 09:36 mongod.lock
-rw------- 1 vboxadd vboxsf 36864 Mar 21 09:39 sizeStorer.wt
-rw------- 1 vboxadd vboxsf   114 Mar 21 09:36 storage.bson
-rw------- 1 vboxadd vboxsf    50 Mar 21 09:36 WiredTiger
-rw------- 1 vboxadd vboxsf  4096 Mar 21 09:36 WiredTigerHS.wt
-rw------- 1 vboxadd vboxsf    21 Mar 21 09:36 WiredTiger.lock
-rw------- 1 vboxadd vboxsf  1471 Mar 21 09:49 WiredTiger.turtle
-rw------- 1 vboxadd vboxsf 77824 Mar 21 09:49 WiredTiger.wt
--------------------------------------------------a------------------------------------------------
so yes our data are in the volume dc0ddf7063bdf753809037567f91c0b9657fbd40dc6b4573a043ccf81d1226a4
if you want check the two a
so for the time we cannot use the flag -v to delete our container because this means the delation of the vloume above and the consequence is to loose 
our data so what must be done here is to create a volume manually and map that to the conntainer (data/db) instead of the /mnt/mongo folder 
and then we are able to destroy the container create a new that mounts the same volume and the we can find our database together with its data there 
so as you see volumes are quite powerful as they allow you to save information and you can make sure that your data will persist even if your container is 
not alive 




-------------------------------------------------------------------------  whole ----------------------------------------------------------
------------------------------------------------------------------------- attempt ---------------------------------------------------------

mike@mike-VirtualBox:/$ docker volume ls
DRIVER    VOLUME NAME
local     9e3c3fbaffbce76b3aab70034af0377a7973c2e9b2309d2f5b1664d91c3f80ae
local     dc0ddf7063bdf753809037567f91c0b9657fbd40dc6b4573a043ccf81d1226a4


mike@mike-VirtualBox:/$ docker images
REPOSITORY   TAG       IMAGE ID       CREATED        SIZE
mongo        4-focal   fd8d12514c6b   38 hours ago   438MB

mike@mike-VirtualBox:/$ ls /mnt/mongo/
mike@mike-VirtualBox:/$ docker info | grep -i root
WARNING: No swap limit support
 Docker Root Dir: /mnt/docker

mike@mike-VirtualBox:/$ ll mnt/docker/
ls: cannot open directory 'mnt/docker/': Permission denied
mike@mike-VirtualBox:/$ sudo ll /mnt/docker
[sudo] password for mike:
sudo: ll: command not found

mike@mike-VirtualBox:/$ sudo ls /mnt/docker/
buildkit  containers  image  network  overlay2 plugins  runtimes  swarm  tmp  trust  volumes
mike@mike-VirtualBox:/$ cd volumes

bash: cd: volumes: No such file or directory
mike@mike-VirtualBox:/$ cd mnt
mike@mike-VirtualBox:/mnt$ ll
total 20
drwxr-xr-x  5 root    root 4096 Mar 21 06:42 ./
drwxr-xr-x 25 root    root 4096 Mar 21 07:30 ../
drwx--x--- 13 root    root 4096 Mar 15 10:49 docker/
drwxr-xr-x  2 root    root 4096 Mar 21 06:42 mongo/
drwxr-xr-x  6 vboxadd root 4096 Mar 16 12:06 mysql/
mike@mike-VirtualBox:/mnt$ cd docker
bash: cd: docker: Permission denied

mike@mike-VirtualBox:/mnt$ ll
total 20
drwxr-xr-x  5 root    root 4096 Mar 21 06:42 ./
drwxr-xr-x 25 root    root 4096 Mar 21 07:30 ../
drwx--x--- 13 root    root 4096 Mar 15 10:49 docker/
drwxr-xr-x  2 root    root 4096 Mar 21 06:42 mongo/
drwxr-xr-x  6 vboxadd root 4096 Mar 16 12:06 mysql/
mike@mike-VirtualBox:/mnt$ sudo mongo
sudo: mongo: command not found
mike@mike-VirtualBox:/mnt$ sudo cd  mongo/
sudo: cd: command not found

mike@mike-VirtualBox:/mnt$ cd mongo
mike@mike-VirtualBox:/mnt/mongo$ ll
total 8
drwxr-xr-x 2 root root 4096 Mar 21 06:42 ./
drwxr-xr-x 5 root root 4096 Mar 21 06:42 ../
mike@mike-VirtualBox:/mnt/mongo$ cd ..
mike@mike-VirtualBox:/mnt$ cd docker
bash: cd: docker: Permission denied
mike@mike-VirtualBox:/mnt$ sudo cd docker
sudo: cd: command not found
mike@mike-VirtualBox:/mnt$ sudo cd docker/
sudo: cd: command not found
mike@mike-VirtualBox:/mnt$ cd docker/
bash: cd: docker/: Permission denied
mike@mike-VirtualBox:/mnt$ sudo cd docker/
sudo: cd: command not found
mike@mike-VirtualBox:/mnt$ sudo cd /docker/
sudo: cd: command not found
mike@mike-VirtualBox:/mnt$ cd mysql
mike@mike-VirtualBox:/mnt/mysql$ ll
total 188488
drwxr-xr-x 6 vboxadd root       4096 Mar 16 12:06 ./
drwxr-xr-x 5 root    root       4096 Mar 21 06:42 ../
-rw-r----- 1 vboxadd vboxsf       56 Mar 16 11:14 auto.cnf
-rw------- 1 vboxadd vboxsf     1680 Mar 16 11:14 ca-key.pem
-rw-r--r-- 1 vboxadd vboxsf     1112 Mar 16 11:14 ca.pem
-rw-r--r-- 1 vboxadd vboxsf     1112 Mar 16 11:14 client-cert.pem
-rw------- 1 vboxadd vboxsf     1676 Mar 16 11:14 client-key.pem
-rw-r----- 1 vboxadd vboxsf     1352 Mar 16 11:14 ib_buffer_pool
-rw-r----- 1 vboxadd vboxsf 79691776 Mar 16 11:51 ibdata1
-rw-r----- 1 vboxadd vboxsf 50331648 Mar 16 11:51 ib_logfile0
-rw-r----- 1 vboxadd vboxsf 50331648 Mar 16 11:14 ib_logfile1
-rw-r----- 1 vboxadd vboxsf 12582912 Mar 16 11:51 ibtmp1
drwxr-x--- 2 vboxadd vboxsf     4096 Mar 16 11:14 mysql/
drwxr-x--- 2 vboxadd vboxsf     4096 Mar 16 11:14 performance_schema/
-rw------- 1 vboxadd vboxsf     1680 Mar 16 11:14 private_key.pem
-rw-r--r-- 1 vboxadd vboxsf      452 Mar 16 11:14 public_key.pem
-rw-r--r-- 1 vboxadd vboxsf     1112 Mar 16 11:14 server-cert.pem
-rw------- 1 vboxadd vboxsf     1680 Mar 16 11:14 server-key.pem
drwxr-x--- 2 vboxadd vboxsf    12288 Mar 16 11:14 sys/
drwxr-x--- 2 vboxadd vboxsf     4096 Mar 16 11:25 testdb/
-rw-r--r-- 1 root    root          0 Mar 16 12:06 testfile
mike@mike-VirtualBox:/mnt/mysql$ cd ..
mike@mike-VirtualBox:/mnt$ sudo su
root@mike-VirtualBox:/mnt# ll
total 20
drwxr-xr-x  5 root    root 4096 Mar 21 06:42 ./
drwxr-xr-x 25 root    root 4096 Mar 21 07:30 ../
drwx--x--- 13 root    root 4096 Mar 15 10:49 docker/
drwxr-xr-x  2 root    root 4096 Mar 21 06:42 mongo/
drwxr-xr-x  6 vboxadd root 4096 Mar 16 12:06 mysql/
root@mike-VirtualBox:/mnt# cd docker
root@mike-VirtualBox:/mnt/docker# ll
total 60
drwx--x--- 13 root root  4096 Mar 15 10:49 ./
drwxr-xr-x  5 root root  4096 Mar 21 06:42 ../
drwx--x--x  4 root root  4096 Mar  1 05:47 buildkit/
drwx--x---  3 root root  4096 Mar 21 09:36 containers/
drwx------  3 root root  4096 Mar  1 05:47 image/
drwxr-x---  3 root root  4096 Mar  1 05:47 network/
drwx--x--- 15 root root 12288 Mar 21 09:36 overlay2/
drwx------  4 root root  4096 Mar  1 05:47 plugins/
drwx------  2 root root  4096 Mar 15 10:49 runtimes/
drwx------  2 root root  4096 Mar  1 05:47 swarm/
drwx------  3 root root  4096 Mar 21 09:36 tmp/
drwx------  2 root root  4096 Mar  1 05:47 trust/
drwx-----x  4 root root  4096 Mar 21 09:36 volumes/
root@mike-VirtualBox:/mnt/docker# cd volumes
root@mike-VirtualBox:/mnt/docker/volumes# ll
total 48
drwx-----x  4 root root  4096 Mar 21 09:36 ./
drwx--x--- 13 root root  4096 Mar 15 10:49 ../
drwx-----x  3 root root  4096 Mar 21 09:36 9e3c3fbaffbce76b3aab70034af0377a7973c2e9b2309d2f5b1664d91c3f80ae/
brw-------  1 root root  8, 1 Mar 15 10:49 backingFsBlockDev
drwx-----x  3 root root  4096 Mar 21 09:36 dc0ddf7063bdf753809037567f91c0b9657fbd40dc6b4573a043ccf81d1226a4/
-rw-------  1 root root 65536 Mar 21 09:36 metadata.db
root@mike-VirtualBox:/mnt/docker/volumes# cd 9e3c3fbaffbce76b3aab70034af0377a7973c2e9b2309d2f5b1664d91c3f80ae/
root@mike-VirtualBox:/mnt/docker/volumes/9e3c3fbaffbce76b3aab70034af0377a7973c2e9b2309d2f5b1664d91c3f80ae# ll
total 12
drwx-----x 3 root    root   4096 Mar 21 09:36 ./
drwx-----x 4 root    root   4096 Mar 21 09:36 ../
drwxr-xr-x 2 vboxadd vboxsf 4096 Mar 19 19:12 _data/
root@mike-VirtualBox:/mnt/docker/volumes/9e3c3fbaffbce76b3aab70034af0377a7973c2e9b2309d2f5b1664d91c3f80ae# cd _data
root@mike-VirtualBox:/mnt/docker/volumes/9e3c3fbaffbce76b3aab70034af0377a7973c2e9b2309d2f5b1664d91c3f80ae/_data# ll
total 8
drwxr-xr-x 2 vboxadd vboxsf 4096 Mar 19 19:12 ./
drwx-----x 3 root    root   4096 Mar 21 09:36 ../
root@mike-VirtualBox:/mnt/docker/volumes/9e3c3fbaffbce76b3aab70034af0377a7973c2e9b2309d2f5b1664d91c3f80ae/_data# cd ..
root@mike-VirtualBox:/mnt/docker/volumes/9e3c3fbaffbce76b3aab70034af0377a7973c2e9b2309d2f5b1664d91c3f80ae# cd ..
root@mike-VirtualBox:/mnt/docker/volumes# cd dc0ddf7063bdf753809037567f91c0b9657fbd40dc6b4573a043ccf81d1226a4/
root@mike-VirtualBox:/mnt/docker/volumes/dc0ddf7063bdf753809037567f91c0b9657fbd40dc6b4573a043ccf81d1226a4# ll
total 12
drwx-----x 3 root    root   4096 Mar 21 09:36 ./
drwx-----x 4 root    root   4096 Mar 21 09:36 ../
drwxr-xr-x 4 vboxadd vboxsf 4096 Mar 21 09:48 _data/
root@mike-VirtualBox:/mnt/docker/volumes/dc0ddf7063bdf753809037567f91c0b9657fbd40dc6b4573a043ccf81d1226a4# cd _data/
root@mike-VirtualBox:/mnt/docker/volumes/dc0ddf7063bdf753809037567f91c0b9657fbd40dc6b4573a043ccf81d1226a4/_data# ll
total 320
drwxr-xr-x 4 vboxadd vboxsf  4096 Mar 21 09:49 ./
drwx-----x 3 root    root    4096 Mar 21 09:36 ../
-rw------- 1 vboxadd vboxsf 20480 Mar 21 09:37 collection-0--7522652413938340838.wt
-rw------- 1 vboxadd vboxsf 20480 Mar 21 09:37 collection-2--7522652413938340838.wt
-rw------- 1 vboxadd vboxsf  4096 Mar 21 09:36 collection-4--7522652413938340838.wt
-rw------- 1 vboxadd vboxsf 20480 Mar 21 09:38 collection-7--7522652413938340838.wt
drwx------ 2 vboxadd vboxsf  4096 Mar 21 09:49 diagnostic.data/
-rw------- 1 vboxadd vboxsf 20480 Mar 21 09:37 index-1--7522652413938340838.wt
-rw------- 1 vboxadd vboxsf 20480 Mar 21 09:37 index-3--7522652413938340838.wt
-rw------- 1 vboxadd vboxsf  4096 Mar 21 09:36 index-5--7522652413938340838.wt
-rw------- 1 vboxadd vboxsf  4096 Mar 21 09:36 index-6--7522652413938340838.wt
-rw------- 1 vboxadd vboxsf 20480 Mar 21 09:38 index-8--7522652413938340838.wt
drwx------ 2 vboxadd vboxsf  4096 Mar 21 09:36 journal/
-rw------- 1 vboxadd vboxsf 36864 Mar 21 09:38 _mdb_catalog.wt
-rw------- 1 vboxadd vboxsf     2 Mar 21 09:36 mongod.lock
-rw------- 1 vboxadd vboxsf 36864 Mar 21 09:39 sizeStorer.wt
-rw------- 1 vboxadd vboxsf   114 Mar 21 09:36 storage.bson
-rw------- 1 vboxadd vboxsf    50 Mar 21 09:36 WiredTiger
-rw------- 1 vboxadd vboxsf  4096 Mar 21 09:36 WiredTigerHS.wt
-rw------- 1 vboxadd vboxsf    21 Mar 21 09:36 WiredTiger.lock
-rw------- 1 vboxadd vboxsf  1471 Mar 21 09:49 WiredTiger.turtle
-rw------- 1 vboxadd vboxsf 77824 Mar 21 09:49 WiredTiger.wt
root@mike-VirtualBox:/mnt/docker/volumes/dc0ddf7063bdf753809037567f91c0b9657fbd40dc6b4573a043ccf81d1226a4/_data# cd ..
root@mike-VirtualBox:/mnt/docker/volumes/dc0ddf7063bdf753809037567f91c0b9657fbd40dc6b4573a043ccf81d1226a4# cd ..
root@mike-VirtualBox:/mnt/docker/volumes# cd ..
root@mike-VirtualBox:/mnt/docker# cd ..
root@mike-VirtualBox:/mnt# ll
total 20
drwxr-xr-x  5 root    root 4096 Mar 21 06:42 ./
drwxr-xr-x 25 root    root 4096 Mar 21 07:30 ../
drwx--x--- 13 root    root 4096 Mar 15 10:49 docker/
drwxr-xr-x  2 root    root 4096 Mar 21 06:42 mongo/
drwxr-xr-x  6 vboxadd root 4096 Mar 16 12:06 mysql/
root@mike-VirtualBox:/mnt# cd mongo/
root@mike-VirtualBox:/mnt/mongo# ll
total 8
drwxr-xr-x 2 root root 4096 Mar 21 06:42 ./
drwxr-xr-x 5 root root 4096 Mar 21 06:42 ../
root@mike-VirtualBox:/mnt/mongo#
------------------------------------------------------------------------- attempt ---------------------------------------------------------
-------------------------------------------------------------------------  whole ----------------------------------------------------------



73.jenkins again! persist your jobs and configurations
-------------------------------------------------------

hello and good morning in this lesson we are going to learn how to persist data using the jenkins container so delete everything from the 
previous lesson and move to what we do in this one 

to remember the massive deletion comes from what is below 


mike@mike-VirtualBox:~$ docker rm -f $(docker ps -a -q)

mike@mike-VirtualBox:~$ docker rmi -f $(docker images -q)

mike@mike-VirtualBox:~$ docker volume rm -f $(docker volume ls -q)


now we want to create a new container with jenkins and we want to persist all of the information in this container 
so remember the first question that you should ask yourself is :
what folder from the container should i use to use it as my warehouse for my data
so as i am bored right now lets listen the guy on the video that says that for the jenkins the warehouse folder is 
the second attempt as its image has no information about the issue so we go to see for 
jenkins docker volume.......
and then lets take a look and see if we can find anything 
so yes we find that the jenkins image has its warehouse at the address below :
its the very well known " /var/jenkins_home/" avenue which is located in Miami <3 (oscar ithopoias) and before that we put our warehouse address
e.g. -v /tour/home: /var/jenkins_home/ in our docker host-our machine
but the folder that you want to save from the container is "/var/jenkins_home/"
so if you wanna test it what you can do you can use the feature to destroy the container go inside it check it and then go outside (i dont understand a thing)
lets try........

mike@mike-VirtualBox:~$ docker run --rm -ti jenkins/jenkins bash.....and through that we achieve to go inside of a temporary container
.....
Status: Downloaded newer.......
jenkins@5f469cdbf363:/$

and from here we can go to the miami avenue that is "/var/jenkins_home/" then perform ls to see what is in there and  and then we are good to go somewhere else

jenkins@5f469cdbf363:/$ cd /var/jenkins_home/
jenkins@5f469cdbf363:/$ ls
copy_reference_file.log tini_pub.gpg
jenkins@5f469cdbf363:/$

so basically this "/var/jenkins_home/" is a directory that we want to save our and this is what we are going to map in the volume 
so lets copy that folder exit from the temporary container and create a new directory

jenkins@5f469cdbf363:/$ exit 
exit
mike@mike-VirtualBox:~$

in this example we are going to create a new directory in mount again but if we have the results of the yesterday we are going to create a bind volume
and send this to miami through swimming......



mike@mike-VirtualBox:~$ ll
total 164
drwxr-xr-x 20 mike mike  4096 Mar 22 03:23 ./
drwxr-xr-x  3 root root  4096 Mar  1 04:14 ../
-rw-------  1 mike mike 22343 Mar 21 11:27 .bash_history
-rw-r--r--  1 mike mike   220 Mar  1 04:14 .bash_logout
-rw-r--r--  1 mike mike  3771 Mar  1 04:14 .bashrc
drwx------ 15 mike mike  4096 Mar 21 10:19 .cache/
drwx------ 16 mike mike  4096 Mar 10 03:38 .config/
drwxr-xr-x  4 mike mike  4096 Mar 14 03:54 Desktop/
drwxr-xr-x  2 mike mike  4096 Mar  1 04:39 Documents/
drwxr-xr-x  2 mike mike  4096 Mar  8 10:10 Downloads/
-rw-r--r--  1 mike mike  8980 Mar  1 04:14 examples.desktop
drwx------  3 mike mike  4096 Mar  1 04:45 .gnupg/
-rw-------  1 mike mike  8496 Mar 22 03:23 .ICEauthority
drwx------  3 mike mike  4096 Mar  1 04:39 .local/
drwx------  4 mike mike  4096 Mar  1 05:40 .mozilla/
drwxr-xr-x  2 mike mike  4096 Mar  1 04:39 Music/
-rw-------  1 mike mike    93 Mar 10 11:35 .mysql_history
drwxr-xr-x  2 mike mike  4096 Mar  3 10:12 Pictures/
drwx------  3 mike mike  4096 Mar  1 06:44 .pki/
-rw-r--r--  1 mike mike   807 Mar  1 04:14 .profile
drwxr-xr-x  2 mike mike  4096 Mar  1 04:39 Public/
drwxr-xr-x  2 root root  4096 Mar 10 07:40 .rpmdb/
drwx------  3 mike mike  4096 Mar  8 04:52 snap/
drwx------  2 mike mike  4096 Mar  1 04:45 .ssh/
-rw-r--r--  1 mike mike     0 Mar  1 04:45 .sudo_as_admin_successful
drwxr-xr-x  2 mike mike  4096 Mar  1 04:39 Templates/
-rw-r-----  1 mike mike     5 Mar 22 03:23 .vboxclient-clipboard.pid
-rw-r-----  1 mike mike     5 Mar 22 03:23 .vboxclient-display-svga-x11.pid
-rw-r-----  1 mike mike     5 Mar 22 03:23 .vboxclient-draganddrop.pid
-rw-r-----  1 mike mike     5 Mar 22 03:23 .vboxclient-seamless.pid
drwxr-xr-x  2 mike mike  4096 Mar  1 04:39 Videos/
drwxrwxr-x  3 mike mike  4096 Mar  1 06:44 .vscode/

now what is happening here is that i cannot find the mnt folder so lets do a grep root : 
mike@mike-VirtualBox:~$ docker info | grep -i root 
by the way with ls in this folder i am able to see it 

mike@mike-VirtualBox:/$ docker info | grep -i root
 Docker Root Dir: /mnt/docker
WARNING: No swap limit support

mike@mike-VirtualBox:/$ ls
bin   cdrom    dev           etc   initrd.img      lib    lost+found  mnt  proc       root  sbin  srv       sys  usr  vmlinuz
boot  Desktop  dockercommit  home  initrd.img.old  lib64  media       opt  realstuff  run   snap  swapfile  tmp  var  vmlinuz.old
mike@mike-VirtualBox:/$

so in  mnt we go and create a new folder with the name "jenkins" through "sudo mkdir jenkins" 

mike@mike-VirtualBox:~$ cd /mnt/
mike@mike-VirtualBox:/mnt$ sudo mkdir jenkins ........and if we take a look at the folder with "ls" or "ll" we can see now that we have our jenkins folder 
                                                      which is accessible from /mnt/jenkins/ for the time we have nothing but the idea is to map this
                                                      folder to the container's folder so that the data can be replicated from the service......
                                                      so lets craete this service 
mike@mike-VirtualBox:/mnt$ ls 
docker jenkins mongo mysql
mike@mike-VirtualBox:/mnt$ docker run -d --name jenkins -p 8080:8080 -v /mnt/jenkins:/var/jenkins_home jenkins/jenkins

now the video has my yesterday's issues e.g. from the time the container is created is exited simultaneously and the same goes for me
what is happening ?



mike@mike-VirtualBox:/mnt$  docker run -d --name jenkins -p 8080:8080 -v /mnt/jenkins:/var/jenkins_home jenkins/jenkins
92ef9fc8eca205b5fdc17218de5c91240b80d4a2414515325239a64d765935ce
mike@mike-VirtualBox:/mnt$ docker ps
CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES
mike@mike-VirtualBox:/mnt$

we need to perform a docker ps -a to find our exited container and through its id to find its error logs 
so the id is :92ef9fc8eca2 so 
mike@mike-VirtualBox:/mnt$ docker logs -f 92ef9fc8eca2

|---------------------------------------------------------------------------------------|
|can not write to /var/jenkins_home/copy_reference_file.log. wrong volume permissions?  |
|touch: cannot touch '/var/jenkins_home/copy_reference_file.log': permission denied     |
|---------------------------------------------------------------------------------------|

so with this message we understand that we have a wrong volume permission....but what is it?
well it turns out that specifically for some docker official images we have some problems like this 
and its because the cmd script is trying to copy some files to the jenkins directory which means that the container is trying to 
copy information to this folder "jenkins" in our docker host
but if we perform an "ll" in mnt directory in our machine we see that the root user is the owner of this folder 


mike@mike-VirtualBox:/mnt$ ll
total 24
drwxr-xr-x  6 root    root 4096 Mar 22 04:29 ./
drwxr-xr-x 27 root    root 4096 Mar 21 10:43 ../
drwx--x--- 13 root    root 4096 Mar 22 03:22 docker/
drwxr-xr-x  2 root    root 4096 Mar 22 04:29 jenkins/
drwxr-xr-x  2 root    root 4096 Mar 21 06:42 mongo/
drwxr-xr-x  6 vboxadd root 4096 Mar 16 12:06 mysql/
mike@mike-VirtualBox:/mnt$

and then if you just try to go inside of a temporary jenkins container to debug it...you see that the user that is trying to do that is the jenkins user 






mike@mike-VirtualBox:~$ docker run --rm -ti jenkins/jenkins bash.
jenkins@5f469cdbf363:/$..................................................jenkins user, and the id of the jenkins user inside of the container is 1000
                                                                         while the id for the root user is normally 0
so this is the problem jenkins container is trying to copy files to mnt/jenkins directory in our docker host but it is trying to do it from its user that hasn't 
permissions to do that because /mnt/jenkins folder is owned by the root user with a different user id 
so how de we solve this error ?
so it is a matter to apply the same id (1000) to the folder in our docker host so as enable jenkins to write information to our machine 
as you can see from the above that jenkins make its tries to copy the files but its had its permission denied......
so what we do ?
we change thw owner and then we can say that the user with id 1000 and group 1000 will now be the owner of the folder -R /mnt/jenkins/ 

-we do it in simple mode
mike@mike-VirtualBox:/mnt$ sudo chown 1000:1000 -R /mnt/jenkins/ 

-we do it recursively 
mike@mike-VirtualBox:/mnt$ sudo chown 1000:1000 -R /mnt/jenkins/ -R
and now yoy will see that the root user in or jenj=kins folder has changed.....and if you give the id command you will see that 
the user that you are usibg right now has the same id with the jenkins container 


mike@mike-VirtualBox:/mnt$ ll
total 24
drwxr-xr-x  6 root    root 4096 Mar 22 04:29 ./
drwxr-xr-x 27 root    root 4096 Mar 21 10:43 ../
drwx--x--- 13 root    root 4096 Mar 22 03:22 docker/
drwxr-xr-x  2 mike    mike 4096 Mar 22 04:29 jenkins/
drwxr-xr-x  2 root    root 4096 Mar 21 06:42 mongo/
drwxr-xr-x  6 vboxadd root 4096 Mar 16 12:06 mysql/
mike@mike-VirtualBox:/mnt$

so now if we try to restart our stopped container through its "docker start 92ef9fc8eca2" the the cmd wii try to reexecute and now yopur folder has the same 
user id as jenkins and thus the files can now be copied
and now if make "docker ps" you see that your container is up and running 
and through an ls to your /mnt/jenkins/ folder you will see that they jenkins container's data are mapped there 
and 
now if you make docker logs -f (to follow the output in jenkins ) jenkins then you will see all of the things that are being done inside of the container 
and basically this is a script that they putted in cmd which does all of the things like 
copying files from one location to the other location and finally starting the jenkins server 

so lets go and hit it 
mike@mike-VirtualBox:/mnt$ docker logs -f jenkins

------------------------------------------------------------------------------------------------------------------------------------------
mike@mike-VirtualBox:/mnt/jenkins$ docker logs -f jenkins
Can not write to /var/jenkins_home/copy_reference_file.log. Wrong volume permissions?
touch: cannot touch '/var/jenkins_home/copy_reference_file.log': Permission denied
Running from: /usr/share/jenkins/jenkins.war
webroot: EnvVars.masterEnvVars.get("JENKINS_HOME")
2022-03-22 09:18:04.922+0000 [id=1] INFO org.eclipse.jetty.util.log.Log#initialized: Logging initialized @721ms to org.eclipse.jetty.util.log.JavaUtilLog
2022-03-22 09:18:05.044+0000 [id=1] INFO winstone.Logger#logInternal: Beginning extraction from war file
2022-03-22 09:18:06.353+0000 [id=1] WARNING o.e.j.s.handler.ContextHandler#setContextPath: Empty contextPath
2022-03-22 09:18:06.455+0000 [id=1] INFO org.eclipse.jetty.server.Server#doStart: jetty-9.4.45.v20220203; built: 2022-02-03T09:14:34.105Z; git: 4a0c91c0be53805e3fcffdcdcc9587d5301863db; jvm 11.0.14.1+1
2022-03-22 09:18:06.845+0000 [id=1] INFO o.e.j.w.StandardDescriptorProcessor#visitServlet: NO JSP Support for /, did not find org.eclipse.jetty.jsp.JettyJspServlet
2022-03-22 09:18:06.896+0000 [id=1] INFO o.e.j.s.s.DefaultSessionIdManager#doStart: DefaultSessionIdManager workerName=node0
2022-03-22 09:18:06.913+0000 [id=1] INFO o.e.j.s.s.DefaultSessionIdManager#doStart: No SessionScavenger set, using defaults
2022-03-22 09:18:06.914+0000 [id=1] INFO o.e.j.server.session.HouseKeeper#startScavenging: node0 Scavenging every 660000ms
2022-03-22 09:18:07.643+0000 [id=1] INFO hudson.WebAppMain#contextInitialized: Jenkins home directory: /var/jenkins_home found at: EnvVars.masterEnvVars.get("JENKINS_HOME")
2022-03-22 09:18:07.978+0000 [id=1] INFO o.e.j.s.handler.ContextHandler#doStart: Started w.@670ce331{Jenkins v2.339,/,file:///var/jenkins_home/war/,AVAILABLE}{/var/jenkins_home/war}
2022-03-22 09:18:08.019+0000 [id=1] INFO o.e.j.server.AbstractConnector#doStart: Started ServerConnector@5f9678e1{HTTP/1.1, (http/1.1)}{0.0.0.0:8080}
2022-03-22 09:18:08.020+0000 [id=1] INFO org.eclipse.jetty.server.Server#doStart: Started @3826ms
2022-03-22 09:18:08.024+0000 [id=23] INFO winstone.Logger#logInternal: Winstone Servlet Engine running: controlPort=disabled
2022-03-22 09:18:08.590+0000 [id=28] INFO jenkins.InitReactorRunner$1#onAttained: Started initialization
2022-03-22 09:18:08.599+0000 [id=28] INFO jenkins.InitReactorRunner$1#onAttained: Listed all plugins
2022-03-22 09:18:09.984+0000 [id=29] INFO jenkins.InitReactorRunner$1#onAttained: Prepared all plugins
2022-03-22 09:18:09.991+0000 [id=28] INFO jenkins.InitReactorRunner$1#onAttained: Started all plugins
2022-03-22 09:18:10.017+0000 [id=29] INFO jenkins.InitReactorRunner$1#onAttained: Augmented all extensions
2022-03-22 09:18:11.020+0000 [id=28] INFO jenkins.InitReactorRunner$1#onAttained: System config loaded
2022-03-22 09:18:11.020+0000 [id=28] INFO jenkins.InitReactorRunner$1#onAttained: System config adapted
2022-03-22 09:18:11.020+0000 [id=28] INFO jenkins.InitReactorRunner$1#onAttained: Loaded all jobs
2022-03-22 09:18:11.021+0000 [id=28] INFO jenkins.InitReactorRunner$1#onAttained: Configuration for all jobs updated
2022-03-22 09:18:11.070+0000 [id=44] INFO hudson.model.AsyncPeriodicWork#lambda$doRun$1: Started Download metadata
2022-03-22 09:18:11.096+0000 [id=44] INFO hudson.util.Retrier#start: Attempt #1 to do the action check updates server
WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by org.codehaus.groovy.vmplugin.v7.Java7$1 (file:/var/jenkins_home/war/WEB-INF/lib/groovy-all-2.4.21.jar) to constructor java.lang.invoke.MethodHandles$Lookup(java.lang.Class,int)
WARNING: Please consider reporting this to the maintainers of org.codehaus.groovy.vmplugin.v7.Java7$1
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
2022-03-22 09:18:12.256+0000 [id=29] INFO jenkins.install.SetupWizard#init:

*************************************************************
*************************************************************
*************************************************************

Jenkins initial setup is required. An admin user has been created and a password generated.
Please use the following password to proceed to installation:

38d84a714b984e0b93126a325a849a58

This may also be found at: /var/jenkins_home/secrets/initialAdminPassword

*************************************************************
*************************************************************
*************************************************************

2022-03-22 09:18:33.036+0000 [id=28] INFO jenkins.InitReactorRunner$1#onAttained: Completed initialization

2022-03-22 09:18:33.177+0000 [id=22] INFO hudson.lifecycle.Lifecycle#onReady: Jenkins is fully up and running

2022-03-22 09:18:33.644+0000 [id=44] INFO h.m.DownloadService$Downloadable#load: Obtained the updated data file for hudson.tasks.Maven.MavenInstaller
2022-03-22 09:18:33.645+0000 [id=44] INFO hudson.util.Retrier#start: Performed the action check updates server successfully at the attempt #1
2022-03-22 09:18:33.647+0000 [id=44] INFO hudson.model.AsyncPeriodicWork#lambda$doRun$1: Finished Download metadata. 22,575 ms
------------------------------------------------------------------------------------------------------------------------------------------


so from the above we can see that jenkins is fully up and running and if yiy see more closely this process is running in foreground mode because if it didn't 
you wouldn't be able to see the output above and more more you couldn't even see this  "Jenkins is fully up and running"

so now lets try to go to our browser and lets go to our ip address or localhost on port 8080 and we see that we redirected to the jenkins container's page
(fresh jenkins installation and its working good)

so we already know ho to use the "/var/jenkins_home/secrets/initialAdminPassword"


-----------------------------------------------------------------------------------------------
mike@mike-VirtualBox:~/Desktop/realstuff/realstuff1/multistage$ docker exec -ti jenkins bash
jenkins@c2eb5b805622:/$  cat /var/jenkins_home/secrets/initialAdminPassword
c0b44ba56c0349199ac6e4c158f70355
jenkins@c2eb5b805622:/$ 
-----------------------------------------------------------------------------------------------

but in here we are going to taught something different without going inside of the container like above 
so you can basically run commands from the outside of the container without going inside 
what do i mean....well you can go inside of this container like this and asking an interactive terminal : docker exec -ti jenkins bash 
and then you can browse the container like a normal machine 
then 
you can just do a "cat" to the file that they provide you which is this one :   /var/jenkins_home/secrets/initialAdminPassword
and then you can see the output and thats cool
but 
you can also do it from the outside.....so this is done without the -ti flag as you don't want to use this flag 
and the you say akay bash please execute this command -c and then you can just predocumented the commant that you want to output awesome
so if you do this you get the output from the container but you didn't enter inside of the container so its a cool trick 


mike@mike-VirtualBox:/mnt$ docker exec  jenkins bash -c "cat /var/jenkins_home/secrets/initialAdminPassword"
38d84a714b984e0b93126a325a849a58
mike@mike-VirtualBox:/mnt$


so yopu can do it for wahtever you want even for "/etc/hosts/" and whoami
and this is actually useful for scripts whenn you are trying to create a script that go inside of a container and try to do some things 
then this is a cool way to do it 
akay so this is the password that we need so copy and paste it to the jenkins textbxox in the browser to login to the jenkins account and do your stuff
we select the "select  plugins to install" and hit the install button below  and the we create our user and then press the save and continue button then
we save and finnish and later hit the start using jenkins 
and later you are going to see that you have a jenkins service running in docker 
and we can go ahead and create a new job....
from new item which redirects us to a page that prompts us to enter an item name in a txtbox : test_job we call it........
then we have a jbo created 
note before you click the ok button you must click the pipelines below the textbox

so now what we want to do is that we want to verify that even if we remove the container all the information that we create here should be safe 
so lets go ahead and test it 

so lets go to our terminal and remove the container and now if we refresh the browser jenkins is no longer there 
so one important thing to recreate your container you need to remember that the folder that you mapped was at /mnt/jenkins  and there it is that you have 
all of your information 
so now you want to create a new container saying like this below :



mike@mike-VirtualBox:/mnt$  docker run -d --name jenkins -p 8080:8080 -v /mnt/jenkins:/var/jenkins_home jenkins/jenkins

so you specify the same folder of your docker host that contains all of the information that the previous container creates so as to be mapped from the
docker host  to the container this time...so yes we get the hash 
we reload the browser (dont panic if it says the container/browsaer is reset just keep waiting )we provide the credentials that we type before when we create the jenkins user abnd we can see that we have our information there....
from the previous container

even if we destroy the container together with its volume we have mapped a local folder of our machine to mirror the data of the container and what we will
created to it so we are safe as we can mirroring from the opposite direction the second time we create the container i.e. from our machine to the container 

well a final questiion is what happens if we try to create a container without provide the volume ?
what happens is that the new container without the volume shouldn't have any information i mean it should start fresh as we are not mapping any information 
while we have a lot of errors possible if we use the same port the same image name 



mike@mike-VirtualBox:/mnt$  docker run -d --name jenkinss -p 9090:8080  jenkins/jenkins
so here what we achieve is a new installation is going to come up as we are not providing any mapping 
so jenkins things that its the first time that its putting up 
and if we go to the port 9090 to our localhost we will have a fresh jenkins installation without any data 

so rememebre you can have as many containers as you want  as your research allows you in this case i have two comntainers 
one that mirrors data from docke host to the container and vice versa and generally contains all of the information that we want 
and 
the other is simply a new jenkins container that has nothing any information any data any volume mapped and which is basically asking you to start from the start 

i hope through this to undersatnd how to use volumes in a jenkins container or in any other container 


74.Developing a website ? share your data with a docker nginx container
------------------------------------------------------------------------
in this lesson we are going to learn how to persist data in our web server container, well this may be preety preety useful for develpment environments 
so say that you are a web developer and then you want to use docker to develop your site 
so what you can do is to install docker on your own machine 
and  create a folder with your html file or with your code and then you can map that file to the container and then you can just start applying changes to your code
and at any time that you save any file which is mapped to the container it will automaticaly refreshed in the container itself 
and you can use any text editor that you want (sublime visual studio code etc.)
and its going to be a cool tip for developers 
now the real deal....i want to create a web application and the folder that has it bears the name web and is inside the mnt folder of course 
on a next episode i am the one that who uses it through the command "sudo chown mike:mike (to the web folder that i have created) web/"



mike@mike-VirtualBox:/mnt$ sudo mkdir web
mike@mike-VirtualBox:/mnt$ ll
total 28
drwxr-xr-x  7 root    root 4096 Mar 22 07:25 ./
drwxr-xr-x 27 root    root 4096 Mar 21 10:43 ../
drwx--x--- 13 root    root 4096 Mar 22 03:22 docker/
drwxr-xr-x 15 mike    mike 4096 Mar 22 06:41 jenkins/
drwxr-xr-x  2 root    root 4096 Mar 21 06:42 mongo/
drwxr-xr-x  6 vboxadd root 4096 Mar 16 12:06 mysql/

drwxr-xr-x  2 root    root 4096 Mar 22 07:25 web/

mike@mike-VirtualBox:/mnt$  sudo chown mike:mike web/
mike@mike-VirtualBox:/mnt$ ll
total 28
drwxr-xr-x  7 root    root 4096 Mar 22 07:25 ./
drwxr-xr-x 27 root    root 4096 Mar 21 10:43 ../
drwx--x--- 13 root    root 4096 Mar 22 03:22 docker/
drwxr-xr-x 15 mike    mike 4096 Mar 22 06:41 jenkins/
drwxr-xr-x  2 root    root 4096 Mar 21 06:42 mongo/
drwxr-xr-x  6 vboxadd root 4096 Mar 16 12:06 mysql/

drwxr-xr-x  2 mike    mike 4096 Mar 22 07:25 web/

mike@mike-VirtualBox:/mnt$

and now i am able to create files in that folder, so now lets say that i want to create an index.html file inside web folder 

mike@mike-VirtualBox:/mnt/web$ vi index.html

so now what i want to do is to run it in docker container so i will create a new container and this time i am using nginx..
                                                                 location that nginx serves all of its files 
mike@mike-VirtualBox:/mnt/web$  docker run -d --name nginx  -v /mnt/web:/usr/share/nginx/html  nginx:alpine

with a docker ps i can reassure that my container is up and running 
and now i am free to go but we didnt expose any port and probably we will have problems nginx runs on port 80

so lets create another container after we delete this one  first

mike@mike-VirtualBox:/mnt/web$  docker run -d --name nginx  -p 8080:80 -v /mnt/web:/usr/share/nginx/html  nginx:alpine
now if you hit enter and if you see the container from the docker ps you sse your container up and running and your ports 
open and now its time to go the browser so you know 
localhost:8080/index.html 


you will be able to see what you have written in it
you are able to see it without add the /index.html

so now you want to modify the index.html to add extra features and the -v flag whic mirrors the chnages from the docker host to container will 
reflect this change immediatelly

so say now that we want to create another html file


mike@mike-VirtualBox:/mnt/web$ echo "page number 2" > page2.html....and now if you tak a look at your file which is on your own machine you will
see the code and also the page2.html should be created to our container's path also through the mapping below which works vice versa : 
-v /mnt/web:/usr/share/nginx/html

so if we go to our browser and type localhost:8080/page2.html you will see your writtings 

and page2.html is a file that is created by us in the directory of our docker host which is being mapped as a volume to the container 
okay 
by now you already have jnown how to use volumes in a web server and how to use your own stuff how to modify your own code so it gets modified inside of the container 

75.Go deeper share volumes between containers 
----------------------------------------------


------------------------special note----------------------------------------------
how to open vs code from terminal ubuntu Code Answer
Launch VS Code.
Open the Command Palette (Cmd+Shift+P) and type 'shell command' to find the Shell Command: Install 'code' command in PATH command.
Restart the terminal
Navigate to project folder in terminal, 
Type code . press enter
------------------------special note----------------------------------------------

hello in this lesson we are going to learn how to share a directory between two containers, 
so what if you have one container which is using the volume in one folder but then you want to share that folder to another container ?
so say that you have one container which is generating things like grnerating html files and then you have another container which is a web container 
nginx or apache and that container is serving the files that the other container is creating.....
so we can do that by using volumes 
so lets try to do that 
so basically we are going to share the same volume between two containers......so lets go to the /mnt directory and lets create another directory there 
lets say it common as it is used by two containers and 
of course we are going to change the permissions of the owner to be us 


mike@mike-VirtualBox:/mnt$ sudo mkdir common 
mike@mike-VirtualBox:/mnt$ sudo chown 1000:1000 common/


okay so now lets go to this directory and see that it is empty as nothing is added to it or nothing it is mounted to it 
now we want to create a dockerfile here as i want to build my generator 

mike@mike-VirtualBox:/mnt/common$ code Dockerfile .

|---------------------------------------------------------------------------|
| so to start                                 :   from centos:7             |
| --------------------------------------------------------------------------|
| and then i want to create a                                               |
| script that is going to be                                                |
| the cmd but we haven't created             :   copy start.sh /start.sh    |
| it we want to copy start.sh to                                            |
| the container /start.sh                                                   |
| ------------------------------------------------------------------------- |
| then we want to give it executable                                        |
| permissions through the                                                   |
| chmod + x to this file /start.sh          :   run chmod +x /start.sh      |
| which is already in the image                                             |
| ------------------------------------------------------------------------- |
| and then we want this file which is                                       |
| copied and has executable permissions                                     |
| to be the cmd for this file.....         :   cmd /start.sh                |
| so remember that here we must put                                         |
| something that keeps the container                                        |
| alive                                                                     |
|---------------------------------------------------------------------------|


so lets save the dockerfile above and lets go and create the file "start.sh"


mike@mike-VirtualBox:/mnt/common$ code start.sh .

okay we start 

#ok we start with #!/bin/bash as it is a bash file        :  #!/bin/bash
---------------------------------------------------------------------------------------
#then we will use a while that say while true             : while true; do
which means forever and ever
---------------------------------------------------------------------------------------
#then we do the things here, so what we want 
#to do here is to generate some html files
#and remember that in linux we can use the 
#echo command and we put something here then we          : echo "">> /opt/indx.html
#redirect that to some file 
#if the file doesn't exist then the file is going 
#to be created
#so we say echo something like echo "" and we can 
#redirect (>) the output to /opt/index.html
# if we put >> instead of > we tell that we want to 
#append which means that the file will not be overriden
------------------------------------------------------------------------------------
#and the closing it using done                          :     done



okay let me show you if i go to my terminal 
and type echo hello >> ( to ) hello.txt......then it will create a file there in my current directory 
mike@mike-VirtualBox:/mnt/common$ echo hello >> hello.txt that when we call it, it says hello
and if run it again then it will append a line with the text that i put to the original txt file
 mike@mike-VirtualBox:/mnt/common$ echo hello >> hello.txt
 mike@mike-VirtualBox:/mnt/common$ cat hello.txt
 hello
 hello

 now lets keep modify our script (start.sh) ad lets say that we want to add a paragraph so in html it would be "<p>banana</p>"
 or we can make it dynamic like a date command, in linux we have the date command and it prints the current date  

mike@mike-VirtualBox:/mnt/common$ date...shows me the current date 
so if i do echo and execute this command $(date) i am basically printing to the output 
but if i redirected  (echo $(date) > date.txt) to date.txt i will have the date output to  file date.txt
and if i do the same thing but with two >> e.g. i append to the file then you will see that in the file i have another date with different seconds 
so this is what we do we will copy this : echo $(date) >> date.txt 
and we go to our script and we will say ok we want to add an html paragraph 
and we wanto to include in it the output of the date command 

echo "<p> $(date) </p>" 

and this will return the value of the current date and we want redirect and append at the same time to the index.html


echo "<p> $(date) </p>" >> /opt/index.html 
which is inside of this image....so great all of the information will be inside the opt an the index.html file,
now what we can use is a sleep command that allows us to execute this every 3 seconds...i.e. we wait three seconds 
sleep 3
and this goes forever as we set "while true;"

now lets save this file and lets build the image which is based on this dockerfile which we review it below

i.we have the start.sh file 
ii.we copy this file to the /start.sh 
iii.then we give executable permissions 
iv.and from the time that start.sh is always running we can give it aas a cmd command that prevents it from stop 

from centos:7 
copy start.sh /start.sh
run chmod+x /start.sh 
cmd /start.sh 


from centos:7 
copy start.sh /start.sh
run chmod +x /start.sh 
cmd /start.sh 


find the mistake above

lets build the image

mike@mike-VirtualBox:/mnt/common$ docker build -t generator .
once the image is succesfuly builded we can create a new directory here which is going to be the "htmlfiles" and say that we want to map this
directory to the container "to /opt in the container"
so remember that in the script we are writing data to opt......so we want to map the local folder "htmlfiles" to /opt inside of the container 
so i can see this index file inside my localhost so lets do it 
but wait a second you are here 
mike@mike-VirtualBox:/mnt/common$......if you make echo $PWD you print the current directory-path
/mnt/common
mike@mike-VirtualBox:/mnt/common$

so if you type echo $PWD/htmlfiles...you will have your ful path for your folder and when you are mapping a volume you need a full path
mike@mike-VirtualBox:/mnt/common$ echo $PWD/htmlfiles
/mnt/common/htmlfiles

so okau with these lets say 
mike@mike-VirtualBox:/mnt/common$ docker run -d --name gen -v $PWD/htmlfiles:/opt generator 

so basically everything that gets created in opt will be available in htmlfiles that is currently 
empty its ok it will be pull its data later from  /opt
so we get our hash and i think that now htmlfile directory will contain the index.html file that is mapped from the container's opt Directory\

mike@mike-VirtualBox:/mnt/common$  cd htmlfiles/
mike@mike-VirtualBox:/mnt/common/htmlfiles$
.......
......
-rw-r--r......index.html

docker ps show that your container is up and running, so now if you take a look at the htmlfiles folder you see that the index.html file which is replicated 
from /opt to htmlfiles through this......-v $PWD/htmlfiles:/opt
so if you type 
mike@mike-VirtualBox:/mnt/common/htmlfiles$ cat index.html you will see that every three seconds you have the date and the time because as you remember in the start.sh 
we are sleeping 3 seconds and the we are executing the echo 

so basically this container is just appending the date every three seconds to this file "htmlfiles"


the other thing that we need to do now is now that we have this file "htmlfiles/index.html" which is growing every single second 
so now we  want to serve this in our web server, so letrs create a docker container with nginx 


 mike@mike-VirtualBox:/mnt/common$ docker run -d --name nginx -v $PWD/htmlfiles:/usr/share/nginx/html -p 9091:80 nginx:alpine 

 -v $PWD/htmlfiles:/usr/share/nginx/html

 so here we are just mapping this folder htmlfiles to nginx container and remember that in htmlfiles directory 
 we are generating files from another container 


 so here we are  two containers which are sharing the same folder and the "generator" container is constantly updating htmlfiles folder that contains the index.html
 file and the nginx:alpine web server is serving that data right at the same point (ufo point) i.e. htmlfiles folder
 so lets take a look at the index.html file 
  mike@mike-VirtualBox:/mnt/common/htmlfiles$ cat index.html
  and it is huge  so now i amgoing to remove the index.html file 
  mike@mike-VirtualBox:/mnt/common/htmlfiles$ sudo rm -rf index.html 

  and when i make cat agai on that it will start from 0
  mike@mike-VirtualBox:/mnt/common/htmlfiles$ cat index.html.....so yes much smaller 


  special note if youa are already in htmlfiles and make -v $PWD/htmlfiles:/usr/share/nginx/html
  e.g. 
  mike@mike-VirtualBox:/mnt/common/htmlfiles$ docker run -d --name nginx -v $PWD/htmlfiles:/usr/share/nginx/html -p 9091:80 nginx:alpine......wrong
 mike@mike-VirtualBox:/mnt/common$ docker run -d --name nginx -v $PWD/htmlfiles:/usr/share/nginx/html -p 9091:80 nginx:alpine......wrong

  then the localhost:8080 will throw you a 403 forbidden

  so in the browse rif we hit refersh the generator will updationg the file 
  and basically what happened was that you created one folder and you are sharing that folder between two containers 

the first one is creating this file index.html and the second one is just serving this file in a web browser 



so thats how you share volumes between contaiuners 
and you should make sure that only one container should be writting to the file because if more than one containers are writting to the same file 
then imagine what happens the file will become corrupted..
---------------------------------8.Docker Volumes - persist data in containers-------------end

start----------------------------9.Docker networks -learn how to get containers communicated----

76.intoduction networking in  docker
------------------------------------
hello and welcome back in this section 
we are going to learn about docker network 
we are going to learn what is network in docker 
we are also going to learn how to use networks 
we are going to learn how to create remove manage and deeploy networks 
we are also going to learn what is a bridge network 
where is the host network 
what is a none network........hiw to use them 

the concept of network in docker is superimportant since you use networks to communicate containers 
say that you want to connect a super small application that uses a database in a web server
then  you use networks to connect to other container 
and we are going to learn how to use the default network 
how to create your own network 
and do a lot of things with the docker network 


77.Whats the default network in docker ?
----------------------------------------
hello and welcome back in this lesson we are going to learn about the default network in docker 
if you hit : " ip a " and you type enter then you are going to see all of the interfaces that your machine has available 




-------------------------------------------------------
mike@mike-VirtualBox:~$ ip a
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host
       valid_lft forever preferred_lft forever
2: enp0s3: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000
    link/ether 08:00:27:46:a9:82 brd ff:ff:ff:ff:ff:ff
    inet 10.0.2.15/24 brd 10.0.2.255 scope global dynamic noprefixroute enp0s3
       valid_lft 76753sec preferred_lft 76753sec
    inet6 fe80::a659:354c:8d3f:ab26/64 scope link noprefixroute
       valid_lft forever preferred_lft forever
3: docker0: <NO-CARRIER,BROADCAST,MULTICAST,UP> mtu 1500 qdisc noqueue state DOWN group default
    link/ether 02:42:b7:90:ac:44 brd ff:ff:ff:ff:ff:ff
    inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0
       valid_lft forever preferred_lft forever
mike@mike-VirtualBox:~$
-------------------------------------------------------



we are doing this outside of the containers inside your docker host machine,
so you will see a docker0 interface (in number 3) 

so if we just do the same command and grep for docker then you will see the docker0 interface that is created and this interface is actually the one 
that handles all of the requests between the containers when they are using networks so that cool

mike@mike-VirtualBox:~$ ip a | grep docker
3: docker0: <NO-CARRIER,BROADCAST,MULTICAST,UP> mtu 1500 qdisc noqueue state DOWN group default
    inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0
mike@mike-VirtualBox:~$

now what does it mean ?
well it turns out there is a network in docker that is called the bridge network...and the bridge network is a default network that comes 
with docker and whenever you create a container it will automatically get assigned to the default network which is the bridge network.

now...how do you know the networks that you have in docker ?
well you can type 
docker network ls.......mike@mike-VirtualBox:~$ docker network ls

and you are going to see a lot of networks here but if you grep for bridge you will see only the bridge network

docker network ls.......mike@mike-VirtualBox:~$ docker network ls | grep bridge

mike@mike-VirtualBox:~$ docker network ls
NETWORK ID     NAME      DRIVER    SCOPE
4fc87dabc1ba   bridge    bridge    local
5672c1a44e74   host      host      local
b8ccd8950c5c   none      null      local

mike@mike-VirtualBox:~$ docker network ls | grep bridge
4fc87dabc1ba   bridge    bridge    local
mike@mike-VirtualBox:~$


and this bridge network is actually the default network and all of the containers will be attached to this network by default
so lets take a look at the output  commands that came up when we gave the command ip a | grep docker 

| -------------------------------------------------------------------------------------------------|
| 3: docker0: <NO-CARRIER,BROADCAST,MULTICAST,UP> mtu 1500 qdisc noqueue state DOWN group default  |
| inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0                                       |
|--------------------------------------------------------------------------------------------------|

here we can see that we have an ip address (172.17.0.1) that is the gateway address please remember 
this ip and see that it ends with one.
so now you can take a look at your bridge network and you can also inspect this network by typing 
docker network inspect and you provide the name of the network that you want to inspect lets say bridge 

mike@mike-VirtualBox:~$ docker network inspect bridge......you are going to find a lot of useful data 
one of these useful data are :

subnet  : 172.17.0.0/16
gateway : 172.17.0.1

so this means that the subnet above contains this id block and the containers that are attached to this network will inherit an ip 
inside of this range (172.17.0.0/16)
what is else is that the gateway address is exactly the same with the one with the docker0 interace which is quite good 


now if you create a container let me just go ahead and create anormal container 
lets say 

mike@mike-VirtualBox:~$ docker  run -dti centos:7
and hit enter then the well know stuff 
the container is up and running if you do docker ps
but now if you inspect your container like this.....docker inspect c8dfd92c844c
you will see that at the end we have the "network" section and under this section 
we have the bridge network which means that this container was linked to this network by default
so you see that it is inheriting the same gateway and its actually take an ip inside the range of 1-16

  "NetworkSettings": {
            "Bridge": "",
            "SandboxID": "23c948b17c80e757734574adb347c5402414f610334ff922406d862e63b2fc98",
            "HairpinMode": false,
            "LinkLocalIPv6Address": "",
            "LinkLocalIPv6PrefixLen": 0,
            "Ports": {},
            "SandboxKey": "/var/run/docker/netns/23c948b17c80",
            "SecondaryIPAddresses": null,
            "SecondaryIPv6Addresses": null,
            "EndpointID": "9bbc231a7d18b72095e244597cb48493021979fd3d7fc1e6f91dc492a1fb5b7c",
            "Gateway": "172.17.0.1",
            "GlobalIPv6Address": "",
            "GlobalIPv6PrefixLen": 0,
            "IPAddress": "172.17.0.2",
            "IPPrefixLen": 16,
            "IPv6Gateway": "",
            "MacAddress": "02:42:ac:11:00:02",
            "Networks": {
                "bridge": {
                    "IPAMConfig": null,
                    "Links": null,
                    "Aliases": null,
                    "NetworkID": "4fc87dabc1ba0a739d5db02fddadd83902522a4bcaa37d9d8c690a49b8ffc637",
                    "EndpointID": "9bbc231a7d18b72095e244597cb48493021979fd3d7fc1e6f91dc492a1fb5b7c",
                    "Gateway": "172.17.0.1",
                    "IPAddress": "172.17.0.2",
                    "IPPrefixLen": 16,
                    "IPv6Gateway": "",
                    "GlobalIPv6Address": "",
                    "GlobalIPv6PrefixLen": 0,
                    "MacAddress": "02:42:ac:11:00:02",
                    "DriverOpts": null
                }



so remember that if you do a docker inspect to the network which is called the bridge network you are going to see that 
the gateway   "Gateway": "172.17.0.1" is the same gateway that you have in your default container 
and the subnet "subnet  : 172.17.0.0/16" is the one that is used to assign an ip  address  "IPAddress": "172.17.0.2" to this container 

the thing here is that you must remember some important things 
i.you must always have a docker0 interface which handles all the traffic between your normall containers 
  this interface is created when you install docker and there you have your ip address which is the gateway for the bridge network 
remember that this docker0 interface is created once you install docker for the first time and at the same time some default networks are also 
created as you see here --> "docker network ls"
and also remember that if you create a container without specifying anything just like you do normally it will be created inside 
of the bridge network 
so if you type docker network inspect and you inspect the network bridge "docker network inspect bridge" you are going to see here 
that we have some containers in this network....(but first we must create a container):

      "Containers": {
            "c8dfd92c844c84d0e5dc4be2af78999af8d7074363cac800c56fd2db77373365": {
                "Name": "trusting_sammet",
                "EndpointID": "9bbc231a7d18b72095e244597cb48493021979fd3d7fc1e6f91dc492a1fb5b7c",
                "MacAddress": "02:42:ac:11:00:02",
                "IPv4Address": "172.17.0.2/16",
                "IPv6Address": ""
            }
        },

here the name of the container is "trusting_sammet" and this container is created by us and we didn't specify any parameter or any special parameter 
in the creation of the creation of this container and as you see it was linked automatically to the bridge network 
and it also inherited an ip address from this network   "IPv4Address": "172.17.0.2/16"
you see the subnet above : 172.17.0.0/16 and from this subnet the container inherited its random ip address 



78.ping containers in the default network
-----------------------------------------
hello and welcome vack in this lesson we are going to talk about the default network which is a bridge network 
so if you type 
docker ps....we will see a container that was created previously, so lets go and remove it 
so now you know that if you create any container at any time without passing any special parameters for network it will automatically 
attached to the bridge network so now whant tell my something else and it is if you type "docker network ls "
you are going to see that you ahve the name of the network "bridge " and the driver also 
the most common driver in docker is driver bridge but atr the same time the defualt network in docker is called bridge 
so it may sound confusing but the thing is that the name doesn't really matter 
what does matter is the driver...so the default network could be called "default" or whatever but the just gave it the name of  bridge 
but the driver that this networ is using is also called bridge 
so as you see below we have anothe networ under the bridge one which has a different name and it also has a driver called bridge 
so it super important for yopu to understand that the default network is created and the name is bridge 
but the important thing is that the driver is  bridge you should always care about the driver 
the name is just a representation to easily find what you are looking for 


something else that i wanted to tell you is that you cannot delete the default networks like the bridge network or the host network or the none network 
you cannot delete them because they are part of the dockjer installation and the come by default
now we want to learn abouyt networking in docker right 
so we want to know how to communicate to containers say that i have a container a and a contaner b 
and i want them to get communicated.......then how do i do it ?
well as i told you once in the past once the container are created they are attached to the default networks and the inherit an ip address and you can use that ip address
to other containers 

so let me create two containers 

i.  docker run -dti --name aa centos:7
ii. docker run -dti --name bb centos:7


now if you type docker ps you will see two container up and running and you will know that you will not have specify any special flag in the creation 
of the containers 
so they are attached by default to the bridge network 

so if you type docker network inspect bridge (=default network )
then you will see that you have a section which has the name of containers and there you have the definition for the containers 
that are inside of your network with name,ip


iii.docker network inspect bridge

   "Containers": {
            "005b9a87cecdc317819d901d2c7433ce444130f0ffad75e474a415a4445d29cd": {
                "Name": "aa",
                "EndpointID": "018c0d753c9b76baa8f3c1e74b8b86b16ceeda2f544f52a68290601a9fec9132",
                "MacAddress": "02:42:ac:11:00:03",
                "IPv4Address": "172.17.0.3/16",
                "IPv6Address": ""
            },
            "6877e13913d49edf827ee58fc244fe862245a9f9b9a44cfcfd1e042df1904c85": {
                "Name": "dreamy_benz",
                "EndpointID": "31d475326c03cd2becc4a895abff3c9d514e4940b5863a831036cb72a7c28e04",
                "MacAddress": "02:42:ac:11:00:02",
                "IPv4Address": "172.17.0.2/16",
                "IPv6Address": ""
            },
            "b1e7eb9b50e9ba2defee72616956f64f5ee91ec6b82652b105b4e71ac0324098": {
                "Name": "bb",
                "EndpointID": "3118ca6357315ce54d5b57eb0688088933c86ecff4f8d893a5ab82172168c565",
                "MacAddress": "02:42:ac:11:00:04",
                "IPv4Address": "172.17.0.4/16",
                "IPv6Address": ""
            }
        },



you can also individually inspect each corresponding container through its id/name instead of the entire network 
iv.docker inspect aa
and at the end you see the section networks where there you can see that container aa is linked to the default network 
or in other words the bridge network and of course you can see all of the configurations that are inherited by default 
i.e. we have the same ip address that you saw before and all of the configuration right here below 

      "Networks": {
                "bridge": {
                    "IPAMConfig": null,
                    "Links": null,
                    "Aliases": null,
                    "NetworkID": "4fc87dabc1ba0a739d5db02fddadd83902522a4bcaa37d9d8c690a49b8ffc637",
                    "EndpointID": "018c0d753c9b76baa8f3c1e74b8b86b16ceeda2f544f52a68290601a9fec9132",
                    "Gateway": "172.17.0.1",
                    "IPAddress": "172.17.0.3",
                    "IPPrefixLen": 16,
                    "IPv6Gateway": "",
                    "GlobalIPv6Address": "",
                    "GlobalIPv6PrefixLen": 0,
                    "MacAddress": "02:42:ac:11:00:03",
                    "DriverOpts": null
                }

now that you understand a liitle bit more about how this thing works, we want to take a look at the ip addresses 
remember
  for the container "aa" we have th ip address  "IPv4Address": "172.17.0.3/16",
  for the container "bb" we have th ip address  "IPv4Address": "172.17.0.4/16",


so we can use these ip addresses  to try to ping one container from an other
e.g. lets try to ping the container bb from container aa 
so lets say 
docker exec aa bash....and we can execute a command through -c (means execute) flag without going in the container.... -c "ping 172.17.0.4 "
if you hit enter you see that the conyainer is answering for the infinite and you must type ctrl+C to stop it 

mike@mike-VirtualBox:~$ docker exec aa bash -c "ping 172.17.0.4"
PING 172.17.0.4 (172.17.0.4) 56(84) bytes of data.
64 bytes from 172.17.0.4: icmp_seq=1 ttl=64 time=0.246 ms

now lets try to ping the same container 


mike@mike-VirtualBox:~$ docker exec aa bash -c "ping 172.17.0.3"

you will see that of course and it  answers because this ip corresponds to the container aa 

now lets do the same thing but on the opposite direction i.e. 
ping from container bb to container aa
if you hit enter you see that it works and from bb to bb's ip address 
so super nice 

now you see that in the default network the containers have internal communication 
they can see each other by using the ip address that is assigned to each container 

now here is something important and that is that if you try to ping the container aa from conatiner bb through the use of its name 
i.e. 
docker exec bb bas -c "ping aa" you will see that it isn't going to work 
in the default network the only way for the containers to communicate is through the ip address 
we can use the flag whic is --link in docker but its super deprecated and thus it is not recommended so we want going to be talk about this 
just keep in mind that in the default network you can only see containers by using the ip address 
in future lessons we will learn how to create a different network and how to create a dynamic dns 
which will allow you to ping containers by using the name of the container  


79.create your own network
--------------------------
hello and welcome back in this lesson we are going to learn how to create our own networks because 
if you think about it 
you see that you are a little bit restricted in the default network because 
you first cont ping containers by using the name 
and 
second you cannot control the ranges...the subnets...the numbers the iop addresses you cannot control anything 
you can just add  containers to the existing network 

so now what happens if you want to create your own network ?
well thats what we are going to learn here......
and the first thing that you need to have in mind is that we need to provide a driver to create the network 
and as i told you the bridge driver is the most common driver which is used when we creating docker networks 
so we will be using the driver bridge which is the driver that the default network also uses 
so how do we create a docker network ?
well thers is a command in docker : docker network create, and if you hit enter you create the netwprk 

mike@mike-VirtualBox:~$ docker network create
"docker network create" requires exactly 1 argument.
See 'docker network create --help'.

it actually gives you some help as you are in the clouds above and wants to 
give you instructions to come dowm 

Usage:  docker network create [OPTIONS] NETWORK
Create a network
mike@mike-VirtualBox:~$ docker network create -help
unknown shorthand flag: 'e' in -elp
See 'docker network create --help'.

basically you are above the clouds 



mike@mike-VirtualBox:~$ docker network create --help

Usage:  docker network create [OPTIONS] NETWORK

Create a network

Options:
      --attachable           Enable manual container attachment
      --aux-address map      Auxiliary IPv4 or IPv6 addresses used by Network driver (default map[])
      --config-from string   The network from which to copy the configuration
      --config-only          Create a configuration only network
  -d, --driver string        Driver to manage the Network (default "bridge")
      --gateway strings      IPv4 or IPv6 Gateway for the master subnet
      --ingress              Create swarm routing-mesh network
      --internal             Restrict external access to the network
      --ip-range strings     Allocate container ip from a sub-range
      --ipam-driver string   IP Address Management Driver (default "default")
      --ipam-opt map         Set IPAM driver specific options (default map[])
      --ipv6                 Enable IPv6 networking
      --label list           Set metadata on a network
  -o, --opt map              Set driver specific options (default map[])
      --scope string         Control the network's scope
      --subnet strings       Subnet in CIDR format that represents a network segment
mike@mike-VirtualBox:~$


so the guidance tells us what we can do, so the first thing that we need to provide 
  is the driver                    :  -d, --driver string        Driver to manage the Network (default "bridge")
  and you can provid it or not because the defualt option if you dont provide it is to be bridge 
  then you can specify the gateway :    --gateway strings      IPv4 or IPv6 Gateway for the master subnet
  you can specify the subnet       :    --subnet strings       Subnet in CIDR format that represents a network segment
  and a lot of more things, 
  so lets go ahead and create our own network 
  the first thing that we need to do is to take a look at the subnet of the defauklt network as we dont want to overlap i mean 
  we dont want to use the same subnet 

  mike@mike-VirtualBox:~$  docker network inspect bridge.....and we are going to take a look at the subnet value of this network 
                                                             and below we see the two values of subnet and gateway   
                                                             notworthy is the thing that the subnet is a range at heart of 16 
                                                             networks so we can create as many subnets as possible using different ranges 
 subnet  : 172.17.0.0/16
 gateway : 172.17.0.1


 so lets just copy these two values and try to create a new network using the instruction --help 
 to create the network except that we must say "docker network create " 
 we must also specify the options that we want to provide, the driver of the network is one of them 
 so "-d bridge"...but if we dont provide this...then by default it will be bridge 
 "docker network create  -d bridge" 
 then we can specify the subnet by using flag "--subnet" and as its parameter we provide the subnet that you want 
 to create  
 "docker network create  -d bridge --subnet 172.18.0.0/16" 
 then we are alos going to create the gateway using the glag --gateway and of course the gateway must be inside of our subnet  172.18.0.1
 "docker network create  -d bridge --subnet 172.18.0.0/16 --gateway 172.18.0.1"
 so typically the gateway runs on the ip number one      and finally we provide the name of the new network "newnetwork"

 mike@mike-VirtualBox:~$ docker network create -d bridge --subnet 172.18.0.0/16 --gateway 172.18.0.1 newnetwork
592a337f2c2045d4c1bf50937dcb9ddbcb95912a95496b5c984588b5b48c4192




 so if we hit enter on that we see that we just create a new network and we can list our new networks ny typing 
 docker network ls and of course we are going to see our network that we create above.



mike@mike-VirtualBox:~$ docker network ls
NETWORK ID     NAME         DRIVER    SCOPE
4fc87dabc1ba   bridge       bridge    local
5672c1a44e74   host         host      local
592a337f2c20   newnetwork   bridge    local
b8ccd8950c5c   none         null      local
mike@mike-VirtualBox:~$

and now of course we go and make an inspect this network

mike@mike-VirtualBox:~$ docker network inspect newnetwork then you are going to see all of the configuration right below 

mike@mike-VirtualBox:~$ docker network inspect newnetwork
[
    {
        "Name": "newnetwork",
        "Id": "592a337f2c2045d4c1bf50937dcb9ddbcb95912a95496b5c984588b5b48c4192",
        "Created": "2022-03-23T11:03:51.676559443-04:00",
        "Scope": "local",
        "Driver": "bridge",
        "EnableIPv6": false,
        "IPAM": {
            "Driver": "default",
            "Options": {},
            "Config": [
                {
                    "Subnet": "172.18.0.0/16",
                    "Gateway": "172.18.0.1"
                }
            ]
        },
        "Internal": false,
        "Attachable": false,
        "Ingress": false,
        "ConfigFrom": {
            "Network": ""
        },
        "ConfigOnly": false,
        "Containers": {},
        "Options": {},
        "Labels": {}
    }
]
mike@mike-VirtualBox:~$

]


you are already know how to createyour own network and in the future how to bind containers to this specific network 
so for now we are going to see how to remove this network, so if you want to remove a network you can just go ahead and do it 
but remember that yoiu cannot remove the default networks only the ones that you create 
so to remove it is super easy....you jist keep in mind the name of the network (newnetwork)
and then 
docker network rm newnetwork




80.Embedded dns ping containers by name in the same network 
-----------------------------------------------------------
hello and welcome back in this video we are going to learn how to attach new containers through the network that is just created 
i mean lets say that you dont want to attach your containers to the default network but instead you want to attach those containers to your own network 
so the first thing that we need to do is, is that you need to of course create a network 

so we are going to recreate the network above 


 mike@mike-VirtualBox:~$ docker network create -d bridge --subnet 172.18.0.0/16 --gateway 172.18.0.1 newnetwork

 i never delete it i can use it, now i can attach a new container to this network 
 so how do we do this ?
 remember that if you dont provide any option it will be attached to the bridge network 
 so to create a container in our new network we can do 

                                 --network option that allows us to bind the network above then we continue to build our container as we usually do 
 mike@mike-VirtualBox:~$ docker run -dti --network newnetwork --name cc centos:7 
after the enter of that i go to 
 mike@mike-VirtualBox:~$ docker inspect cc....and we are going to see that this container is not included in the bridge network 
 but in the newnetwork that inherits the new configuration that you provide with your own gateway and you own ip address that is of course inside the 
 allow subnet's addresses 

mike@mike-VirtualBox:~$ docker inspect cc
             "Networks": {
                "newnetwork": {
                    "IPAMConfig": null,
                    "Links": null,
                    "Aliases": [
                        "afdc3ae24db2"
                    ],
                    "NetworkID": "592a337f2c2045d4c1bf50937dcb9ddbcb95912a95496b5c984588b5b48c4192",
                    "EndpointID": "b88f811fdf0161508508952a49325cecccebb135dfa95988368d5c0e96283bef",
                    "Gateway": "172.18.0.1",
                    "IPAddress": "172.18.0.2",
                    "IPPrefixLen": 16,
                    "IPv6Gateway": "",
                    "GlobalIPv6Address": "",
                    "GlobalIPv6PrefixLen": 0,
                    "MacAddress": "02:42:ac:12:00:02",
                    "DriverOpts": null
                }




mike@mike-VirtualBox:~$ docker inspect aa
            "Networks": {
                "bridge": {
                    "IPAMConfig": null,
                    "Links": null,
                    "Aliases": null,
                    "NetworkID": "4fc87dabc1ba0a739d5db02fddadd83902522a4bcaa37d9d8c690a49b8ffc637",
                    "EndpointID": "018c0d753c9b76baa8f3c1e74b8b86b16ceeda2f544f52a68290601a9fec9132",
                    "Gateway": "172.17.0.1",
                    "IPAddress": "172.17.0.3",
                    "IPPrefixLen": 16,
                    "IPv6Gateway": "",
                    "GlobalIPv6Address": "",
                    "GlobalIPv6PrefixLen": 0,
                    "MacAddress": "02:42:ac:11:00:03",
                    "DriverOpts": null
                }

 

so now let me remove all of the containers and all of their volumes that i have here in one line.......docker rm -fv $(docker ps -a -q)
one cool thing about the networks that you create compared to the default networks is that in the default network you can't ping the containers 
by using their name, 
but in the networks that you can create you can ping the containers using the ip address and even the name which is quite cool 
so lets try that.....

lets again create two containers in the network that we just created in the new network 


mike@mike-VirtualBox:~$ docker run -dti --network newnetwork --name aa centos:7 
mike@mike-VirtualBox:~$ docker run -dti --network newnetwork --name bb centos:7 

as you see these two containers are attached to the "newnetwork" and not to the default-bridge network as we specify it 
so..... if you type docker network inspect newnetwork...we are going to see that we have our containers in the containers section
and of course they are  inside the newnetwork...see this below...


------------------------------------------------------------------------------------------------------
mike@mike-VirtualBox:~$ docker network inspect newnetwork
[
    {
        "Name": "newnetwork",
        "Id": "592a337f2c2045d4c1bf50937dcb9ddbcb95912a95496b5c984588b5b48c4192",
        "Created": "2022-03-23T11:03:51.676559443-04:00",
        "Scope": "local",
        "Driver": "bridge",
        "EnableIPv6": false,
        "IPAM": {
            "Driver": "default",
            "Options": {},
            "Config": [
                {
                    "Subnet": "172.18.0.0/16",
                    "Gateway": "172.18.0.1"
                }
            ]
        },
        "Internal": false,
        "Attachable": false,
        "Ingress": false,
        "ConfigFrom": {
            "Network": ""
        },
        "ConfigOnly": false,
        "Containers": {
            "33101d096c4d35698a87abad7d3299a9b905936f03946c262b4bdc4d20bec2b0": {
                "Name": "bb",
                "EndpointID": "5dd7b83340143b38352189b08198e4dca400a259af9b5eff5020397cd6b05de7",
                "MacAddress": "02:42:ac:12:00:03",
                "IPv4Address": "172.18.0.3/16",
                "IPv6Address": ""
            },
            "84f3d478f66a79a240c3ae3ddcdf7658c44e32c79e4c9030fbf50d0600f60ddd": {
                "Name": "aa",
                "EndpointID": "b9e69dac075c800a51646f9a750a2593f369c17b66e03df77d0a2fb58034ddf5",
                "MacAddress": "02:42:ac:12:00:02",
                "IPv4Address": "172.18.0.2/16",
                "IPv6Address": ""
            }
        },
        "Options": {},
        "Labels": {}
    }
]
------------------------------------------------------------------------------------------------------


so now lets try to ping the containers 


mike@mike-VirtualBox:~$ docker exec aa bash -c "ping bb".....yes its answering
same goes for the other and goes by saying 
basically this is the main difference between the default networks and the networks that you create and basically in the default
network you cannot ping containers using the name and in the networks that you create you can ping the containers by using the name 
and that is cool as you dont need to remember the ip addresses through tha name you can do the trick 


how to open vs code from terminal ubuntu Code Answer

https://www.codegrepper.com/code-examples/whatever/how+to+open+vs+code+from+terminal+ubuntu
Launch VS Code.
Open the Command Palette (Cmd+Shift+P) and type 'shell command' to find the Shell Command: Install 'code' command in PATH command.
Restart the terminal
Navigate to project folder in terminal, 
Type code . press enter


see for  ServiceDiscovery
google : docker container service discovery
Networking for Docker Containers Part II: Service Discovery for Traditional Apps and Microservices
https://d2iq.com/blog/networking-docker-containers-part-ii-service-discovery-traditional-apps-microservices




81.connect and disconnect networks
----------------------------------
hello and welcome back in this lesson we are going to learn how to communicate two containers to different networks 
so let me just create a new network and we call it todayy

mike@mike-VirtualBox:~$ docker network create -d bridge --subnet 172.30.0.0/16 --gateway 172.30.0.1 todayy
okay we get the hash, and now we are going to create a second network 
mike@mike-VirtualBox:~$ docker network create -d bridge --subnet 172.31.0.0/16 --gateway 172.31.0.1 tommorow

mike@mike-VirtualBox:~$ docker network create -d bridge --subnet 172.30.0.0/16 --gateway 172.30.0.1 todayy
b8ead7b2a5cfc19391c59d8392fb226daec6508c1e54b1fbf36470da70afcdea
mike@mike-VirtualBox:~$ docker network create -d bridge --subnet 172.31.0.0/16 --gateway 172.31.0.1 tommorow
f12d915120bc7684e4e860b220e6dd05a6f3ef15e14145e571d5430c5dbe7959


and now lets go to create two containers where the first container will be attached (binded) to todayy and the 
second one will be attached to tommorow

so lets say 

mike@mike-VirtualBox:~$ docker run -dti --name today --network todayy  centos:7
mike@mike-VirtualBox:~$ docker run -dti --name tommoroww --network tommorow  centos:7



mike@mike-VirtualBox:~$ docker run -dti --name today --network todayy centos:7
Unable to find image 'centos:7' locally
7: Pulling from library/centos
2d473b07cdd5: Pull complete
Digest: sha256:c73f515d06b0fa07bb18d8202035e739a494ce760aa73129f60f4bf2bd22b407
Status: Downloaded newer image for centos:7
96385bc31ce5d6c9f3fa10b0a3c6bd5f30d5940f026a20761e47c0094e72ad54
mike@mike-VirtualBox:~$ docker run -dti --name tommoroww --network tommorow  centos:7
89ed09db8f57521028b47486b8bba6bcb0cd7ef45ce1563cad6faa1868178d4e
mike@mike-VirtualBox:~$

so now hat happens if you try to ping the container today from the contaner tommoroww
remember that these containers are located to different networks 


so if we type docker exec today bash -c "ping tommoroww" we will get the awesome answer that tommoroww 
is a name or a service that is not known from the  today'S Container'S NETWORKS  

mike@mike-VirtualBox:~$ docker exec today bash -c "ping tommoroww"
ping: tommoroww: Name or service not known

so basically the container with the name "today" cannot ping the container tommoroww as they are in two different networks 
rememember that in the previous lesson we learned how to communicate containers iside of the same network 
so you know that if i create another container "yesterday" in the network "tommorow" then these  two containers (yesterday and tommoroww) 
will be able to communicate as they will be in the same network
but f you want to ping a container that is in a different network you will have the error above (ping : "name or service not known") as the containers 
are fully isolated in their own networks.

so how we can make this work;
so well there is a command called "docker network connect" and this command allows you to connect containers in different networks 


mike@mike-VirtualBox:~$ docker network connect 


so if we type this to the terminal we will see that we need to provide 2 arguments (network and container) 
that you want to connect 

mike@mike-VirtualBox:~$ docker network connect
"docker network connect" requires exactly 2 arguments.
See 'docker network connect --help'.

Usage:  docker network connect [OPTIONS] NETWORK CONTAINER

Connect a container to a network
mike@mike-VirtualBox:~$



so say that we want to connect container "tommoroww" to the network of the container "today" 
i.e. the network "tommorow" to the network "todayy" because it is in "todayy" where we have the container today 
but now we want to connect the container "tommoroww" to the network "todayy" to be able to ping the container that we want to 

so we say +"docker network connect"+to the network todayy+"todayy"+and the container tommoroww+"tommoroww" 

mike@mike-VirtualBox:~$ docker network connect todayy tommoroww

so basically we are connecting this container : tommoroww to this network todayy with the voiew to provide communication among these two 
containers...so if we hit enter then you see that the command gets succesfully executed 
and lets go to see a new ping command from 
the network of the container today to the network tommorow (container tommoroww)


mike@mike-VirtualBox:~$ docker exec today bash -c "ping tommoroww"

and now we see that it is now working 
so basically what we did is that we just connected the container today to the network tommorow
and thus the network tommoroww is able to reach the container today and the same goes for the opposite direction 
as they are in the same network now 
i mean the network of tommorow  that has the container tommoroww is now in the network of the container today
so all the containers in the network todayy are able to communicate 
and that's how you connect containers in different networks by using the "docker network connect" command

but now what happens if you finish testing and you want to dosconnect the container tommoroww from the network todayy?
well, basically you can do the same thing 

mike@mike-VirtualBox:~$ docker network connect todayy tommoroww

but instead of using the "docker network connect" command you can use the "docker network disconnect" which disconnects the 
container tommoroww from the network todayy
so now if you try to ping the same components the commad will fail as these two are now disconnected 
and thus the container today is no longer able to see the container tommoroww that is located in the network tomorow

now we understand how to connect containers in different networks basically you just need to say 
docker network connect....connect to this network's container
and that will do the job  
 and if you want to disconnect them you simply replace the connect with disconnect 
 or in other words 
 docker please disconnect from this network this container 

 82.Assign a static ip to a container 
 -------------------------------------

hello and welcome back in this lesson we are going to learn how to assign a static ip addrees to a container 
well i d9ont know why you would like to assign an ip address...a static ip address to a container 
because remember that in the networks that you create whih are called user defined networks you can reach containers by using the name 
so i think that you dont need to use ip addresses to much 
but for some reason in the future you need to assign an ip address to a container you can do it in the way below
the first thing that you must keep in mind is that you can only assign ip addreses to containers using  networks that you create.
so if you want to assign a static ip address in the bridge network i.e. in the default one you will have problems 

but of you create some network and then you try to assign an ip address using that network then it will work 

lets create another network 

mike@mike-VirtualBox:~$ docker network create -d bridge --subnet 172.40.0.0/16 --gateway 172.40.0.1 ipnetwork

so now if we create a container without providing any ip address, so you just bind a container to the network 
so you say 
mike@mike-VirtualBox:~$ docker run --network networkt --name test1 centos:7

and now if you inspect this container : docker inspect  container hash from above


it will show you that it will inform you that the container above will inherit an ip address from the network itself 
e.g. you will see that the IPAddress : 172.40.0.2 is automatically taken 

so now what if you want to put here 50 or 100 instead of 2 ?
well you need to use something different in the container i.e. you need to provide a new flag that bears the name --ip and
remember that this flag works for networks that you create and after that flag you provide the ip that you need : --ip 172.40.0.100

mike@mike-VirtualBox:~$ docker run --network networkt --ip  172.40.0.100 --name test2 centos:7

so now if you inspect that container : " docker inspect test2 "
you will see that the container took the ip address that we told him to


so this might be useful for the future and if at any time you need to assign an ip address to a container this is how you do it 



83.the host network
--------------------
hello and welcome in this lesson we are going to learn about the host network e.g. if you type docker network ls 
you can see all the networks that you have  
and you have some defaults networks and some other networks that you create but here there is a network that bears the name 
host network and it comes by default and thus its a network that you cannot delete 

network is    name   driver    scope
265dvhgd327   host   host      local

as you see it uses the driver host instead of the bridge driver and this host driver actually allows you to create 
networks that share the network attribute of your docker host, 
so basically if you create a container using the host network it will be exactly the same thing in network in terms as 
your docker host 
so it will inherit the same ip address 
                            all of the interfaces 
it will inherit pretty much everything from the network configuration  of your docker host 
so let me just show you, if i create a new container a temporary container 


mike@mike-VirtualBox:~/ docker run --rm -ti centos:7 bash

[root@d1dbe8d300ed /]# hostname
d1dbe8d300ed
[root@d1dbe8d300ed /]#

and remember that these are created in the default network and you see here that we are in a random hostname (d1dbe8d300ed) which is 
actually the id of the container so if we type "hostname" we can see that it but if you go outside of the container you will see that the hostname
of your machine is actually diffeerent 
so basifcally when you create a container in a bridge network it actually isolates the container 
and it inherits a different it inherits a different hostname  
then you create a new container but now you join this container  to the host network 
you will see something that is different you will see that your container inherits preety much everything from your docker host 

mike@mike-VirtualBox:~/ docker run --rm -ti --network host centos:7 bash

so now if you type hostname then you will see that you have exactly the same hostname with your machine 

[root@d1dbe8d300ed /]# hostname
ip-172.31....internal

and if you take a look at your dns at your host's file at all of the networking and attributes you actually have the network of your host but 
inside of a container but you see that the user is different i.e. from mike or coffee it becomes root....., so the only one thing here that is sured here 
is the host network 
so basically if you use the driver host what you are doing is that you are sharing exactly the same thing that you have in you docker host 

so if you create a container and you bind that container to the host network then your container will inherit exactly the same attributes that your docker host has 
in networking terms 

84.the none network
--------------------

here we are gonna talk about the none network....if you type docker network ls 
at the end you are going to see the none network and this network doesnt have any driver 
so as you may guess this network doesn't have any kind of network its like if you bind a container
to that network thew container is competely dieconnected it doesn't have any subnet any ip addresses any interfaces 
its just a container without network 

so lets try that....and we can use the none network which co9mes by default and thus it comes by default and of course you can provide the centos image 

mike@mike-VirtualBox:~/ docker run --rm -dti --name none --network none centos:7 bash

and now if we type docker ps -l (latest) the system will call the last container that was created which is our none container 
so as you see here the port is empty as you dont have any information about the port and if we go inside of the container 
through "docker exec -ti 8xcbsb8 bash" you will see that you have the hostname but if you type "ip a" no we try 
"docker inspect" instead but first lets exit from the container 
and make it like this 
"docker inspect 8xcbsb8" and move to the networks section you will see that the gateway is empty and the same goes for the ipaddress
and it basically it doesn't have any kind of network its joined to a network which is none but this netwrok doesn;'t have any driver 
which means that itys an empty network 
so  if in the future for some reason you need to put a container somewhere where you don't need any network and i dont know probably you need to isolate that 
container and you dont need any network you can use this network 

----------------------------------9.Docker networks -learn how to get containers communicated----end


start----------------------------10.Docker compose put everything you learned together-------

86.introduction why compose?
----------------------------
we are going to do a small introduction what is docker compose '
basically docker compose is a tool that allows you to create multi container applications 
and what di i mean by saying "multi container application"?
well say that you want to create a word press site and to do it you need a web server which 
has apache or nginx and you also need a database 
so probably you need two containers : one for the web server and the other for the database 
so you can always go ahead and create that using "docker run" but thats going to be a little bit complicated 
becaus what if you start passing a lot of flags a lot of volumes a lot of environmental variables in the run of that container 
then its going to be complicated to handle it and here is where docker compose comes to help you 
it helps you organize  in your configurations because you can create a simple text file and you can define all of the configurations 
for your containers,
so for example say that you want to create a wordpress site-container and then a database container 
then in your docker compose file you need to create the nginx container with these configurations and i want to create this database with these configurations
and then 
it takes you only one command to create all of those services from the file that you just created 
it actually reduces the work a lot and its super helpful....you are going to see it 
but as i told you docker compose allows you to manage images containers volumes and networks all in one yaml file 


87.how do i install docker compose ?
------------------------------------
        docker compose  H/Y , 
         "docker compose installation"
      
-linux
-windows
-mac
-windows server 
    Linux     


mike@mike-VirtualBox:~ 
sudo curl -L "https://github.com/docker/compose/releases/download/1.29.2/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
% Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
100   664  100   664    0     0   1405      0 --:--:-- --:--:-- --:--:--  1406
100 12.1M  100 12.1M    0     0  6245k      0  0:00:01  0:00:01 --:--:-- 8232k
mike@mike-VirtualBox:~


and its as simple as that........  documentation     executable permissions to the binary 
         accomplish

mike@mike-VirtualBox:~ chmod+x /usr/local/bin/docker-compose......and cool

     : 
sudo curl -L "https://github.com/docker/compose/releases/download/1.29.2/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
      Github         ( /usr/local/bin/docker-compose)    flag "-"

             : " /usr/local/bin/docker-compose"
   it works.....
-------------------------------------------------------------------------------------------------------------------------------
mike@mike-VirtualBox:~$ /usr/local/bin/docker-compose
Define and run multi-container applications with Docker.

Usage:
  docker-compose [-f <arg>...] [--profile <name>...] [options] [--] [COMMAND] [ARGS...]
  docker-compose -h|--help

Options:
  -f, --file FILE             Specify an alternate compose file
                              (default: docker-compose.yml)


  -p, --project-name NAME     Specify an alternate project name
                              (default: directory name)

  --profile NAME              Specify a profile to enable

  -c, --context NAME          Specify a context name

  --verbose                   Show more output

  --log-level LEVEL           Set log level (DEBUG, INFO, WARNING, ERROR, CRITICAL)

  --ansi (never|always|auto)  Control when to print ANSI control characters

  --no-ansi                   Do not print ANSI control characters (DEPRECATED)

  -v, --version               Print version and exit

  -H, --host HOST             Daemon socket to connect to

  --tls                       Use TLS; implied by --tlsverify

  --tlscacert CA_PATH         Trust certs signed only by this CA

  --tlscert CLIENT_CERT_PATH  Path to TLS certificate file

  --tlskey TLS_KEY_PATH       Path to TLS key file

  --tlsverify                 Use TLS and verify the remote

  --skip-hostname-check       Don't check the daemon's hostname against the
                              name specified in the client certificate

  --project-directory PATH    Specify an alternate working directory
                              (default: the path of the Compose file)
  --compatibility             If set, Compose will attempt to convert keys
                              in v3 files to their non-Swarm equivalent (DEPRECATED)
  --env-file PATH             Specify an alternate environment file

Commands:
  build              Build or rebuild services
  config             Validate and view the Compose file
  create             Create services
  down               Stop and remove resources
  events             Receive real time events from containers
  exec               Execute a command in a running container
  help               Get help on a command
  images             List images
  kill               Kill containers
  logs               View output from containers
  pause              Pause services
  port               Print the public port for a port binding
  ps                 List containers
  pull               Pull service images
  push               Push service images
  restart            Restart services
  rm                 Remove stopped containers
  run                Run a one-off command
  scale              Set number of containers for a service
  start              Start services
  stop               Stop services
  top                Display the running processes
  unpause            Unpause services
  up                 Create and start containers
  version            Show version information and quit
mike@mike-VirtualBox:~$
-------------------------------------------------------------------------------------------------------------------------------


    docker compose           "docker-compose version"

mike@mike-VirtualBox:~$ docker-compose version 
docker-compose version 1.29.2, build 5becea4c
docker-py version: 5.0.0
CPython version: 3.7.10
OpenSSL version: OpenSSL 1.1.0l  10 Sep 2019
mike@mike-VirtualBox:~$

        install  docker compose


88.Lets go first steps in compose
---------------------------------
   section    docker compose         
docker compose file,    docker compose           
multiplecontainer applications         "docker-compose.yaml"      
s define   stuff,  containers,   services     .

      directory  "docker compose"    ......


mike@mike-VirtualBox:~$ cd /Desktop
mike@mike-VirtualBox:~/Desktop$ mkdir docker-compose
mike@mike-VirtualBox:~/Desktop$ cd  docker-compose
mike@mike-VirtualBox:~/Desktop/docker-compose$ ll.........          
docker-compose.yml.........   "docker-compose.yaml"     dockerfile

        "nginx container" 

mike@mike-VirtualBox:~/Desktop/docker-compose$ docker run -d --name nginx -p 8080:80 nginx:alpine

     container           browser  
        docker compose       
docker run  docker remove  docker everything  command line ?
      arguments    options       
(docker run -d --name nginx -p 8080:80 nginx:alpine)         reduce your efforts   
        typing       
o      file like this.......

mike@mike-VirtualBox:~/Desktop/docker-compose$ code .        visual studio code     (docker-compose)
                                                               ....
         docker-compose file     (4) options:

|---------------|
|i  . version   |
|ii . services  |
|iii. volumes   |
|iv . networks  |
|---------------|...............       docker compose file,     , 
                                  version  services        optional 
                                       version    service 
                                    volumes   networks is totally optional.


 ok        yaml,                google  
 ....
google : docker compose version,      versions     ,      versions 1,2  3
                  3  3.7,3.6   
 "version: 3",            "docker run"         docker compose 
          docker compose?
  -d   by default  docker compose        docker compose file.
        container    specify  container name  docker compose ?
   definitions   containers         services,       
 services        service      nginx container ..
 services:
    web:                service...its only for reference      
         define      service 
                  web service     web service     web, nginx  
                  ,      web.....    web     provide   
           container,     -d  by default     container     
             ;
            documentation  discovery channel        "docker compose file reference"         stuffs
                "how tom define a container name in docker compose file"      attribute  
          container name......."container_name: myname"
             
         -------------------------------
         version: "3"
         services:
           web:
            container_name: nginxx
        -------------------------------
             port,  ;
          documentation   
        ports:
        -"8080:80"
                define  image   docker compose,    documentation   define 
          
        image: nginx:alpine 
           :     image        launch  container 
          docker compose         :
         
         version: "3"
         services:
           web:
            container_name: nginxx
            ports:
              -"8080:80"
            image: nginx:alpine
        

           "docker-compose"  terminal        "docker-compose.yml"
     
        container        ;
    "docker-compose up -d"....         services   containers 
  docker ps           

         docker-compose -d    
   docker-compose                   deployed 
    docker-compose up -d      yml     created 
   docker-compose   flexibility      services  containers     
  

possibly now you understand the difference among the docker run and the docker compose 
         destroy  container     docker compose    docker-compose down 
   down      remove   resources    defined  docker-compose.yml file  


89.enviroment variables in compose
----------------------------------
   '         enviroment variables  docker compose,
           service      , 
    "service"        services (web)    options 
  service,     specify :

-container name
-ports
-image......
-   


     ....


mike@mike-VirtualBox:~$ mv docker-compose.yml docker-compose-nginx.yml

        docker-compose file      mysql service 

version: "3"
services:
  db:            service          
             keep in mind   indentation   ,   spaces   component services
              parent component  db component     db    options....
            ok  db service   mysql....
    image: mysql:5.7
    container_name:mysqll
    ports: 
      - "3306:3306"        ,    mysql root password,       
                        define environment variables in docker compose?
                          
                        ----------------i----------------
                        enviroment:
                          RACK_ENV: development
                          SHOW: 'true'
                          SESSION_SECRET:
                        ----------------i----------------
                        ----------------ii---------------
                        enviroment:
                          RACK_ENV=development
                          SHOW=true
                          SESSION_SECRET:
                        ----------------ii---------------

     environmnet variables  "environment"         
    db service         mysql container o     image "mysql:5.7" 
  .

version: "3"
services:
  db: 
    image: mysql:5.7
    container_name:mysqll
    ports: 
      - "3306:3306"
    enviroment:
        MYSQL_ROOT_PASSWORD=123456
        SHOW=true

    terminal     docker-compose       
    docker-compose.yml        visual studio code



mike@mike-VirtualBox:~$ cd /Desktop
mike@mike-VirtualBox:~/Desktop$ cd  docker-compose
mike@mike-VirtualBox:~/Desktop/docker-compose$ code docker-compose.yml   

               

mike@mike-VirtualBox:~/Desktop/docker-compose$ docker-compose up -d

     docker     "docker-compse.yml"      services 
   ,   enter hit   mysql image        Internet 
     download    "creating mysql ...done"

mike@mike-VirtualBox:~/Desktop/docker-compose$ docker-compose up -d
WARNING: Found orphan containers (nginxx) for this project. If you removed or renamed this service in your compose file, you can run this command with the --remove-orphans flag to clean it up.
Pulling db (mysql:5.7)...
5.7: Pulling from library/mysql
a4b007099961: Pull complete
e2b610d88fd9: Pull complete
38567843b438: Pull complete
5fc423bf9558: Pull complete
aa8241dfe828: Pull complete
cc662311610e: Pull complete
9832d1192cf2: Pull complete
3f242378e320: Pull complete
cc65503c0186: Pull complete
ce8944d50437: Pull complete
597d59a9a424: Pull complete
Digest: sha256:c8f68301981a7224cc9c063fc7a97b6ef13cfc4142b4871d1a35c95777ce96f4
Status: Downloaded newer image for mysql:5.7
Creating mysql ... done



      docker ps    container   "mysqll"  ()    instructions     
docker-compose.yml



mike@mike-VirtualBox:~/Desktop/docker-compose$ docker ps
CONTAINER ID   IMAGE          COMMAND                  CREATED         STATUS         PORTS                                                  NAMES
ea7472e5349c   mysql:5.7      "docker-entrypoint.s"   4 minutes ago   Up 4 minutes   0.0.0.0:3306->3306/tcp, :::3306->3306/tcp, 33060/tcp   mysqll
642a723604b5   nginx:alpine   "/docker-entrypoint."   16 hours ago    Up 16 hours    0.0.0.0:9090->80/tcp, :::9090->80/tcp                  nginxx
mike@mike-VirtualBox:~/Desktop/docker-compose$

    container displayed above     "cat"  yaml              .

mike@mike-VirtualBox:~/Desktop/docker-compose$ cat docker-compose.yml

    container      "docker exec -ti mysqll bash"       docker host   container
   "env | grep MYSQL"       instructions      yaml     mysql instructions.
     "env | grep SHOW"            show

mike@mike-VirtualBox:~/Desktop/docker-compose$ docker exec -ti mysqll bash

        environment variables  docker compose file,       ....


       "env_file"            - 
  .. "env_file: env.txt",       env.txt  current directory      
docker-compose,         instruction "environment"  docker-compose.yml 
   show=true   show=file
   remove   enviroment instruction   docker-compose.yml    "env_file: env.txt"


mike@mike-VirtualBox:~/Desktop/docker-compose$ code env.txt


docker compose.yml
------------------
version: "3"
services:
  db: 
    image: mysql:5.7
    container_name:mysqll
    ports: 
      - "3306:3306"
    env_file: env.txt

env.txt
------------------
MYSQL_ROOT_PASSWORD=123456
SHOW=file

      "docker-compose up -d"                
recreate  container    status  docker compose file 
        mysql  up to date  ....
   docker-compose.yml             docker-compose.yml   
      "docker-compose up -d"    "recreating mysql ...done"
   recreates     o docker       container recreate         
 docker-compose.yml             env.txt file
      container     container    up and running
    docker host  conatiner    "docker exec -ti bash mysql"       
        show  file   true           
env.txt   docker-compose.yml file       option "env_file"       env.txt


mike@mike-VirtualBox:~/Desktop/docker-compose$ docker exec -ti bash mysql
root@f4a697a8edc0:/# env | grep SHOW


       environment variables  docker-compose  
       environment instructions         instruction 
"env_file"             .. env.txt ("env_file: env.txt")          
 .

90. volumes in Compose
-----------------------
       volumes  docker-compose     containers, images, networks  kai volumes     

mike@mike-VirtualBox:~/Desktop/docker-compose$ docker ps -a       docker rm -f $(docker ps -a -q)
mike@mike-VirtualBox:~/Desktop/docker-compose$ docker images      docker rmi -f $(docker images -q)
mike@mike-VirtualBox:~/Desktop/docker-compose$ docker volume ls   docker volume rm -f $(docker volume ls -q )

        container   docker-compose.yml file       container 
    docker-compose.....docker-compose -f docker-compose.yml down


         volumes  docker-compose        map  volume  mysql server 
  :

version: "3"
services:
  db: 
    image: mysql:5.7
    container_name:mysqll
    ports: 
      - "3306:3306"
    env_file: env.txt

    ;
    volumes:       path          map,
  directories    opt           docker-compose directory

mike@mike-VirtualBox:~/Desktop/docker-compose$ sudo mkdir mysql.........   directory    component    provide  volume


-----------------------------
volumes:
  - "/mysql:/var/lib/mysql".........          (mysql)     "docker-compose up -d"    
                                  "cd .."
                            directory      
                   /mysql:/var/lib/mysql.... map    mysql directory    docker host  path  container (/var/lib/mysql)

-----------------------------
docker-compose.yml (complete)
version: "3"
services:
  db: 
    image: mysql:5.7
    container_name:mysqll
    ports: 
      - "3306:3306"
    env_file: env.txt
    volumes:
      - "/mysql:/var/lib/mysql"

          "docker-compose -f docker-compose.yml up -d"

*    ll  directory mysql         docker-compose directory     
    docker-compose.yml file....   "/mysql:/var/lib/mysql"   "/docker-compose/mysql:/var/lib/mysql"
   
        mysql directory     define bind volumes  docker compose  
      define  normal volume;
              volumes    
  optional   docker compose


         docker-compose file     (4) options:

|---------------|
|i  . version   |
|ii . services  |
|iii. volumes   |
|iv . networks  |
|---------------|...............       docker compose file,     , 
                                  version  services        optional 
                                       version    service 
                                    volumes   networks is totally optional.


     volume   docker compose           volume tag    
   version   services :

volumes:           
   mysql_volume:

  volumes         normal volume,        map   volume  container ?
             path  doker host " mysql_volume:/var/lib/mysql"
  "/var/lib/mysql"   path     mapping 

version: "3"
services:
  db: 
    image: mysql:5.7
    container_name:mysqll
    ports: 
      - "3306:3306"
    env_file: env.txt
    volumes:
      - "mysqlvolume:/var/lib/mysql"
volumes:
   mysqlvolume:


         docker-compose -f docker-compose.yml up -d  
 and yes  recreate  mysql       "docker volume ls"    volume
   mysqlvolume      docker-compose.yml file

mike@mike-VirtualBox:~/Desktop/docker-compose$ docker volume ls

DRIVER   VOLUME NAME
local    docker-compose_mysqlvolume

    dockers     docker-compose         
     service   define    docker       volume      .
      volume "docker-compose_mysqlvolume"     docker redirectory 
    " docker info | grep -i root "      root directory  docker    
 /mnt/docker 
*  docker hosts    .....

           volume section   sudo su       "docker-compose_mysqlvolume"
     _data directory             container .


mike@mike-VirtualBox:/mnt$ cd docker
bash: cd: docker: Permission denied
mike@mike-VirtualBox:/mnt$ cd docker/
bash: cd: docker/: Permission denied

mike@mike-VirtualBox:/mnt$ sudo su
root@mike-VirtualBox:/mnt# cd docker
root@mike-VirtualBox:/mnt/docker# ll
total 60
drwx--x--- 13 root root  4096 Mar 29 06:20 ./
drwxr-xr-x  8 root root  4096 Mar 22 08:40 ../
drwx--x--x  4 root root  4096 Mar  1 05:47 buildkit/
drwx--x---  3 root root  4096 Mar 29 06:50 containers/
drwx------  3 root root  4096 Mar  1 05:47 image/
drwxr-x---  3 root root  4096 Mar  1 05:47 network/
drwx--x--- 16 root root 12288 Mar 29 06:50 overlay2/
drwx------  4 root root  4096 Mar  1 05:47 plugins/
drwx------  2 root root  4096 Mar 29 06:20 runtimes/
drwx------  2 root root  4096 Mar  1 05:47 swarm/
drwx------  2 root root  4096 Mar 29 06:20 tmp/
drwx------  2 root root  4096 Mar  1 05:47 trust/
drwx-----x  3 root root  4096 Mar 29 06:50 volumes/
root@mike-VirtualBox:/mnt/docker# cd volumes
root@mike-VirtualBox:/mnt/docker/volumes# ll
total 44
drwx-----x  3 root root  4096 Mar 29 06:50 ./
drwx--x--- 13 root root  4096 Mar 29 06:20 ../
brw-------  1 root root  8, 1 Mar 29 06:20 backingFsBlockDev
drwx-----x  3 root root  4096 Mar 29 06:50 docker-compose_mysqlvolume/
-rw-------  1 root root 65536 Mar 29 06:50 metadata.db
root@mike-VirtualBox:/mnt/docker/volumes# cd docker-compose_mysqlvolume/
root@mike-VirtualBox:/mnt/docker/volumes/docker-compose_mysqlvolume# ll
total 12
drwx-----x 3 root    root   4096 Mar 29 06:50 ./
drwx-----x 3 root    root   4096 Mar 29 06:50 ../
drwxrwxrwt 5 vboxadd vboxsf 4096 Mar 29 06:51 _data/
root@mike-VirtualBox:/mnt/docker/volumes/docker-compose_mysqlvolume# cd _data
root@mike-VirtualBox:/mnt/docker/volumes/docker-compose_mysqlvolume/_data# ll
total 188484
drwxrwxrwt 5 vboxadd vboxsf     4096 Mar 29 06:51 ./
drwx-----x 3 root    root       4096 Mar 29 06:50 ../
-rw-r----- 1 vboxadd vboxsf       56 Mar 29 06:50 auto.cnf
-rw------- 1 vboxadd vboxsf     1676 Mar 29 06:50 ca-key.pem
-rw-r--r-- 1 vboxadd vboxsf     1112 Mar 29 06:50 ca.pem
-rw-r--r-- 1 vboxadd vboxsf     1112 Mar 29 06:50 client-cert.pem
-rw------- 1 vboxadd vboxsf     1676 Mar 29 06:50 client-key.pem
-rw-r----- 1 vboxadd vboxsf     1352 Mar 29 06:51 ib_buffer_pool
-rw-r----- 1 vboxadd vboxsf 79691776 Mar 29 06:51 ibdata1
-rw-r----- 1 vboxadd vboxsf 50331648 Mar 29 06:51 ib_logfile0
-rw-r----- 1 vboxadd vboxsf 50331648 Mar 29 06:50 ib_logfile1
-rw-r----- 1 vboxadd vboxsf 12582912 Mar 29 06:51 ibtmp1
drwxr-x--- 2 vboxadd vboxsf     4096 Mar 29 06:50 mysql/
drwxr-x--- 2 vboxadd vboxsf     4096 Mar 29 06:50 performance_schema/
-rw------- 1 vboxadd vboxsf     1680 Mar 29 06:50 private_key.pem
-rw-r--r-- 1 vboxadd vboxsf      452 Mar 29 06:50 public_key.pem
-rw-r--r-- 1 vboxadd vboxsf     1112 Mar 29 06:50 server-cert.pem
-rw------- 1 vboxadd vboxsf     1676 Mar 29 06:50 server-key.pem
drwxr-x--- 2 vboxadd vboxsf    12288 Mar 29 06:51 sys/
root@mike-VirtualBox:/mnt/docker/volumes/docker-compose_mysqlvolume/_data#

91.Networking in compose
------------------------
          docker compose,      docker-compose file   ,

version: "3"
services:
   web:          define  web service 
      image: nginx:alpine
      container_name:nginx

              service    db    
  image      Image    Image mysql:5.7       container name 

version: "3"
services:
   web:       
      image: nginx:alpine
      container_name:nginx
    db:
     image: mysql:5.7
     container_name:mysql

      ,   define   ;

     section          optional ' docker-compose file 
component      Level   services,version .
     instruction       
 

networks:
   testnet:

           testnet,        assign    network 
 container ?
 
 documentation      "testnet"  n volume o   myvolume
          volumes   file 

ut the thing is how do you include one container in the network ?
    define  property    service    property  networks    define  
    ,    

version: "3"
services:
   web:       
      image: nginx:alpine
      container_name:nginx
      networks:
         - testnet       web guy    testnet
    db: 
     image: mysql:5.7
     container_name:mysql
     networks:
        - testnet          join  db service   testnet network    
networks:                  web service 
    testnet:                  

       docker-compose.yml file      docker-compose -f docker-compose.yml up -d
           containers mysql  nginxx 
  definition  docker-compose     service  web    db
     docker ps      
           ....OXI      
        service  db    environment variable   mysql  

environment:
    - MYSQL_ROOT_PASSWORD=12345 

          option for a configuration       docker compose up 
  docker   figure out          services recreate 


         " docker network ls "              docker-compose.yml file
docker-compose_test_net......    docker-compose  include         test_net       
 .
  containers    joint   testnet         (ping)           
       docker compose        web application   database application    
docker compose file.
 ' docker ps     mysql container  Nginx container,     ping   

*             conatiners     network section     
 ping  containers         . 

mike@mike-VirtualBox:~/Desktop/docker-compose$ docker exec nginxii bash -c "ping mysqlii"

mike@mike-VirtualBox:~/Desktop/docker-compose$ docker exec nginxii bash -c "ping mysqlii"
OCI runtime exec failed: exec failed: container_linux.go:380: starting container process caused: 
exec: "bash": executable file not found in $PATH: unknown

         nginx:alpine   bash      sh       
  Ping  nginx    nginx:alpine  centos:7    containers' names  network names .

version: "3"
services:
   web:       
      image: centos:7
      container_name:cent
      networks:
         - testnett   
    db: 
     image: mysql:5.7
     container_name:coffee
     networks:
        - testnett    
networks:            
    testnett:   


     container coffee   centos     cmd  its "/bin/bashed"
     provide  -ti flag        
    docker compose ?
 
 tty: true

   
version: "3"
services:
   web:       
      image: centos:7
      container_name:cent
      networks:
         - testnett   
      tty: true
    db: 
     image: mysql:5.7
     container_name:coffee
     networks:
        - testnett    
networks:            
    testnett:   


  docker-compose -f docker-compose.yml up -d,        -alive
    Ping 


mike@mike-VirtualBox:~/Desktop/docker-compose$ docker exec cent bash -c "ping coffee"
and yes     
       service names ..

mike@mike-VirtualBox:~/Desktop/docker-compose$ docker exec cent bash -c "ping web"
  

mike@mike-VirtualBox:~/Desktop/docker-compose$ docker exec coffee bash -c "ping cent"
mike@mike-VirtualBox:~/Desktop/docker-compose$ docker exec coffee bash -c "ping web"
  


     s ping  containers         service 
             service    
   container       container 
     ..          .... 


92.build docker images using docker compose
--------------------------------------------
        build images   docker-compose file,     
 image      ,           docker compose 



version: "3"
services:
   web:       
      image: centos:7
      container_name:cent

     built   image,      image built   docker compose;
     option    build             
dockerfile    directory       


version: "3"
services:
   web:       
      image: centos:7
      container_name:cent
      build: .


    ,            docker-compose build;

 docker-compose build       build instruction  docker compose file     
   build   images,      enter  terminal  ubuntu       
dockerfile


mike@mike-VirtualBox:~/Desktop/docker-compose$ docker-compose build
Building web
unable to prepare context: unable to evaluate symlinks in Dockerfile path: lstat /home/mike/Desktop/docker-compose/Dockerfile: 
no such file or directory
ERROR: Service 'web' failed to build : Build failed
mike@mike-VirtualBox:~/Desktop/docker-compose$ docker-compose -f docker-compose.yml build
Building web
unable to prepare context: unable to evaluate symlinks in Dockerfile path: lstat /home/mike/Desktop/docker-compose/Dockerfile: 
no such file or directory
ERROR: Service 'web' failed to build : Build failed
mike@mike-VirtualBox:~/Desktop/docker-compose$


      dockerfile 

mike@mike-VirtualBox:~/Desktop/docker-compose$ code Dockerfile

  '          centos (from centos:7)
         instructions        
     web server       
      directory    :

 run mkdir /opt/test

             container   docker-compose   
 docker-compose build         image  
        dockerfile     .. Dockerfile2 
       image   default     Dockerfile  Dockerfile
            
   docker-compose     property build   property context     
    context   current directory  (context: .)        property dockerfile   
       Dockerfile      
  
 build:
    context: .
    dockerfile: Dockerfile2

  ....      dockerfile     folder     optt
   "docker-compose build -f docker-compose.yml build"
  error   dockerfile2    

Building web
unable to prepare context: unable to evaluate symlinks in Dockerfile path: lstat /home/mike/Desktop/docker-compose/Dockerfile2: 
no such file or directory
ERROR: Service 'web' failed to build : Build failed

       docker-compose    Property context         
 Dockerfile2

version: "3"
services:
   web:       
      image: myimage
      container_name:cent
      build: .
      context: optt
      dockerfile:Dockerfile2


from centos:7
run mkdir /opt/test

    

     build images    provide  dockerfile    provide   context    dockerfile  

93.Overwritte the cmd of an image with compose
----------------------------------------------
      override  cmd instruction  image     docker-compose
     override  cmd  image      container....
    cmd    argument  docker run 
       docker-compose?
    docker-compose file       container o     centos:7 image
     centos      cmd instruction    valid 
   docker-compose     valid cmd   property command

version: "3"
services:
   something:       
      image: centos:7
      container_name:threecents
      command: python -m SimpleHTTPServer
   
           o docker    container   centos image o   
  cmd  overriden 

  ..  docker-compose -f docker-compose.yml up -d
    docker ps,     centos container   up     command "python -m SimpleHTTPServer" 
    docker compose file


94.install drupal + postgreSQL
------------------------------
        applications         containers 
      .
   drupal folder o    docker-compose.yml          
instructions:

version: '3'
services:
  drupal:
    volumes:
      - drupal:/var/www/html
    image: drupal:8-apache
    ports:
      - "8080:80"
    networks:
      - net
  postgres:
    image: postgres:10
    environment:
      POSTGRES_PASSWORD: example
    volumes:
      - $PWD/data:/var/lib/postgresql/data
    networks:
      - net
volumes:
  drupal:
networks:
  net:

      ....            google     
      drupal,docker drupal?
    open source content management platform   wordpress     
          drupal site  .
       docker-compose.yml file   .
     version    3     services     drupal   
      volumes      mapping    .
               image option    volumes    
             drupal service          yml file 
            service   options ..

   
   drupal:
   volumes:
       - drupal:/var/www/html
      image: drupal:8-apache

   
     drupal:
       volumes:
          - drupal:/var/www/html
         image: drupal:8-apache


    volume        mapping  drupal volume [( - drupal:/var/www/html)
         yml file (volumes:  drupal:)     
docker volume create]   /var/www/html   container         
      container   .
     path (/var/www/html);    documentation   image (docker drupal)    
  volumes      path      
in a nutshell       
 map     directory /var/www/html         '   volume drupal
  drupal drupal:8-apache    expose  port.
   networks   net           yml file 
          container   drupal   net
everything cool these are everything for the drupal service (container).

version: '3'
services:
  drupal:
    volumes:
      - drupal:/var/www/html
    image: drupal:8-apache
    ports:
      - "8080:80"
    networks:
      - net


    container postgres  postgres service   drupal        
       image  tag = 10,      
 POSTGRES_PASSWORD: example,         mysql,         volume 
             service   directory  postgres container   
 current path    (  PWD)      5%   data     current path  
        docker     postgres service    net       
       service  drupal     conatiner_name        o docker mechanism 
    random    service       option container_name 
        services (drupal,postgres)
               volumes (a normal one like drupal: - drupal:/var/www/html )   bind
 - $PWD/data:/var/lib/postgresql/data : data
 no worries you can mix them and everything is ok 

 postgres:
    image: postgres:10
    environment:
      POSTGRES_PASSWORD: example
    volumes:
      - $PWD/data:/var/lib/postgresql/data
    networks:
      - net

     ;
      its high time to run the service,      apps     
    :

drupal
joomla
prestashop
react
wp
zabbix

      drupal         data   docker       
   store   postgres data    drupal data   in a docker volume,  lets go ahead    
docker-compose up -d


mike@mike-VirtualBox:~/Desktop/apps/drupal$ docker-compose up -d
creating drupal_drupal_1  ...done
creating drupal_postgres_1  ...done

     containers   up and running   web browser   localhost:8080
   install.php  drupal    setup installation  drupal 

     docker drupal volume         drupal   ls     data 
o        postgress service    docker volume ls    volume   create   
docker-compose file 
     volume       web server files 
     (docker-compose down)  container            
mapping       docker host  container   site       .


  

https://github.com/ricardoandre97/docker-en-resources

---------------------------------10.Docker compose put everything you learned together----end

sto service file theloume na trexioyme to image me 2 environment variables 

-license key 
-app name

running container me environment variables








